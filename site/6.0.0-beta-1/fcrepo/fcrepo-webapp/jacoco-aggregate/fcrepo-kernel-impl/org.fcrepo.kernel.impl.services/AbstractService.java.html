<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractService.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Fedora Repository Deployable Web Application</a> &gt; <a href="../index.html" class="el_bundle">fcrepo-kernel-impl</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.kernel.impl.services</a> &gt; <span class="el_source">AbstractService.java</span></div><h1>AbstractService.java</h1><pre class="source lang-java linenums">/*
 * Licensed to DuraSpace under one or more contributor license agreements.
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * DuraSpace licenses this file to you under the Apache License,
 * Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.fcrepo.kernel.impl.services;

import org.apache.jena.graph.Graph;
import org.apache.jena.graph.Node;
import org.apache.jena.rdf.model.Model;
import org.apache.jena.rdf.model.RDFNode;
import org.apache.jena.rdf.model.Statement;

import org.fcrepo.config.FedoraPropsConfig;
import org.fcrepo.kernel.api.ContainmentIndex;
import org.fcrepo.kernel.api.RdfLexicon;
import org.fcrepo.kernel.api.Transaction;
import org.fcrepo.kernel.api.exception.ACLAuthorizationConstraintViolationException;
import org.fcrepo.kernel.api.exception.MalformedRdfException;
import org.fcrepo.kernel.api.exception.RequestWithAclLinkHeaderException;
import org.fcrepo.kernel.api.exception.ServerManagedPropertyException;
import org.fcrepo.kernel.api.identifiers.FedoraId;
import org.fcrepo.kernel.api.observer.EventAccumulator;
import org.fcrepo.kernel.api.operations.ResourceOperation;
import org.fcrepo.kernel.api.services.MembershipService;
import org.fcrepo.kernel.api.services.ReferenceService;
import org.fcrepo.persistence.api.PersistentStorageSession;
import org.slf4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

import javax.inject.Inject;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Pattern;

import static org.apache.jena.graph.NodeFactory.createURI;
import static org.apache.jena.rdf.model.ResourceFactory.createProperty;
import static org.apache.jena.rdf.model.ResourceFactory.createResource;
import static org.apache.jena.rdf.model.ResourceFactory.createStatement;
import static org.fcrepo.kernel.api.FedoraTypes.FCR_ACL;
import static org.fcrepo.kernel.api.RdfLexicon.DEFAULT_INTERACTION_MODEL;
import static org.fcrepo.kernel.api.RdfLexicon.HAS_MEMBER_RELATION;
import static org.fcrepo.kernel.api.RdfLexicon.INSERTED_CONTENT_RELATION;
import static org.fcrepo.kernel.api.RdfLexicon.INTERACTION_MODELS_FULL;
import static org.fcrepo.kernel.api.RdfLexicon.IS_MEMBER_OF_RELATION;
import static org.fcrepo.kernel.api.RdfLexicon.MEMBERSHIP_RESOURCE;
import static org.fcrepo.kernel.api.RdfLexicon.NON_RDF_SOURCE;
import static org.fcrepo.kernel.api.RdfLexicon.WEBAC_ACCESS_TO;
import static org.fcrepo.kernel.api.RdfLexicon.WEBAC_ACCESS_TO_CLASS;
import static org.fcrepo.kernel.api.RdfLexicon.WEBAC_ACCESS_TO_PROPERTY;
import static org.fcrepo.kernel.api.RdfLexicon.isManagedPredicate;
import static org.fcrepo.kernel.api.rdf.DefaultRdfStream.fromModel;
import static org.slf4j.LoggerFactory.getLogger;


/**
 * Abstract service for interacting with a kernel service
 *
 * @author whikloj
 * @author bseeger
 */

<span class="fc" id="L79">public abstract class AbstractService {</span>

<span class="fc" id="L81">    private static final Logger log = getLogger(ReplacePropertiesServiceImpl.class);</span>

<span class="fc" id="L83">    private static final Node WEBAC_ACCESS_TO_URI = createURI(WEBAC_ACCESS_TO);</span>

<span class="fc" id="L85">    private static final Node WEBAC_ACCESS_TO_CLASS_URI = createURI(WEBAC_ACCESS_TO_CLASS);</span>

    @Autowired
    @Qualifier(&quot;containmentIndex&quot;)
    protected ContainmentIndex containmentIndex;

    @Inject
    private EventAccumulator eventAccumulator;

    @Autowired
    @Qualifier(&quot;referenceService&quot;)
    protected ReferenceService referenceService;

    @Inject
    protected MembershipService membershipService;

    @Inject
    protected FedoraPropsConfig fedoraPropsConfig;

    /**
     * Utility to determine the correct interaction model from elements of a request.
     *
     * @param linkTypes         Link headers with rel=&quot;type&quot;
     * @param isRdfContentType  Is the Content-type a known RDF type?
     * @param contentPresent    Is there content present on the request body?
     * @param isExternalContent Is there Link headers that define external content?
     * @return The determined or default interaction model.
     */
    protected String determineInteractionModel(final List&lt;String&gt; linkTypes,
                                               final boolean isRdfContentType, final boolean contentPresent,
                                               final boolean isExternalContent) {
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        final String interactionModel = linkTypes == null ? null :</span>
<span class="fc" id="L117">                linkTypes.stream().filter(INTERACTION_MODELS_FULL::contains).findFirst().orElse(null);</span>

        // If you define a valid interaction model, we try to use it.
<span class="fc bfc" id="L120" title="All 2 branches covered.">        if (interactionModel != null) {</span>
<span class="fc" id="L121">            return interactionModel;</span>
        }
<span class="fc bfc" id="L123" title="All 6 branches covered.">        if (isExternalContent || (contentPresent &amp;&amp; !isRdfContentType)) {</span>
<span class="fc" id="L124">            return NON_RDF_SOURCE.toString();</span>
        } else {
<span class="fc" id="L126">            return DEFAULT_INTERACTION_MODEL.toString();</span>
        }
    }

    /**
     * Check that we don't try to provide an ACL Link header.
     *
     * @param links list of the link headers provided.
     * @throws RequestWithAclLinkHeaderException If we provide an rel=&quot;acl&quot; link header.
     */
    protected void checkAclLinkHeader(final List&lt;String&gt; links) throws RequestWithAclLinkHeaderException {
<span class="fc" id="L137">        final var matcher = Pattern.compile(&quot;rel=[\&quot;']?acl[\&quot;']?&quot;).asPredicate();</span>
<span class="fc bfc" id="L138" title="All 4 branches covered.">        if (links != null &amp;&amp; links.stream().anyMatch(matcher)) {</span>
<span class="fc" id="L139">            throw new RequestWithAclLinkHeaderException(</span>
                    &quot;Unable to handle request with the specified LDP-RS as the ACL.&quot;);
        }
<span class="fc" id="L142">    }</span>

    /**
     * Verifies that DirectContainer properties are valid, throwing exceptions if the triples
     * do not meet LDP requirements or a server managed property is specified as a membership relation.
     * If no membershipResource or membership relation are specified, defaults will be populated.
     * @param fedoraId id of the resource described
     * @param interactionModel interaction model of the resource
     * @param model model to check
     */
    protected void ensureValidDirectContainer(final FedoraId fedoraId, final String interactionModel,
            final Model model) {
<span class="fc" id="L154">        final boolean isIndirect = RdfLexicon.INDIRECT_CONTAINER.getURI().equals(interactionModel);</span>
<span class="fc bfc" id="L155" title="All 4 branches covered.">        if (!(RdfLexicon.DIRECT_CONTAINER.getURI().equals(interactionModel)</span>
                || isIndirect)) {
<span class="fc" id="L157">            return;</span>
        }
<span class="fc" id="L159">        final var dcResc = model.getResource(fedoraId.getFullId());</span>
<span class="fc" id="L160">        final AtomicBoolean hasMembershipResc = new AtomicBoolean(false);</span>
<span class="fc" id="L161">        final AtomicBoolean hasRelation = new AtomicBoolean(false);</span>
<span class="fc" id="L162">        final AtomicInteger insertedContentRelationCount = new AtomicInteger(0);</span>

<span class="fc" id="L164">        dcResc.listProperties().forEachRemaining(stmt -&gt; {</span>
<span class="fc" id="L165">            final var predicate = stmt.getPredicate();</span>

<span class="fc bfc" id="L167" title="All 2 branches covered.">            if (MEMBERSHIP_RESOURCE.equals(predicate)) {</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">                if (hasMembershipResc.get()) {</span>
<span class="fc" id="L169">                    throw new MalformedRdfException(&quot;Direct and Indirect containers must specify&quot;</span>
                            + &quot; exactly one ldp:membershipResource property, multiple are present&quot;);
                }

<span class="fc bfc" id="L173" title="All 2 branches covered.">                if (stmt.getObject().isURIResource()) {</span>
<span class="fc" id="L174">                    hasMembershipResc.set(true);</span>
                } else {
<span class="fc" id="L176">                    throw new MalformedRdfException(&quot;Direct and Indirect containers must specify&quot;</span>
                            + &quot; a ldp:membershipResource property with a resource as the object&quot;);
                }
<span class="fc bfc" id="L179" title="All 4 branches covered.">            } else if (HAS_MEMBER_RELATION.equals(predicate) || IS_MEMBER_OF_RELATION.equals(predicate)) {</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">                if (hasRelation.get()) {</span>
<span class="fc" id="L181">                    throw new MalformedRdfException(&quot;Direct and Indirect containers must specify exactly one&quot;</span>
                            + &quot; ldp:hasMemberRelation or ldp:isMemberOfRelation property, but multiple were present&quot;);
                }

<span class="fc" id="L185">                final RDFNode obj = stmt.getObject();</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">                if (obj.isURIResource()) {</span>
<span class="fc" id="L187">                    final String uri = obj.asResource().getURI();</span>

                    // Throw exception if object is a server-managed property
<span class="fc bfc" id="L190" title="All 2 branches covered.">                    if (isManagedPredicate.test(createProperty(uri))) {</span>
<span class="fc" id="L191">                        throw new ServerManagedPropertyException(String.format(</span>
                                &quot;%s cannot take a server managed property as an object: property value = %s.&quot;,
<span class="fc" id="L193">                                predicate.getLocalName(), uri));</span>
                    }
<span class="fc" id="L195">                    hasRelation.set(true);</span>
<span class="fc" id="L196">                } else {</span>
<span class="fc" id="L197">                    throw new MalformedRdfException(&quot;Direct and Indirect containers must specify either&quot;</span>
                            + &quot; ldp:hasMemberRelation or ldp:isMemberOfRelation properties,&quot;
                            + &quot; with a predicate as the object&quot;);
                }
<span class="pc bpc" id="L201" title="1 of 4 branches missed.">            } else if (isIndirect &amp;&amp; INSERTED_CONTENT_RELATION.equals(predicate)) {</span>
<span class="fc" id="L202">                insertedContentRelationCount.incrementAndGet();</span>
<span class="fc" id="L203">                final RDFNode obj = stmt.getObject();</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">                if (obj.isURIResource()) {</span>
<span class="fc" id="L205">                    final String uri = obj.asResource().getURI();</span>
                    // Throw exception if object is a server-managed property
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">                    if (isManagedPredicate.test(createProperty(uri))) {</span>
<span class="nc" id="L208">                        throw new ServerManagedPropertyException(String.format(</span>
                                &quot;%s cannot take a server managed property as an object: property value = %s.&quot;,
<span class="nc" id="L210">                                predicate.getLocalName(), uri));</span>
                    }
<span class="fc" id="L212">                } else {</span>
<span class="nc" id="L213">                    throw new MalformedRdfException(&quot;Indirect containers must specify an&quot;</span>
                            + &quot; ldp:insertedContentRelation property with a URI property as the object&quot;);
                }
            }
<span class="fc" id="L217">        });</span>

<span class="fc bfc" id="L219" title="All 2 branches covered.">        if (isIndirect) {</span>
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">            if (insertedContentRelationCount.get() &gt; 1) {</span>
<span class="nc" id="L221">                throw new MalformedRdfException(&quot;Indirect containers must contain exactly one triple&quot;</span>
                        + &quot; with the predicate ldp:insertedContentRelation and a property as the object.&quot;);
<span class="fc bfc" id="L223" title="All 2 branches covered.">            } else if (insertedContentRelationCount.get() == 0) {</span>
<span class="fc" id="L224">                dcResc.addProperty(INSERTED_CONTENT_RELATION, RdfLexicon.MEMBER_SUBJECT);</span>
            }
        }
<span class="fc bfc" id="L227" title="All 2 branches covered.">        if (!hasMembershipResc.get()) {</span>
<span class="fc" id="L228">            dcResc.addProperty(MEMBERSHIP_RESOURCE, dcResc);</span>
        }
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (!hasRelation.get()) {</span>
<span class="fc" id="L231">            dcResc.addProperty(HAS_MEMBER_RELATION, RdfLexicon.LDP_MEMBER);</span>
        }
<span class="fc" id="L233">    }</span>

    /**
     * This method does two things:
     * - Throws an exception if an authorization has both accessTo and accessToClass
     * - Adds a default accessTo target if an authorization has neither accessTo nor accessToClass
     *
     * @param inputModel to be checked and updated
     */
    protected void ensureValidACLAuthorization(final Model inputModel) {

        // TODO -- check ACL first

<span class="fc" id="L246">        final Set&lt;Node&gt; uniqueAuthSubjects = new HashSet&lt;&gt;();</span>
<span class="fc" id="L247">        inputModel.listStatements().forEachRemaining((final Statement s) -&gt; {</span>
<span class="fc" id="L248">            log.debug(&quot;statement: s={}, p={}, o={}&quot;, s.getSubject(), s.getPredicate(), s.getObject());</span>
<span class="fc" id="L249">            final Node subject = s.getSubject().asNode();</span>
            // If subject is Authorization Hash Resource, add it to the map with its accessTo/accessToClass status.
<span class="fc bfc" id="L251" title="All 2 branches covered.">            if (subject.toString().contains(&quot;/&quot; + FCR_ACL + &quot;#&quot;)) {</span>
<span class="fc" id="L252">                uniqueAuthSubjects.add(subject);</span>
            }
<span class="fc" id="L254">        });</span>
<span class="fc" id="L255">        final Graph graph = inputModel.getGraph();</span>
<span class="fc" id="L256">        uniqueAuthSubjects.forEach((final Node subject) -&gt; {</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">            if (graph.contains(subject, WEBAC_ACCESS_TO_URI, Node.ANY) &amp;&amp;</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">                    graph.contains(subject, WEBAC_ACCESS_TO_CLASS_URI, Node.ANY)) {</span>
<span class="fc" id="L259">                throw new ACLAuthorizationConstraintViolationException(</span>
<span class="fc" id="L260">                        String.format(</span>
                                &quot;Using both accessTo and accessToClass within &quot; +
                                        &quot;a single Authorization is not allowed: %s.&quot;,
<span class="fc" id="L263">                                subject.toString().substring(subject.toString().lastIndexOf(&quot;#&quot;))));</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">            } else if (!(graph.contains(subject, WEBAC_ACCESS_TO_URI, Node.ANY) ||</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">                    graph.contains(subject, WEBAC_ACCESS_TO_CLASS_URI, Node.ANY))) {</span>
<span class="fc" id="L266">                inputModel.add(createDefaultAccessToStatement(subject.toString()));</span>
            }
<span class="fc" id="L268">        });</span>
<span class="fc" id="L269">    }</span>

    protected void recordEvent(final String transactionId, final FedoraId fedoraId, final ResourceOperation operation) {
<span class="fc" id="L272">        this.eventAccumulator.recordEventForOperation(transactionId, fedoraId, operation);</span>
<span class="fc" id="L273">    }</span>

    /**
     * Wrapper to call the referenceService updateReference method
     * @param transactionId the transaction ID.
     * @param resourceId the resource's ID.
     * @param model the model of the request body.
     */
    protected void updateReferences(final String transactionId, final FedoraId resourceId, final String user,
                                    final Model model) {
<span class="fc" id="L283">        referenceService.updateReferences(transactionId, resourceId, user,</span>
<span class="fc" id="L284">                fromModel(model.getResource(resourceId.getFullId()).asNode(), model));</span>
<span class="fc" id="L285">    }</span>

    protected void lockArchivalGroupResource(final Transaction tx,
                                             final PersistentStorageSession pSession,
                                             final FedoraId fedoraId) {
<span class="fc" id="L290">        final var headers = pSession.getHeaders(fedoraId, null);</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        if (headers.getArchivalGroupId() != null) {</span>
<span class="fc" id="L292">            tx.lockResource(headers.getArchivalGroupId());</span>
        }
<span class="fc" id="L294">    }</span>

    protected void lockArchivalGroupResourceFromParent(final Transaction tx,
                                                       final PersistentStorageSession pSession,
                                                       final FedoraId parentId) {
<span class="pc bpc" id="L299" title="1 of 4 branches missed.">        if (parentId != null &amp;&amp; !parentId.isRepositoryRoot()) {</span>
<span class="fc" id="L300">            final var parentHeaders = pSession.getHeaders(parentId, null);</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">            if (parentHeaders.isArchivalGroup()) {</span>
<span class="fc" id="L302">                tx.lockResource(parentId);</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">            } else if (parentHeaders.getArchivalGroupId() != null) {</span>
<span class="fc" id="L304">                tx.lockResource(parentHeaders.getArchivalGroupId());</span>
            }
        }
<span class="fc" id="L307">    }</span>

    /**
     * Returns a Statement with the resource containing the acl to be the accessTo target for the given auth subject.
     *
     * @param authSubject - acl authorization subject uri string
     * @return acl statement
     */
    private Statement createDefaultAccessToStatement(final String authSubject) {
<span class="fc" id="L316">        final String currentResourcePath = authSubject.substring(0, authSubject.indexOf(&quot;/&quot; + FCR_ACL));</span>
<span class="fc" id="L317">        return createStatement(</span>
<span class="fc" id="L318">                createResource(authSubject),</span>
                WEBAC_ACCESS_TO_PROPERTY,
<span class="fc" id="L320">                createResource(currentResourcePath));</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>