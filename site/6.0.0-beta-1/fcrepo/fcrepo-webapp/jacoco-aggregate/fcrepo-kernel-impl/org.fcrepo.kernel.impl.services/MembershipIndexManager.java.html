<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>MembershipIndexManager.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Fedora Repository Deployable Web Application</a> &gt; <a href="../index.html" class="el_bundle">fcrepo-kernel-impl</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.kernel.impl.services</a> &gt; <span class="el_source">MembershipIndexManager.java</span></div><h1>MembershipIndexManager.java</h1><pre class="source lang-java linenums">/*
 * Licensed to DuraSpace under one or more contributor license agreements.
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * DuraSpace licenses this file to you under the Apache License,
 * Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.fcrepo.kernel.impl.services;

import static org.slf4j.LoggerFactory.getLogger;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Queue;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.function.Consumer;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import javax.annotation.PostConstruct;
import javax.inject.Inject;
import javax.sql.DataSource;
import javax.transaction.Transactional;

import org.fcrepo.common.db.DbPlatform;
import org.fcrepo.kernel.api.identifiers.FedoraId;

import org.apache.jena.graph.Node;
import org.apache.jena.graph.NodeFactory;
import org.apache.jena.graph.Triple;
import org.slf4j.Logger;
import org.springframework.jdbc.core.RowCallbackHandler;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Component;

/**
 * Manager for the membership index
 *
 * @author bbpennel
 */
@Component
<span class="fc" id="L60">public class MembershipIndexManager {</span>
<span class="fc" id="L61">    private static final Logger log = getLogger(MembershipIndexManager.class);</span>

<span class="fc" id="L63">    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);</span>
<span class="fc" id="L64">    private static final Timestamp NO_START_TIMESTAMP = Timestamp.from(Instant.parse(&quot;1000-01-01T00:00:00.000Z&quot;));</span>

    private static final String ADD_OPERATION = &quot;add&quot;;
    private static final String DELETE_OPERATION = &quot;delete&quot;;
    private static final String FORCE_FLAG = &quot;force&quot;;

    private static final String TX_ID_PARAM = &quot;txId&quot;;
    private static final String SUBJECT_ID_PARAM = &quot;subjectId&quot;;
    private static final String NO_END_TIME_PARAM = &quot;noEndTime&quot;;
    private static final String ADD_OP_PARAM = &quot;addOp&quot;;
    private static final String DELETE_OP_PARAM = &quot;deleteOp&quot;;
    private static final String MEMENTO_TIME_PARAM = &quot;mementoTime&quot;;
    private static final String PROPERTY_PARAM = &quot;property&quot;;
    private static final String TARGET_ID_PARAM = &quot;targetId&quot;;
    private static final String SOURCE_ID_PARAM = &quot;sourceId&quot;;
    private static final String PROXY_ID_PARAM = &quot;proxyId&quot;;
    private static final String START_TIME_PARAM = &quot;startTime&quot;;
    private static final String END_TIME_PARAM = &quot;endTime&quot;;
    private static final String LAST_UPDATED_PARAM = &quot;lastUpdated&quot;;
    private static final String OPERATION_PARAM = &quot;operation&quot;;
    private static final String FORCE_PARAM = &quot;forceFlag&quot;;
    private static final String LIMIT_PARAM = &quot;limit&quot;;
    private static final String OFFSET_PARAM = &quot;offSet&quot;;

    private static final String SELECT_ALL_MEMBERSHIP = &quot;SELECT * FROM membership&quot;;

    private static final String SELECT_ALL_OPERATIONS = &quot;SELECT * FROM membership_tx_operations&quot;;

    private static final String SELECT_MEMBERSHIP_IN_TX =
            &quot;SELECT property, object_id&quot; +
            &quot; FROM membership m&quot; +
            &quot; WHERE subject_id = :subjectId&quot; +
                &quot; AND end_time = :noEndTime&quot; +
                &quot; AND NOT EXISTS (&quot; +
                    &quot; SELECT 1&quot; +
                    &quot; FROM membership_tx_operations mto&quot; +
                    &quot; WHERE mto.subject_id = :subjectId&quot; +
                        &quot; AND mto.source_id = m.source_id&quot; +
                        &quot; AND mto.object_id = m.object_id&quot; +
                        &quot; AND mto.tx_id = :txId&quot; +
                        &quot; AND mto.operation = :deleteOp)&quot; +
            &quot; UNION&quot; +
            &quot; SELECT property, object_id&quot; +
            &quot; FROM membership_tx_operations&quot; +
            &quot; WHERE subject_id = :subjectId&quot; +
                &quot; AND tx_id = :txId&quot; +
                &quot; AND end_time = :noEndTime&quot; +
                &quot; AND operation = :addOp&quot; +
            &quot; ORDER BY property, object_id&quot; +
            &quot; LIMIT :limit OFFSET :offSet&quot;;

    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =
            &quot;SELECT property, object_id&quot; +
            &quot; FROM membership m&quot; +
            &quot; WHERE m.subject_id = :subjectId&quot; +
                &quot; AND m.start_time &lt;= :mementoTime&quot; +
                &quot; AND m.end_time &gt; :mementoTime&quot; +
                &quot; AND NOT EXISTS (&quot; +
                    &quot; SELECT 1&quot; +
                    &quot; FROM membership_tx_operations mto&quot; +
                    &quot; WHERE mto.subject_id = :subjectId&quot; +
                        &quot; AND mto.source_id = m.source_id&quot; +
                        &quot; AND mto.property = m.property&quot; +
                        &quot; AND mto.object_id = m.object_id&quot; +
                        &quot; AND mto.end_time &lt;= :mementoTime&quot; +
                        &quot; AND mto.tx_id = :txId&quot; +
                        &quot; AND mto.operation = :deleteOp)&quot; +
            &quot; UNION&quot; +
            &quot; SELECT property, object_id&quot; +
            &quot; FROM membership_tx_operations&quot; +
            &quot; WHERE subject_id = :subjectId&quot; +
                &quot; AND tx_id = :txId&quot; +
                &quot; AND start_time &lt;= :mementoTime&quot; +
                &quot; AND end_time &gt; :mementoTime&quot; +
                &quot; AND operation = :addOp&quot; +
            &quot; ORDER BY property, object_id&quot; +
            &quot; LIMIT :limit OFFSET :offSet&quot;;

    private static final String SELECT_LAST_UPDATED =
            &quot;SELECT max(last_updated) as last_updated&quot; +
            &quot; FROM membership&quot; +
            &quot; WHERE subject_id = :subjectId&quot;;

    // For mementos, use the start_time instead of last_updated as the
    // end_time reflects when the next version starts
    private static final String SELECT_LAST_UPDATED_MEMENTO =
            &quot;SELECT max(start_time)&quot; +
            &quot; FROM membership&quot; +
            &quot; WHERE subject_id = :subjectId&quot; +
                &quot; AND start_time &lt;= :mementoTime&quot; +
                &quot; AND end_time &gt; :mementoTime&quot;;

    private static final String SELECT_LAST_UPDATED_IN_TX =
            &quot;SELECT max(combined.updated) as last_updated&quot; +
            &quot; FROM (&quot; +
                &quot; SELECT max(last_updated) as updated&quot; +
                &quot; FROM membership m&quot; +
                &quot; WHERE subject_id = :subjectId&quot; +
                    &quot; AND NOT EXISTS (&quot; +
                        &quot; SELECT 1&quot; +
                        &quot; FROM membership_tx_operations mto&quot; +
                        &quot; WHERE mto.subject_id = :subjectId&quot; +
                            &quot; AND mto.source_id = m.source_id&quot; +
                            &quot; AND mto.object_id = m.object_id&quot; +
                            &quot; AND mto.tx_id = :txId&quot; +
                            &quot; AND mto.operation = :deleteOp)&quot; +
                &quot; UNION&quot; +
                &quot; SELECT max(last_updated) as updated&quot; +
                &quot; FROM membership_tx_operations&quot; +
                &quot; WHERE subject_id = :subjectId&quot; +
                    &quot; AND tx_id = :txId&quot; +
            &quot;) combined&quot;;

    private static final String INSERT_MEMBERSHIP_IN_TX =
            &quot;INSERT INTO membership_tx_operations (subject_id, property, object_id, source_id,&quot; +
                    &quot; proxy_id, start_time, end_time, last_updated, tx_id, operation)&quot; +
            &quot; VALUES (:subjectId, :property, :targetId, :sourceId,&quot; +
                    &quot; :proxyId, :startTime, :endTime, :lastUpdated, :txId, :operation)&quot;;

    private static final String END_EXISTING_MEMBERSHIP =
            &quot;INSERT INTO membership_tx_operations (subject_id, property, object_id, source_id,&quot; +
                    &quot; proxy_id, start_time, end_time, last_updated, tx_id, operation)&quot; +
            &quot; SELECT m.subject_id, m.property, m.object_id, m.source_id, m.proxy_id, m.start_time,&quot; +
                    &quot; :endTime, :endTime, :txId, :deleteOp&quot; +
            &quot; FROM membership m&quot; +
            &quot; WHERE m.source_id = :sourceId&quot; +
                &quot; AND m.proxy_id = :proxyId&quot; +
                &quot; AND m.end_time = :noEndTime&quot;;

    private static final String CLEAR_FOR_PROXY_IN_TX =
            &quot;DELETE FROM membership_tx_operations&quot; +
            &quot; WHERE source_id = :sourceId&quot; +
                &quot; AND tx_id = :txId&quot; +
                &quot; AND proxy_id = :proxyId&quot; +
                &quot; AND force_flag IS NULL&quot;;

    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =
            &quot;DELETE FROM membership_tx_operations&quot; +
            &quot; WHERE source_id = :sourceId&quot; +
                &quot; AND tx_id = :txId&quot; +
                &quot; AND operation = :addOp&quot;;

    // Add &quot;delete&quot; entries for all existing membership from the given source, if not already deleted
    private static final String END_EXISTING_FOR_SOURCE =
            &quot;INSERT INTO membership_tx_operations (subject_id, property, object_id, source_id,&quot; +
                    &quot; proxy_id, start_time, end_time, last_updated, tx_id, operation)&quot; +
            &quot; SELECT subject_id, property, object_id, source_id,&quot; +
                    &quot; proxy_id, start_time, :endTime, :endTime, :txId, :deleteOp&quot; +
            &quot; FROM membership m&quot; +
            &quot; WHERE source_id = :sourceId&quot; +
                &quot; AND end_time = :noEndTime&quot; +
                &quot; AND NOT EXISTS (&quot; +
                    &quot; SELECT TRUE&quot; +
                    &quot; FROM membership_tx_operations mtx&quot; +
                    &quot; WHERE mtx.subject_id = m.subject_id&quot; +
                        &quot; AND mtx.property = m.property&quot; +
                        &quot; AND mtx.object_id = m.object_id&quot; +
                        &quot; AND mtx.source_id = m.source_id&quot; +
                        &quot; AND mtx.proxy_id = m.proxy_id&quot; +
                        &quot; AND mtx.operation = :deleteOp&quot; +
                    &quot;)&quot;;

    private static final String DELETE_EXISTING_FOR_SOURCE_AFTER =
            &quot;INSERT INTO membership_tx_operations(subject_id, property, object_id, source_id,&quot; +
                    &quot; proxy_id, start_time, end_time, last_updated, tx_id, operation, force_flag)&quot; +
            &quot; SELECT subject_id, property, object_id, source_id, proxy_id, start_time, end_time,&quot; +
                    &quot; last_updated, :txId, :deleteOp, :forceFlag&quot; +
            &quot; FROM membership m&quot; +
            &quot; WHERE m.source_id = :sourceId&quot; +
                &quot; AND (m.start_time &gt;= :startTime&quot; +
                &quot; OR m.end_time &gt;= :startTime)&quot;;

    private static final String DELETE_EXISTING_FOR_PROXY_AFTER =
            &quot;INSERT INTO membership_tx_operations(subject_id, property, object_id, source_id,&quot; +
                    &quot; proxy_id, start_time, end_time, last_updated, tx_id, operation, force_flag)&quot; +
            &quot; SELECT subject_id, property, object_id, source_id, proxy_id, start_time, end_time,&quot; +
                    &quot; last_updated, :txId, :deleteOp, :forceFlag&quot; +
            &quot; FROM membership m&quot; +
            &quot; WHERE m.proxy_id = :proxyId&quot; +
                &quot; AND (m.start_time &gt;= :startTime&quot; +
                &quot; OR m.end_time &gt;= :startTime)&quot;;

    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =
            &quot;DELETE from membership&quot; +
            &quot; where source_id = :targetId&quot; +
                &quot; OR subject_id = :targetId&quot; +
                &quot; OR object_id = :targetId&quot;;

    private static final String PURGE_ALL_REFERENCES_TRANSACTION =
            &quot;DELETE from membership_tx_operations&quot; +
            &quot; WHERE tx_id = :txId&quot; +
                &quot; AND (source_id = :targetId&quot; +
                &quot; OR subject_id = :targetId&quot; +
                &quot; OR object_id = :targetId)&quot;;

    private static final String COMMIT_DELETES =
            &quot;DELETE from membership&quot; +
            &quot; WHERE EXISTS (&quot; +
                &quot; SELECT TRUE&quot; +
                &quot; FROM membership_tx_operations mto&quot; +
                &quot; WHERE mto.tx_id = :txId&quot; +
                    &quot; AND mto.operation = :deleteOp&quot; +
                    &quot; AND mto.force_flag = :forceFlag&quot; +
                    &quot; AND membership.source_id = mto.source_id&quot; +
                    &quot; AND membership.proxy_id = mto.proxy_id&quot; +
                    &quot; AND membership.subject_id = mto.subject_id&quot; +
                    &quot; AND membership.property = mto.property&quot; +
                    &quot; AND membership.object_id = mto.object_id&quot; +
                &quot; )&quot;;

    private static final String COMMIT_ENDS_H2 =
            &quot;UPDATE membership m&quot; +
            &quot; SET end_time = (&quot; +
                &quot; SELECT mto.end_time&quot; +
                &quot; FROM membership_tx_operations mto&quot; +
                &quot; WHERE mto.tx_id = :txId&quot; +
                    &quot; AND m.source_id = mto.source_id&quot; +
                    &quot; AND m.proxy_id = mto.proxy_id&quot; +
                    &quot; AND m.subject_id = mto.subject_id&quot; +
                    &quot; AND m.property = mto.property&quot; +
                    &quot; AND m.object_id = mto.object_id&quot; +
                    &quot; AND mto.operation = :deleteOp&quot; +
                &quot; ),&quot; +
                &quot; last_updated = (&quot; +
                    &quot; SELECT mto.end_time&quot; +
                    &quot; FROM membership_tx_operations mto&quot; +
                    &quot; WHERE mto.tx_id = :txId&quot; +
                        &quot; AND m.source_id = mto.source_id&quot; +
                        &quot; AND m.proxy_id = mto.proxy_id&quot; +
                        &quot; AND m.subject_id = mto.subject_id&quot; +
                        &quot; AND m.property = mto.property&quot; +
                        &quot; AND m.object_id = mto.object_id&quot; +
                        &quot; AND mto.operation = :deleteOp&quot; +
                    &quot; )&quot; +
            &quot; WHERE EXISTS (&quot; +
                &quot;SELECT TRUE&quot; +
                &quot; FROM membership_tx_operations mto&quot; +
                &quot; WHERE mto.tx_id = :txId&quot; +
                    &quot; AND mto.operation = :deleteOp&quot; +
                    &quot; AND m.source_id = mto.source_id&quot; +
                    &quot; AND m.proxy_id = mto.proxy_id&quot; +
                    &quot; AND m.subject_id = mto.subject_id&quot; +
                    &quot; AND m.property = mto.property&quot; +
                    &quot; AND m.object_id = mto.object_id&quot; +
                &quot; )&quot;;

    private static final String COMMIT_ENDS_POSTGRES =
            &quot;UPDATE membership&quot; +
            &quot; SET end_time = mto.end_time, last_updated = mto.end_time&quot; +
            &quot; FROM membership_tx_operations mto&quot; +
            &quot; WHERE mto.tx_id = :txId&quot; +
                &quot; AND mto.operation = :deleteOp&quot; +
                &quot; AND membership.source_id = mto.source_id&quot; +
                &quot; AND membership.proxy_id = mto.proxy_id&quot; +
                &quot; AND membership.subject_id = mto.subject_id&quot; +
                &quot; AND membership.property = mto.property&quot; +
                &quot; AND membership.object_id = mto.object_id&quot;;

    private static final String COMMIT_ENDS_MYSQL =
            &quot;UPDATE membership m&quot; +
            &quot; INNER JOIN membership_tx_operations mto ON&quot; +
                &quot; m.source_id = mto.source_id&quot; +
                &quot; AND m.proxy_id = mto.proxy_id&quot; +
                &quot; AND m.subject_id = mto.subject_id&quot; +
                &quot; AND m.property = mto.property&quot; +
                &quot; AND m.object_id = mto.object_id&quot; +
            &quot; SET m.end_time = mto.end_time, m.last_updated = mto.end_time&quot; +
            &quot; WHERE mto.tx_id = :txId&quot; +
                &quot; AND mto.operation = :deleteOp&quot;;

<span class="fc" id="L334">    private static final Map&lt;DbPlatform, String&gt; COMMIT_ENDS_MAP = Map.of(</span>
            DbPlatform.MYSQL, COMMIT_ENDS_MYSQL,
            DbPlatform.MARIADB, COMMIT_ENDS_MYSQL,
            DbPlatform.POSTGRESQL, COMMIT_ENDS_POSTGRES,
            DbPlatform.H2, COMMIT_ENDS_H2
    );

    // Transfer all &quot;add&quot; operations from tx to committed membership, unless the entry already exists
    private static final String COMMIT_ADDS =
            &quot;INSERT INTO membership&quot; +
            &quot; (subject_id, property, object_id, source_id, proxy_id, start_time, end_time, last_updated)&quot; +
            &quot; SELECT subject_id, property, object_id, source_id, proxy_id, start_time, end_time, last_updated&quot; +
            &quot; FROM membership_tx_operations mto&quot; +
            &quot; WHERE mto.tx_id = :txId&quot; +
                &quot; AND mto.operation = :addOp&quot; +
                &quot; AND NOT EXISTS (&quot; +
                    &quot; SELECT TRUE&quot; +
                    &quot; FROM membership m&quot; +
                    &quot; WHERE m.source_id = mto.source_id&quot; +
                        &quot; AND m.proxy_id = mto.proxy_id&quot; +
                        &quot; AND m.subject_id = mto.subject_id&quot; +
                        &quot; AND m.property = mto.property&quot; +
                        &quot; AND m.object_id = mto.object_id&quot; +
                        &quot; AND m.start_time = mto.start_time&quot; +
                        &quot; AND m.end_time = mto.end_time&quot; +
                &quot; )&quot;;

    private static final String DELETE_TRANSACTION =
            &quot;DELETE FROM membership_tx_operations&quot; +
            &quot; WHERE tx_id = :txId&quot;;

    private static final String TRUNCATE_MEMBERSHIP = &quot;TRUNCATE TABLE membership&quot;;

    private static final String TRUNCATE_MEMBERSHIP_TX = &quot;TRUNCATE TABLE membership_tx_operations&quot;;

    @Inject
    private DataSource dataSource;

    private NamedParameterJdbcTemplate jdbcTemplate;

    private DbPlatform dbPlatform;

    private static final int MEMBERSHIP_LIMIT = 50000;

    @PostConstruct
    public void setUp() {
<span class="fc" id="L380">        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());</span>
<span class="fc" id="L381">        dbPlatform = DbPlatform.fromDataSource(dataSource);</span>
<span class="fc" id="L382">    }</span>

    /**
     * End a membership from the child of a Direct/IndirectContainer, setting an end time if committed,
     * or clearing from the current tx if it was newly added.
     *
     * @param txId transaction id
     * @param sourceId ID of the direct/indirect container whose membership should be ended
     * @param proxyId ID of the proxy producing this membership, when applicable
     * @param endTime the time the resource was deleted, generally its last modified
     */
    @Transactional
    public void endMembershipFromChild(final String txId, final FedoraId sourceId, final FedoraId proxyId,
            final Instant endTime) {
<span class="fc" id="L396">        final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="fc" id="L397">        parameterSource.addValue(TX_ID_PARAM, txId);</span>
<span class="fc" id="L398">        parameterSource.addValue(SOURCE_ID_PARAM, sourceId.getFullId());</span>
<span class="fc" id="L399">        parameterSource.addValue(PROXY_ID_PARAM, proxyId.getFullId());</span>

<span class="fc" id="L401">        final int affected = jdbcTemplate.update(CLEAR_FOR_PROXY_IN_TX, parameterSource);</span>

        // If no rows were deleted, then assume we need to delete permanent entry
<span class="fc bfc" id="L404" title="All 2 branches covered.">        if (affected == 0) {</span>
<span class="fc" id="L405">            final MapSqlParameterSource parameterSource2 = new MapSqlParameterSource();</span>
<span class="fc" id="L406">            parameterSource2.addValue(TX_ID_PARAM, txId);</span>
<span class="fc" id="L407">            parameterSource2.addValue(SOURCE_ID_PARAM, sourceId.getFullId());</span>
<span class="fc" id="L408">            parameterSource2.addValue(PROXY_ID_PARAM, proxyId.getFullId());</span>
<span class="fc" id="L409">            parameterSource2.addValue(END_TIME_PARAM, formatInstant(endTime));</span>
<span class="fc" id="L410">            parameterSource2.addValue(NO_END_TIME_PARAM, NO_END_TIMESTAMP);</span>
<span class="fc" id="L411">            parameterSource2.addValue(DELETE_OP_PARAM, DELETE_OPERATION);</span>
<span class="fc" id="L412">            jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);</span>
        }
<span class="fc" id="L414">    }</span>

    @Transactional
    public void deleteMembershipForProxyAfter(final String txId, final FedoraId sourceId, final FedoraId proxyId,
            final Instant afterTime) {
        // Clear all membership added in this transaction
<span class="nc" id="L420">        final var parameterSource =  Map.of(</span>
                TX_ID_PARAM, txId,
<span class="nc" id="L422">                SOURCE_ID_PARAM, sourceId.getFullId(),</span>
<span class="nc" id="L423">                PROXY_ID_PARAM, proxyId.getFullId(),</span>
                OPERATION_PARAM, ADD_OPERATION);

<span class="nc" id="L426">        jdbcTemplate.update(CLEAR_FOR_PROXY_IN_TX, parameterSource);</span>

<span class="nc bnc" id="L428" title="All 2 branches missed.">        final var afterTimestamp = afterTime == null ? NO_START_TIMESTAMP : formatInstant(afterTime);</span>

        // Delete all existing membership entries that start after or end after the given timestamp
<span class="nc" id="L431">        final Map&lt;String, Object&gt; parameterSource2 = Map.of(</span>
                TX_ID_PARAM, txId,
<span class="nc" id="L433">                PROXY_ID_PARAM, proxyId.getFullId(),</span>
                START_TIME_PARAM, afterTimestamp,
                FORCE_PARAM, FORCE_FLAG,
                DELETE_OP_PARAM, DELETE_OPERATION);
<span class="nc" id="L437">        jdbcTemplate.update(DELETE_EXISTING_FOR_PROXY_AFTER, parameterSource2);</span>
<span class="nc" id="L438">    }</span>

    /**
     * End all membership properties resulting from the specified source container
     * @param txId transaction id
     * @param sourceId ID of the direct/indirect container whose membership should be ended
     * @param endTime the time the resource was deleted, generally its last modified
     */
    @Transactional
    public void endMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime) {
<span class="fc" id="L448">        final Map&lt;String, Object&gt; parameterSource = Map.of(</span>
                TX_ID_PARAM, txId,
<span class="fc" id="L450">                SOURCE_ID_PARAM, sourceId.getFullId(),</span>
                ADD_OP_PARAM, ADD_OPERATION);

<span class="fc" id="L453">        jdbcTemplate.update(CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX, parameterSource);</span>

<span class="fc" id="L455">        final Map&lt;String, Object&gt; parameterSource2 = Map.of(</span>
                TX_ID_PARAM, txId,
<span class="fc" id="L457">                SOURCE_ID_PARAM, sourceId.getFullId(),</span>
<span class="fc" id="L458">                END_TIME_PARAM, formatInstant(endTime),</span>
                NO_END_TIME_PARAM, NO_END_TIMESTAMP,
                DELETE_OP_PARAM, DELETE_OPERATION);
<span class="fc" id="L461">        jdbcTemplate.update(END_EXISTING_FOR_SOURCE, parameterSource2);</span>
<span class="fc" id="L462">    }</span>

    /**
     * Delete membership entries that are active at or after the given timestamp for the specified source
     * @param txId transaction id
     * @param sourceId ID of the direct/indirect container
     * @param afterTime time at or after which membership should be removed
     */
    @Transactional
    public void deleteMembershipForSourceAfter(final String txId, final FedoraId sourceId, final Instant afterTime) {
        // Clear all membership added in this transaction
<span class="fc" id="L473">        final Map&lt;String, Object&gt; parameterSource = Map.of(</span>
                TX_ID_PARAM, txId,
<span class="fc" id="L475">                SOURCE_ID_PARAM, sourceId.getFullId(),</span>
                ADD_OP_PARAM, ADD_OPERATION);

<span class="fc" id="L478">        jdbcTemplate.update(CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX, parameterSource);</span>

<span class="fc bfc" id="L480" title="All 2 branches covered.">        final var afterTimestamp = afterTime == null ? NO_START_TIMESTAMP : formatInstant(afterTime);</span>

        // Delete all existing membership entries that start after or end after the given timestamp
<span class="fc" id="L483">        final Map&lt;String, Object&gt; parameterSource2 = Map.of(</span>
                TX_ID_PARAM, txId,
<span class="fc" id="L485">                SOURCE_ID_PARAM, sourceId.getFullId(),</span>
                START_TIME_PARAM, afterTimestamp,
                FORCE_PARAM, FORCE_FLAG,
                DELETE_OP_PARAM, DELETE_OPERATION);
<span class="fc" id="L489">        jdbcTemplate.update(DELETE_EXISTING_FOR_SOURCE_AFTER, parameterSource2);</span>
<span class="fc" id="L490">    }</span>

    /**
     * Clean up any references to the target id, in transactions and outside
     * @param txId transaction id
     * @param targetId identifier of the resource to cleanup membership references for
     */
    @Transactional
    public void deleteMembershipReferences(final String txId, final FedoraId targetId) {
<span class="fc" id="L499">        final Map&lt;String, Object&gt; parameterSource = Map.of(</span>
<span class="fc" id="L500">                TARGET_ID_PARAM, targetId.getFullId(),</span>
                TX_ID_PARAM, txId);

<span class="fc" id="L503">        jdbcTemplate.update(PURGE_ALL_REFERENCES_TRANSACTION, parameterSource);</span>
<span class="fc" id="L504">        jdbcTemplate.update(PURGE_ALL_REFERENCES_MEMBERSHIP, parameterSource);</span>
<span class="fc" id="L505">    }</span>

    /**
     * Add new membership property to the index, clearing any delete
     * operations for the property if necessary.
     * @param txId transaction id
     * @param sourceId ID of the direct/indirect container which produced the membership
     * @param proxyId ID of the proxy producing this membership, when applicable
     * @param membership membership triple
     * @param startTime time the membership triple was added
     */
    @Transactional
    public void addMembership(final String txId, final FedoraId sourceId, final FedoraId proxyId,
            final Triple membership, final Instant startTime) {
<span class="fc bfc" id="L519" title="All 2 branches covered.">        if (membership == null) {</span>
<span class="fc" id="L520">            return;</span>
        }
<span class="fc" id="L522">        addMembership(txId, sourceId, proxyId, membership, startTime, null);</span>
<span class="fc" id="L523">    }</span>

    /**
     * Add new membership property to the index
     * @param txId transaction id
     * @param sourceId ID of the direct/indirect container which produced the membership
     * @param proxyId ID of the proxy producing this membership, when applicable
     * @param membership membership triple
     * @param startTime time the membership triple was added
     * @param endTime time the membership triple ends, or never if not provided
     */
    @Transactional
    public void addMembership(final String txId, final FedoraId sourceId, final FedoraId proxyId,
            final Triple membership, final Instant startTime, final Instant endTime) {
        final Timestamp endTimestamp;
        final Timestamp lastUpdated;
<span class="fc" id="L539">        final Timestamp startTimestamp = formatInstant(startTime);</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">        if (endTime == null) {</span>
<span class="fc" id="L541">            endTimestamp = NO_END_TIMESTAMP;</span>
<span class="fc" id="L542">            lastUpdated = startTimestamp;</span>
        } else {
<span class="fc" id="L544">            endTimestamp = formatInstant(endTime);</span>
<span class="fc" id="L545">            lastUpdated = endTimestamp;</span>
        }
        // Add the new membership operation
<span class="fc" id="L548">        final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="fc" id="L549">        parameterSource.addValue(SUBJECT_ID_PARAM, membership.getSubject().getURI());</span>
<span class="fc" id="L550">        parameterSource.addValue(PROPERTY_PARAM, membership.getPredicate().getURI());</span>
<span class="fc" id="L551">        parameterSource.addValue(TARGET_ID_PARAM, membership.getObject().getURI());</span>
<span class="fc" id="L552">        parameterSource.addValue(SOURCE_ID_PARAM, sourceId.getFullId());</span>
<span class="fc" id="L553">        parameterSource.addValue(PROXY_ID_PARAM, proxyId.getFullId());</span>
<span class="fc" id="L554">        parameterSource.addValue(START_TIME_PARAM, startTimestamp);</span>
<span class="fc" id="L555">        parameterSource.addValue(END_TIME_PARAM, endTimestamp);</span>
<span class="fc" id="L556">        parameterSource.addValue(LAST_UPDATED_PARAM, lastUpdated);</span>
<span class="fc" id="L557">        parameterSource.addValue(TX_ID_PARAM, txId);</span>
<span class="fc" id="L558">        parameterSource.addValue(OPERATION_PARAM, ADD_OPERATION);</span>

<span class="fc" id="L560">        jdbcTemplate.update(INSERT_MEMBERSHIP_IN_TX, parameterSource);</span>
<span class="fc" id="L561">    }</span>

    /**
     * Get a stream of membership triples with
     * @param txId transaction from which membership will be retrieved, or null for no transaction
     * @param subjectId ID of the subject
     * @return Stream of membership triples
     */
    public Stream&lt;Triple&gt; getMembership(final String txId, final FedoraId subjectId) {
<span class="fc" id="L570">        final Node subjectNode = NodeFactory.createURI(subjectId.getBaseId());</span>

<span class="fc" id="L572">        final RowMapper&lt;Triple&gt; membershipMapper = (rs, rowNum) -&gt;</span>
<span class="fc" id="L573">                Triple.create(subjectNode,</span>
<span class="fc" id="L574">                        NodeFactory.createURI(rs.getString(&quot;property&quot;)),</span>
<span class="fc" id="L575">                        NodeFactory.createURI(rs.getString(&quot;object_id&quot;)));</span>

<span class="fc" id="L577">        final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="fc" id="L578">        parameterSource.addValue(TX_ID_PARAM, txId);</span>

        final String query;
<span class="fc bfc" id="L581" title="All 2 branches covered.">        if (subjectId.isMemento()) {</span>
<span class="fc" id="L582">            parameterSource.addValue(SUBJECT_ID_PARAM, subjectId.getBaseId());</span>
<span class="fc" id="L583">            parameterSource.addValue(MEMENTO_TIME_PARAM, formatInstant(subjectId.getMementoInstant()));</span>
<span class="fc" id="L584">            query = SELECT_MEMBERSHIP_MEMENTO_IN_TX;</span>
        } else {
<span class="fc" id="L586">            parameterSource.addValue(SUBJECT_ID_PARAM, subjectId.getFullId());</span>
<span class="fc" id="L587">            parameterSource.addValue(NO_END_TIME_PARAM, NO_END_TIMESTAMP);</span>
<span class="fc" id="L588">            query = SELECT_MEMBERSHIP_IN_TX;</span>
        }

<span class="fc" id="L591">        return StreamSupport.stream(new MembershipIterator(query, parameterSource, membershipMapper), false);</span>
    }

    public Instant getLastUpdated(final String txId, final FedoraId subjectId) {
<span class="fc" id="L595">        final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>

<span class="fc" id="L597">        parameterSource.addValue(NO_END_TIME_PARAM, NO_END_TIMESTAMP);</span>
        final String lastUpdatedQuery;
<span class="fc bfc" id="L599" title="All 2 branches covered.">        if (subjectId.isMemento()) {</span>
<span class="fc" id="L600">            lastUpdatedQuery = SELECT_LAST_UPDATED_MEMENTO;</span>
<span class="fc" id="L601">            parameterSource.addValue(SUBJECT_ID_PARAM, subjectId.getBaseId());</span>
<span class="fc" id="L602">            parameterSource.addValue(MEMENTO_TIME_PARAM, formatInstant(subjectId.getMementoInstant()));</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">        } else if (txId == null) {</span>
<span class="fc" id="L604">            lastUpdatedQuery = SELECT_LAST_UPDATED;</span>
<span class="fc" id="L605">            parameterSource.addValue(SUBJECT_ID_PARAM, subjectId.getFullId());</span>
        } else {
<span class="fc" id="L607">            lastUpdatedQuery = SELECT_LAST_UPDATED_IN_TX;</span>
<span class="fc" id="L608">            parameterSource.addValue(SUBJECT_ID_PARAM, subjectId.getFullId());</span>
<span class="fc" id="L609">            parameterSource.addValue(TX_ID_PARAM, txId);</span>
<span class="fc" id="L610">            parameterSource.addValue(DELETE_OP_PARAM, DELETE_OPERATION);</span>
        }

<span class="fc" id="L613">        return jdbcTemplate.queryForObject(lastUpdatedQuery, parameterSource, Instant.class);</span>
    }

    /**
     * Perform a commit of operations stored in the specified transaction
     * @param txId transaction id
     */
    @Transactional
    public void commitTransaction(final String txId) {
<span class="fc" id="L622">        final Map&lt;String, String&gt; parameterSource = Map.of(TX_ID_PARAM, txId,</span>
                ADD_OP_PARAM, ADD_OPERATION,
                DELETE_OP_PARAM, DELETE_OPERATION,
                FORCE_PARAM, FORCE_FLAG);

<span class="fc" id="L627">        jdbcTemplate.update(COMMIT_DELETES, parameterSource);</span>
<span class="fc" id="L628">        final int ends = jdbcTemplate.update(COMMIT_ENDS_MAP.get(this.dbPlatform), parameterSource);</span>
<span class="fc" id="L629">        final int adds = jdbcTemplate.update(COMMIT_ADDS, parameterSource);</span>
<span class="fc" id="L630">        final int cleaned = jdbcTemplate.update(DELETE_TRANSACTION, parameterSource);</span>

<span class="fc" id="L632">        log.debug(&quot;Completed commit, {} ended, {} adds, {} operations&quot;, ends, adds, cleaned);</span>
<span class="fc" id="L633">    }</span>

    /**
     * Delete all entries related to a transaction
     * @param txId transaction id
     */
    public void deleteTransaction(final String txId) {
<span class="fc" id="L640">        final Map&lt;String, String&gt; parameterSource = Map.of(TX_ID_PARAM, txId);</span>
<span class="fc" id="L641">        jdbcTemplate.update(DELETE_TRANSACTION, parameterSource);</span>
<span class="fc" id="L642">    }</span>

    /**
     * Format an instant to a timestamp without milliseconds, due to precision
     * issues with memento datetimes.
     * @param instant
     * @return
     */
    private Timestamp formatInstant(final Instant instant) {
<span class="fc" id="L651">        final var timestamp = Timestamp.from(instant);</span>
<span class="fc" id="L652">        timestamp.setNanos(0);</span>
<span class="fc" id="L653">        return timestamp;</span>
    }

    /**
     * Clear all entries from the index
     */
    @Transactional
    public void clearIndex() {
<span class="fc" id="L661">        jdbcTemplate.update(TRUNCATE_MEMBERSHIP, Map.of());</span>
<span class="fc" id="L662">        jdbcTemplate.update(TRUNCATE_MEMBERSHIP_TX, Map.of());</span>
<span class="fc" id="L663">    }</span>

    /**
     * Log all membership entries, for debugging usage only
     */
    public void logMembership() {
<span class="nc" id="L669">        log.info(&quot;source_id, proxy_id, subject_id, property, object_id, start_time, end_time, last_updated&quot;);</span>
<span class="nc" id="L670">        jdbcTemplate.query(SELECT_ALL_MEMBERSHIP, new RowCallbackHandler() {</span>
            @Override
            public void processRow(final ResultSet rs) throws SQLException {
<span class="nc" id="L673">                log.info(&quot;{}, {}, {}, {}, {}, {}, {}, {}&quot;,</span>
<span class="nc" id="L674">                        rs.getString(&quot;source_id&quot;), rs.getString(&quot;proxy_id&quot;), rs.getString(&quot;subject_id&quot;),</span>
<span class="nc" id="L675">                        rs.getString(&quot;property&quot;), rs.getString(&quot;object_id&quot;), rs.getTimestamp(&quot;start_time&quot;),</span>
<span class="nc" id="L676">                        rs.getTimestamp(&quot;end_time&quot;), rs.getTimestamp(&quot;last_updated&quot;));</span>
<span class="nc" id="L677">            }</span>
        });
<span class="nc" id="L679">    }</span>

    /**
     * Log all membership operations, for debugging usage only
     */
    public void logOperations() {
<span class="nc" id="L685">        log.info(&quot;source_id, proxy_id, subject_id, property, object_id, start_time, end_time,&quot;</span>
                + &quot; last_updated, tx_id, operation, force_flag&quot;);
<span class="nc" id="L687">        jdbcTemplate.query(SELECT_ALL_OPERATIONS, new RowCallbackHandler() {</span>
            @Override
            public void processRow(final ResultSet rs) throws SQLException {
<span class="nc" id="L690">                log.info(&quot;{}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}&quot;,</span>
<span class="nc" id="L691">                        rs.getString(&quot;source_id&quot;), rs.getString(&quot;proxy_id&quot;), rs.getString(&quot;subject_id&quot;),</span>
<span class="nc" id="L692">                        rs.getString(&quot;property&quot;), rs.getString(&quot;object_id&quot;), rs.getTimestamp(&quot;start_time&quot;),</span>
<span class="nc" id="L693">                        rs.getTimestamp(&quot;end_time&quot;), rs.getTimestamp(&quot;last_updated&quot;), rs.getString(&quot;tx_id&quot;),</span>
<span class="nc" id="L694">                        rs.getString(&quot;operation&quot;), rs.getString(&quot;force_flag&quot;));</span>
<span class="nc" id="L695">            }</span>
        });
<span class="nc" id="L697">    }</span>

    /**
     * Set the JDBC datastore.
     * @param dataSource the dataStore.
     */
    public void setDataSource(final DataSource dataSource) {
<span class="fc" id="L704">        this.dataSource = dataSource;</span>
<span class="fc" id="L705">    }</span>

    /**
     * Get the JDBC datastore.
     * @return the dataStore.
     */
    public DataSource getDataSource() {
<span class="fc" id="L712">        return dataSource;</span>
    }

    /**
     * Private class to back a stream with a paged DB query.
     *
     * If this needs to be run in parallel we will have to override trySplit() and determine a good method to split on.
     */
    private class MembershipIterator extends Spliterators.AbstractSpliterator&lt;Triple&gt; {
<span class="fc" id="L721">        final Queue&lt;Triple&gt; children = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L722">        int numOffsets = 0;</span>
        final String queryToUse;
        final MapSqlParameterSource parameterSource;
        final RowMapper&lt;Triple&gt; rowMapper;

        public MembershipIterator(final String query, final MapSqlParameterSource parameters,
<span class="fc" id="L728">                                  final RowMapper&lt;Triple&gt; mapper) {</span>
<span class="fc" id="L729">            super(Long.MAX_VALUE, Spliterator.ORDERED);</span>
<span class="fc" id="L730">            queryToUse = query;</span>
<span class="fc" id="L731">            parameterSource = parameters;</span>
<span class="fc" id="L732">            rowMapper = mapper;</span>
<span class="fc" id="L733">            parameterSource.addValue(ADD_OP_PARAM, ADD_OPERATION);</span>
<span class="fc" id="L734">            parameterSource.addValue(DELETE_OP_PARAM, DELETE_OPERATION);</span>
<span class="fc" id="L735">            parameterSource.addValue(LIMIT_PARAM, MEMBERSHIP_LIMIT);</span>
<span class="fc" id="L736">        }</span>

        @Override
        public boolean tryAdvance(final Consumer&lt;? super Triple&gt; action) {
            try {
<span class="fc" id="L741">                action.accept(children.remove());</span>
<span class="fc" id="L742">            } catch (final NoSuchElementException e) {</span>
<span class="fc" id="L743">                parameterSource.addValue(OFFSET_PARAM, numOffsets * MEMBERSHIP_LIMIT);</span>
<span class="fc" id="L744">                numOffsets += 1;</span>
<span class="fc" id="L745">                children.addAll(jdbcTemplate.query(queryToUse, parameterSource, rowMapper));</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">                if (children.size() == 0) {</span>
                    // no more elements.
<span class="fc" id="L748">                    return false;</span>
                }
<span class="fc" id="L750">                action.accept(children.remove());</span>
<span class="fc" id="L751">            }</span>
<span class="fc" id="L752">            return true;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>