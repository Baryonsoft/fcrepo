<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JcrRdfTools.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fedora Repository Kernel Implementation</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.kernel.impl.rdf</a> &gt; <span class="el_source">JcrRdfTools.java</span></div><h1>JcrRdfTools.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2014 DuraSpace, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.fcrepo.kernel.impl.rdf;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Throwables.propagate;
import static com.google.common.collect.Iterables.any;
import static com.hp.hpl.jena.graph.Triple.create;
import static com.hp.hpl.jena.rdf.model.ModelFactory.createDefaultModel;
import static com.hp.hpl.jena.rdf.model.ResourceFactory.createProperty;
import static java.util.Collections.emptyMap;
import static java.util.Collections.singleton;
import static javax.jcr.PropertyType.REFERENCE;
import static javax.jcr.PropertyType.STRING;
import static javax.jcr.PropertyType.UNDEFINED;
import static javax.jcr.PropertyType.URI;
import static javax.jcr.PropertyType.WEAKREFERENCE;
import static org.fcrepo.kernel.RdfLexicon.HAS_MEMBER_OF_RESULT;
import static org.fcrepo.kernel.RdfLexicon.JCR_NAMESPACE;
import static org.fcrepo.kernel.RdfLexicon.LDP_NAMESPACE;
import static org.fcrepo.kernel.RdfLexicon.REPOSITORY_NAMESPACE;
import static org.fcrepo.kernel.impl.utils.FedoraTypesUtils.isReferenceProperty;
import static org.fcrepo.kernel.utils.NamespaceTools.getNamespaceRegistry;
import static org.fcrepo.kernel.impl.utils.NodePropertiesTools.getReferencePropertyOriginalName;
import static org.slf4j.LoggerFactory.getLogger;

import java.util.Iterator;
import java.util.Map;

import javax.jcr.Node;
import javax.jcr.Property;
import javax.jcr.PropertyType;
import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.Value;
import javax.jcr.ValueFormatException;
import javax.jcr.ValueFactory;
import javax.jcr.nodetype.NodeType;
import javax.jcr.nodetype.PropertyDefinition;

import org.fcrepo.kernel.RdfLexicon;
import org.fcrepo.kernel.rdf.HierarchyRdfContextOptions;
import org.fcrepo.kernel.rdf.IdentifierTranslator;
import org.fcrepo.kernel.impl.rdf.impl.FixityRdfContext;
import org.fcrepo.kernel.impl.rdf.impl.HierarchyRdfContext;
import org.fcrepo.kernel.impl.rdf.impl.NamespaceRdfContext;
import org.fcrepo.kernel.impl.rdf.impl.PropertiesRdfContext;
import org.fcrepo.kernel.impl.rdf.impl.ReferencesRdfContext;
import org.fcrepo.kernel.impl.rdf.impl.VersionsRdfContext;
import org.fcrepo.kernel.impl.rdf.impl.WorkspaceRdfContext;
import org.fcrepo.kernel.utils.FixityResult;
import org.fcrepo.kernel.utils.iterators.RdfStream;
import org.modeshape.jcr.api.NamespaceRegistry;
import org.modeshape.jcr.api.Namespaced;
import org.slf4j.Logger;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.BiMap;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableList;
import com.hp.hpl.jena.datatypes.RDFDatatype;
import com.hp.hpl.jena.datatypes.xsd.XSDDateTime;
import com.hp.hpl.jena.rdf.model.Literal;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.RDFNode;
import com.hp.hpl.jena.rdf.model.Resource;

/**
 * A set of helpful tools for converting JCR properties to RDF
 *
 * @author Chris Beer
 * @since May 10, 2013
 */
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">public class JcrRdfTools {</span>

<span class="fc" id="L90">    private static final Logger LOGGER = getLogger(JcrRdfTools.class);</span>

    /**
     * A map of JCR namespaces to Fedora's RDF namespaces
     */
<span class="fc" id="L95">    public static BiMap&lt;String, String&gt; jcrNamespacesToRDFNamespaces =</span>
        ImmutableBiMap.of(JCR_NAMESPACE,
                RdfLexicon.REPOSITORY_NAMESPACE);

    /**
     * A map of Fedora's RDF namespaces to the JCR equivalent
     */
<span class="fc" id="L102">    public static BiMap&lt;String, String&gt; rdfNamespacesToJcrNamespaces =</span>
        jcrNamespacesToRDFNamespaces.inverse();

    private final IdentifierTranslator graphSubjects;

    private Session session;

    /**
     * Factory method to create a new JcrRdfTools utility with a graph subjects
     * converter
     *
     * @param graphSubjects
     */
    public JcrRdfTools(final IdentifierTranslator graphSubjects) {
<span class="nc" id="L116">        this(graphSubjects, null);</span>
<span class="nc" id="L117">    }</span>
    /**
     * Constructor with even more context.
     *
     * @param graphSubjects
     * @param session
     */
<span class="fc" id="L124">    public JcrRdfTools(final IdentifierTranslator graphSubjects, final Session session) {</span>
<span class="fc" id="L125">        this.graphSubjects = graphSubjects;</span>
<span class="fc" id="L126">        this.session = session;</span>
<span class="fc" id="L127">    }</span>

    /**
     * Factory method to create a new JcrRdfTools instance
     *
     * @param graphSubjects
     * @return new JcrRdfTools instance
     */
    public static JcrRdfTools withContext(final IdentifierTranslator graphSubjects) {
<span class="nc" id="L136">        return new JcrRdfTools(graphSubjects);</span>
    }

    /**
     * Factory method to create a new JcrRdfTools instance
     *
     * @param idTranslator
     * @param session
     * @return new JcrRdfTools instance
     */
    public static JcrRdfTools withContext(final IdentifierTranslator idTranslator,
        final Session session) {
<span class="fc" id="L148">        checkNotNull(idTranslator, &quot;JcrRdfTools must operate with a non-null IdentifierTranslator for context!&quot;);</span>
<span class="fc" id="L149">        return new JcrRdfTools(idTranslator, session);</span>
    }

    /**
     * Convert a Fedora RDF Namespace into its JCR equivalent
     *
     * @param rdfNamespaceUri a namespace from an RDF document
     * @return the JCR namespace, or the RDF namespace if no matching JCR
     *         namespace is found
     */
    public static String getJcrNamespaceForRDFNamespace(
            final String rdfNamespaceUri) {
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        if (rdfNamespacesToJcrNamespaces.containsKey(rdfNamespaceUri)) {</span>
<span class="nc" id="L162">            return rdfNamespacesToJcrNamespaces.get(rdfNamespaceUri);</span>
        }
<span class="fc" id="L164">        return rdfNamespaceUri;</span>
    }

    /**
     * Convert a JCR namespace into an RDF namespace fit for downstream
     * consumption.
     *
     * @param jcrNamespaceUri a namespace from the JCR NamespaceRegistry
     * @return an RDF namespace for downstream consumption.
     */
    public static String getRDFNamespaceForJcrNamespace(
            final String jcrNamespaceUri) {
<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (jcrNamespacesToRDFNamespaces.containsKey(jcrNamespaceUri)) {</span>
<span class="fc" id="L177">            return jcrNamespacesToRDFNamespaces.get(jcrNamespaceUri);</span>
        }
<span class="fc" id="L179">        return jcrNamespaceUri;</span>
    }

    /**
     * Get a model in which to collect statements of RDF extraction problems
     *
     * @return an empty model
     */
    public static Model getProblemsModel() {
<span class="nc" id="L188">        return createDefaultModel();</span>
    }

    /**
     * Using the same graph subjects, create a new JcrRdfTools with the given
     * session
     *
     * @param session
     * @return a new JcrRdfTools instance with the given session
     */
    public JcrRdfTools withSession(final Session session) {
<span class="nc" id="L199">        return new JcrRdfTools(graphSubjects, session);</span>
    }

    /**
     * Get an {@link RdfStream} for the given JCR NodeIterator
     *
     * @param nodeIterator
     * @param iteratorSubject
     * @return RdfStream for the given JCR NodeIterator
     * @throws RepositoryException
     */
    public RdfStream getJcrPropertiesModel(final Iterator&lt;Node&gt; nodeIterator,
            final Resource iteratorSubject) throws RepositoryException {

<span class="nc" id="L213">        final RdfStream results = new RdfStream();</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">        while (nodeIterator.hasNext()) {</span>
<span class="nc" id="L215">            final Node node = nodeIterator.next();</span>
<span class="nc" id="L216">            results.concat(new PropertiesRdfContext(node, graphSubjects));</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">            if (iteratorSubject != null) {</span>
<span class="nc" id="L218">                results.concat(singleton(create(iteratorSubject.asNode(), HAS_MEMBER_OF_RESULT.asNode(), graphSubjects</span>
                        .getSubject(node.getPath()).asNode())));
            }
<span class="nc" id="L221">        }</span>
<span class="nc" id="L222">        return results;</span>
    }

    /**
     * Get an {@link RdfStream} for a node that includes all its own JCR properties,
     * as well as the properties of its immediate children. TODO add triples for
     * root node, ala addRepositoryMetricsToModel()
     *
     * @param node
     * @return RdfStream including all its own JCR properties and properties from immediate children
     * @throws RepositoryException
     */
    public RdfStream getJcrTriples(final Node node) throws RepositoryException {
<span class="fc" id="L235">        return new PropertiesRdfContext(node, graphSubjects);</span>
    }

    /**
     * Get an {@link RdfStream} for the JCR version history information for a node
     *
     * @param node
     * @return RdfStream for the JCR version history information for the given node
     * @throws RepositoryException
     */
    public RdfStream getVersionTriples(final Node node)
        throws RepositoryException {
<span class="fc" id="L247">        return new VersionsRdfContext(node, graphSubjects);</span>
    }

    /**
     * Serialize the JCR fixity information in an {@link RdfStream}
     *
     * @param node
     * @param blobs
     * @return fixity information triples as an RdfStream
     * @throws RepositoryException
     */
    public RdfStream getJcrTriples(final Node node,
            final Iterable&lt;FixityResult&gt; blobs) throws RepositoryException {
<span class="nc" id="L260">        return new FixityRdfContext(node, graphSubjects, blobs);</span>
    }

    /**
     * Get an {@link RdfStream} of the registered JCR namespaces
     *
     * @return namespace triples as an RdfStream
     * @throws RepositoryException
     */
    public RdfStream getNamespaceTriples() throws RepositoryException {
<span class="fc" id="L270">        return new NamespaceRdfContext(session);</span>
    }

    /**
     * Get an {@link RdfStream} of the registered JCR workspaces
     *
     * @return workspace triples as an RdfStream
     * @throws RepositoryException
     */
    public RdfStream getWorkspaceTriples(final IdentifierTranslator subjects) throws RepositoryException {
<span class="nc" id="L280">        return new WorkspaceRdfContext(session, subjects);</span>
    }

    /**
     * Add the properties of a Node's parent and immediate children (as well as
     * the jcr:content of children) to the given {@link RdfStream}
     *
     * @param node
     * @throws RepositoryException
     */
    public RdfStream getTreeTriples(final Node node,
                                    final HierarchyRdfContextOptions options) throws RepositoryException {
<span class="fc" id="L292">        return new HierarchyRdfContext(node, graphSubjects, options);</span>
    }

    /**
     * Add the properties of a Node's parent and immediate children using the default
     * serialization options
     * @param node
     * @return RdfStream of properties for the node's parent and immediate children
     * @throws RepositoryException
     */
    public RdfStream getTreeTriples(final Node node) throws RepositoryException {
<span class="nc" id="L303">        return getTreeTriples(node, HierarchyRdfContextOptions.DEFAULT);</span>
    }


    /**
     * Add the properties for inbound references to this node
     * @param node
     * @return RdfStream containing propeties for inbound references to the given node
     * @throws RepositoryException
     */
    public RdfStream getReferencesTriples(final Node node) throws RepositoryException {
<span class="fc" id="L314">        return new ReferencesRdfContext(node, graphSubjects);</span>
    }

    /**
     * Decides whether the RDF representation of this {@link Node} will receive LDP Container status.
     *
     * @param node
     * @return true if the node will receive LDP Container status
     * @throws RepositoryException
     */
    public static boolean isContainer(final Node node) throws RepositoryException {
<span class="pc bpc" id="L325" title="3 of 4 branches missed.">        return HAS_CHILD_NODE_DEFINITIONS.apply(node.getPrimaryNodeType())</span>
                || any(ImmutableList.copyOf(node.getMixinNodeTypes()),
                        HAS_CHILD_NODE_DEFINITIONS);
    }

<span class="fc" id="L330">    static Predicate&lt;NodeType&gt; HAS_CHILD_NODE_DEFINITIONS =</span>
<span class="fc" id="L331">        new Predicate&lt;NodeType&gt;() {</span>

            @Override
            public boolean apply(final NodeType input) {
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">                return input.getChildNodeDefinitions().length &gt; 0;</span>
            }
        };

    /**
     * Determine if a predicate is an internal property of a node (and should
     * not be modified from external sources)
     *
     * @param subjectNode
     * @param predicate
     * @return True if a predicate is an internal property of a node
     */
    public boolean isInternalProperty(final Node subjectNode,
            final Resource predicate) {
<span class="pc bpc" id="L349" title="10 of 12 branches missed.">        switch (predicate.getNameSpace()) {</span>
            case REPOSITORY_NAMESPACE:
            case JCR_NAMESPACE:
            case LDP_NAMESPACE:
<span class="nc" id="L353">                return true;</span>
            default:
<span class="fc" id="L355">                return false;</span>
        }
    }

    /**
     * Create a JCR value from an RDFNode, either by using the given JCR
     * PropertyType or by looking at the RDFNode Datatype
     *
     * @param data an RDF Node (possibly with a DataType)
     * @param type a JCR PropertyType value
     * @return a JCR Value
     * @throws javax.jcr.RepositoryException
     */
    public Value createValue(final Node node, final RDFNode data, final int type)
        throws RepositoryException {
<span class="fc" id="L370">        final ValueFactory valueFactory = node.getSession().getValueFactory();</span>
<span class="fc" id="L371">        return createValue(valueFactory, data, type);</span>

    }

    /**
     * Create a JCR value (with an undefined type) from a RDFNode
     * @param data
     * @return created JCR value
     * @throws RepositoryException
     */
    public Value createValue(final RDFNode data) throws RepositoryException {
<span class="nc" id="L382">        return createValue(data, UNDEFINED);</span>
    }

    /**
     * Create a JCR value from an RDFNode with the given JCR type
     * @param data
     * @param type
     * @return created JCR value
     * @throws RepositoryException
     */
    public Value createValue(final RDFNode data, final int type) throws RepositoryException {
<span class="nc" id="L393">        return createValue(session.getValueFactory(), data, type);</span>
    }

    /**
     * Create a JCR value from an RDF node with the given JCR type
     * @param valueFactory
     * @param data
     * @param type
     * @return created value
     * @throws RepositoryException
     */
    public Value createValue(final ValueFactory valueFactory, final RDFNode data, final int type)
        throws RepositoryException {
<span class="pc bpc" id="L406" title="2 of 4 branches missed.">        assert (valueFactory != null);</span>

<span class="pc bpc" id="L408" title="1 of 6 branches missed.">        if (data.isURIResource()</span>
                &amp;&amp; (type == REFERENCE || type == WEAKREFERENCE)) {
            // reference to another node (by path)
<span class="fc" id="L411">            final Node nodeFromGraphSubject = session.getNode(graphSubjects.getPathFromSubject(data.asResource()));</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">            return valueFactory.createValue(nodeFromGraphSubject,</span>
                    type == WEAKREFERENCE);
<span class="pc bpc" id="L414" title="2 of 6 branches missed.">        } else if (!data.isURIResource() &amp;&amp; (type == REFERENCE || type == WEAKREFERENCE)) {</span>
<span class="nc" id="L415">            throw new ValueFormatException(&quot;Reference properties can only refer to URIs, not literals&quot;);</span>
<span class="pc bpc" id="L416" title="1 of 4 branches missed.">        } else if (data.isURIResource() || type == URI) {</span>
            // some random opaque URI
<span class="fc" id="L418">            return valueFactory.createValue(data.toString(), PropertyType.URI);</span>
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">        } else if (data.isResource()) {</span>
            // a non-URI resource (e.g. a blank node)
<span class="nc" id="L421">            return valueFactory.createValue(data.toString(), UNDEFINED);</span>
<span class="pc bpc" id="L422" title="1 of 4 branches missed.">        } else if (data.isLiteral() &amp;&amp; type == UNDEFINED) {</span>
            // the JCR schema doesn't know what this should be; so introspect
            // the RDF and try to figure it out
<span class="fc" id="L425">            final Literal literal = data.asLiteral();</span>
<span class="fc" id="L426">            final RDFDatatype dataType = literal.getDatatype();</span>
<span class="fc" id="L427">            final Object rdfValue = literal.getValue();</span>

<span class="pc bpc" id="L429" title="1 of 2 branches missed.">            if (rdfValue instanceof Boolean) {</span>
<span class="nc" id="L430">                return valueFactory.createValue((Boolean) rdfValue);</span>
<span class="pc bpc" id="L431" title="2 of 6 branches missed.">            } else if (rdfValue instanceof Byte</span>
                    || (dataType != null &amp;&amp; dataType.getJavaClass() == Byte.class)) {
<span class="nc" id="L433">                return valueFactory.createValue(literal.getByte());</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">            } else if (rdfValue instanceof Double) {</span>
<span class="nc" id="L435">                return valueFactory.createValue((Double) rdfValue);</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">            } else if (rdfValue instanceof Float) {</span>
<span class="nc" id="L437">                return valueFactory.createValue((Float) rdfValue);</span>
<span class="pc bpc" id="L438" title="1 of 6 branches missed.">            } else if (rdfValue instanceof Long</span>
                    || (dataType != null &amp;&amp; dataType.getJavaClass() == Long.class)) {
<span class="fc" id="L440">                return valueFactory.createValue(literal.getLong());</span>
<span class="pc bpc" id="L441" title="2 of 6 branches missed.">            } else if (rdfValue instanceof Short</span>
                    || (dataType != null &amp;&amp; dataType.getJavaClass() == Short.class)) {
<span class="nc" id="L443">                return valueFactory.createValue(literal.getShort());</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">            } else if (rdfValue instanceof Integer) {</span>
<span class="nc" id="L445">                return valueFactory.createValue((Integer) rdfValue);</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">            } else if (rdfValue instanceof XSDDateTime) {</span>
<span class="nc" id="L447">                return valueFactory.createValue(((XSDDateTime) rdfValue)</span>
                        .asCalendar());
            } else {
<span class="fc" id="L450">                return valueFactory.createValue(literal.getString(), STRING);</span>
            }

        } else {
<span class="fc" id="L454">            LOGGER.debug(&quot;Using default JCR value creation for RDF literal: {}&quot;,</span>
                    data);
<span class="fc" id="L456">            return valueFactory.createValue(data.asLiteral().getString(), type);</span>
        }
    }

    /**
     * Given an RDF predicate value (namespace URI + local name), figure out
     * what JCR property to use
     *
     * @param node the JCR node we want a property for
     * @param predicate the predicate to map to a property name
     * @return JCR property name
     * @throws RepositoryException
     */
    public String getPropertyNameFromPredicate(final Node node,
        final com.hp.hpl.jena.rdf.model.Property predicate)
        throws RepositoryException {
<span class="fc" id="L472">        final Map&lt;String, String&gt; s = emptyMap();</span>
<span class="fc" id="L473">        return getPropertyNameFromPredicate(node, predicate, s);</span>

    }

    /**
     * Given an RDF predicate value (namespace URI + local name), figure out
     * what JCR property to use
     *
     * @param node the JCR node we want a property for
     * @param predicate the predicate to map to a property name
     * @param namespaceMapping prefix =&gt; uri namespace mapping
     * @return the JCR property name
     * @throws RepositoryException
     */

    public String getPropertyNameFromPredicate(final Node node, final com.hp.hpl.jena.rdf.model.Property predicate,
                                               final Map&lt;String, String&gt; namespaceMapping) throws RepositoryException {

<span class="fc" id="L491">        final NamespaceRegistry namespaceRegistry =</span>
            getNamespaceRegistry.apply(node);

<span class="fc" id="L494">        return getJcrNameForRdfNode(namespaceRegistry,</span>
                                    predicate.getNameSpace(),
                                    predicate.getLocalName(),
                                    namespaceMapping);
    }

    /**
     * Get a property name for an RDF predicate
     * @param predicate
     * @return property name from the given predicate
     * @throws RepositoryException
     */
    public String getPropertyNameFromPredicate(final com.hp.hpl.jena.rdf.model.Property predicate)
        throws RepositoryException {

<span class="nc" id="L509">        final NamespaceRegistry namespaceRegistry =</span>
            (org.modeshape.jcr.api.NamespaceRegistry) session.getWorkspace().getNamespaceRegistry();

<span class="nc" id="L512">        final Map&lt;String, String&gt; namespaceMapping = emptyMap();</span>
<span class="nc" id="L513">        return getJcrNameForRdfNode(namespaceRegistry,</span>
                                    predicate.getNameSpace(),
                                    predicate.getLocalName(),
                                    namespaceMapping);
    }

    /**
     * Get the JCR name for the given RDF resource
     * @param node
     * @param resource
     * @param namespaces
     * @return JCR name for the given RDF resource
     * @throws RepositoryException
     */
    public String getPropertyNameFromPredicate(final Node node,
                                               final Resource resource,
                                               final Map&lt;String,String&gt; namespaces) throws RepositoryException {
<span class="nc" id="L530">        final NamespaceRegistry namespaceRegistry = getNamespaceRegistry.apply(node);</span>
<span class="nc" id="L531">        return getJcrNameForRdfNode(namespaceRegistry,</span>
                                    resource.getNameSpace(),
                                    resource.getLocalName(),
                                    namespaces);
    }

    /**
     * Get the JCR property name for an RDF predicate
     *
     * @param namespaceRegistry
     * @param rdfNamespace
     * @param rdfLocalname
     * @param namespaceMapping
     * @return JCR property name for an RDF predicate
     * @throws RepositoryException
     */
    private String getJcrNameForRdfNode(final NamespaceRegistry namespaceRegistry,
                                        final String rdfNamespace,
                                        final String rdfLocalname,
                                        final Map&lt;String, String&gt; namespaceMapping)
        throws RepositoryException {

        final String prefix;

<span class="fc" id="L555">        final String namespace =</span>
            getJcrNamespaceForRDFNamespace(rdfNamespace);

<span class="pc bpc" id="L558" title="2 of 4 branches missed.">        assert (namespaceRegistry != null);</span>

<span class="fc bfc" id="L560" title="All 2 branches covered.">        if (namespaceRegistry.isRegisteredUri(namespace)) {</span>
<span class="fc" id="L561">            LOGGER.debug(&quot;Discovered namespace: {} in namespace registry.&quot;,namespace);</span>
<span class="fc" id="L562">            prefix = namespaceRegistry.getPrefix(namespace);</span>
        } else {
<span class="fc" id="L564">            LOGGER.debug(&quot;Didn't discover namespace: {} in namespace registry.&quot;,namespace);</span>
<span class="fc" id="L565">            final ImmutableBiMap&lt;String, String&gt; nsMap =</span>
                ImmutableBiMap.copyOf(namespaceMapping);
<span class="fc bfc" id="L567" title="All 2 branches covered.">            if (nsMap.containsValue(namespace)) {</span>
<span class="fc" id="L568">                LOGGER.debug(&quot;Discovered namespace: {} in namespace map: {}.&quot;, namespace,</span>
                        nsMap);
<span class="fc" id="L570">                prefix = nsMap.inverse().get(namespace);</span>
<span class="fc" id="L571">                namespaceRegistry.registerNamespace(prefix, namespace);</span>
            } else {
<span class="fc" id="L573">                prefix = namespaceRegistry.registerNamespace(namespace);</span>
            }
        }

<span class="fc" id="L577">        final String propertyName = prefix + &quot;:&quot; + rdfLocalname;</span>

<span class="fc" id="L579">        LOGGER.debug(&quot;Took RDF predicate {} and translated it to JCR property {}&quot;, namespace, propertyName);</span>

<span class="fc" id="L581">        return propertyName;</span>

    }

    /**
     * Given a node type and a property name, figure out an appropriate jcr value type
     * @param nodeType
     * @param propertyName
     * @return jcr value type
     * @throws RepositoryException
     */
    public int getPropertyType(final String nodeType, final String propertyName) throws RepositoryException {
<span class="nc" id="L593">        return getPropertyType(session.getWorkspace().getNodeTypeManager().getNodeType(nodeType), propertyName);</span>

    }

    /**
     * Given a node type and a property name, figure out an appropraite jcr value type
     * @param nodeType
     * @param propertyName
     * @return jcr value type
     */
    public int getPropertyType(final NodeType nodeType, final String propertyName) {
<span class="nc" id="L604">        final PropertyDefinition[] propertyDefinitions = nodeType.getPropertyDefinitions();</span>
<span class="nc" id="L605">        int type = UNDEFINED;</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">        for (final PropertyDefinition propertyDefinition : propertyDefinitions) {</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">            if (propertyDefinition.getName().equals(propertyName)) {</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">                if (type != UNDEFINED) {</span>
<span class="nc" id="L609">                    return UNDEFINED;</span>
                }

<span class="nc" id="L612">                type = propertyDefinition.getRequiredType();</span>
            }
        }

<span class="nc" id="L616">        return type;</span>
    }

    /**
     * Map a JCR property to an RDF property with the right namespace URI and
     * local name
     */
<span class="fc" id="L623">    public static Function&lt;Property, com.hp.hpl.jena.rdf.model.Property&gt; getPredicateForProperty =</span>
<span class="fc" id="L624">            new Function&lt;Property, com.hp.hpl.jena.rdf.model.Property&gt;() {</span>

                @Override
                public com.hp.hpl.jena.rdf.model.Property apply(
                        final Property property) {
<span class="fc" id="L629">                    LOGGER.trace(&quot;Creating predicate for property: {}&quot;,</span>
                            property);
                    try {
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">                        if (property instanceof Namespaced) {</span>
<span class="fc" id="L633">                            final Namespaced nsProperty = (Namespaced) property;</span>
<span class="fc" id="L634">                            final String uri = nsProperty.getNamespaceURI();</span>
<span class="fc" id="L635">                            final String localName = nsProperty.getLocalName();</span>
                            final String rdfLocalName;

<span class="pc bpc" id="L638" title="1 of 2 branches missed.">                            if (isReferenceProperty.apply(property)) {</span>
<span class="nc" id="L639">                                rdfLocalName = getReferencePropertyOriginalName(localName);</span>
                            } else {
<span class="fc" id="L641">                                rdfLocalName = localName;</span>
                            }
<span class="fc" id="L643">                            return createProperty(</span>
                                    getRDFNamespaceForJcrNamespace(uri),
                                                     rdfLocalName);
                        }
<span class="nc" id="L647">                        return createProperty(property.getName());</span>
<span class="nc" id="L648">                    } catch (final RepositoryException e) {</span>
<span class="nc" id="L649">                        throw propagate(e);</span>
                    }

                }
            };
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312101107</span></div></body></html>