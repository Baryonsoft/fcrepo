<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FedoraTypesUtils.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fedora Repository Kernel Implementation (ModeShape)</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.kernel.modeshape.utils</a> &gt; <span class="el_source">FedoraTypesUtils.java</span></div><h1>FedoraTypesUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to DuraSpace under one or more contributor license agreements.
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * DuraSpace licenses this file to you under the Apache License,
 * Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.fcrepo.kernel.modeshape.utils;

import java.util.Arrays;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;

import org.apache.jena.rdf.model.Resource;
import org.fcrepo.kernel.api.FedoraTypes;
import org.fcrepo.kernel.api.exception.AccessDeniedException;
import org.fcrepo.kernel.api.exception.RepositoryRuntimeException;
import org.fcrepo.kernel.api.models.FedoraResource;
import org.fcrepo.kernel.modeshape.FedoraResourceImpl;
import org.fcrepo.kernel.modeshape.services.functions.AnyTypesPredicate;
import org.modeshape.jcr.JcrRepository;
import org.modeshape.jcr.cache.NodeKey;
import org.slf4j.Logger;

import javax.jcr.NamespaceRegistry;
import javax.jcr.Node;
import javax.jcr.Property;
import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.nodetype.NodeType;
import javax.jcr.nodetype.PropertyDefinition;

import static java.util.Arrays.stream;
import static java.util.Calendar.getInstance;
import static java.util.Optional.empty;
import static java.util.TimeZone.getTimeZone;
import static javax.jcr.PropertyType.REFERENCE;
import static javax.jcr.PropertyType.WEAKREFERENCE;
import static com.google.common.collect.ImmutableSet.of;
import static org.apache.jena.rdf.model.ResourceFactory.createResource;
import static org.fcrepo.kernel.api.FedoraTypes.FEDORA_LASTMODIFIED;
import static org.fcrepo.kernel.api.FedoraTypes.LDP_DIRECT_CONTAINER;
import static org.fcrepo.kernel.api.FedoraTypes.LDP_INDIRECT_CONTAINER;
import static org.fcrepo.kernel.api.FedoraTypes.LDP_INSERTED_CONTENT_RELATION;
import static org.fcrepo.kernel.api.FedoraTypes.LDP_MEMBER_RESOURCE;
import static org.fcrepo.kernel.modeshape.FedoraJcrConstants.FROZEN_MIXIN_TYPES;
import static org.fcrepo.kernel.modeshape.FedoraJcrConstants.FROZEN_PRIMARY_TYPE;
import static org.fcrepo.kernel.modeshape.FedoraJcrConstants.FROZEN_NODE;
import static org.fcrepo.kernel.modeshape.FedoraJcrConstants.JCR_CREATED;
import static org.fcrepo.kernel.modeshape.FedoraJcrConstants.JCR_CREATEDBY;
import static org.fcrepo.kernel.modeshape.FedoraJcrConstants.JCR_FROZEN_NODE;
import static org.fcrepo.kernel.modeshape.FedoraJcrConstants.JCR_LASTMODIFIED;
import static org.fcrepo.kernel.modeshape.FedoraJcrConstants.JCR_LASTMODIFIEDBY;
import static org.fcrepo.kernel.modeshape.FedoraJcrConstants.ROOT;
import static org.fcrepo.kernel.modeshape.services.functions.JcrPropertyFunctions.isBinaryContentProperty;
import static org.fcrepo.kernel.modeshape.utils.NamespaceTools.getNamespaceRegistry;
import static org.fcrepo.kernel.modeshape.utils.UncheckedPredicate.uncheck;
import static org.modeshape.jcr.api.JcrConstants.JCR_CONTENT;
import static org.modeshape.jcr.api.JcrConstants.JCR_PRIMARY_TYPE;
import static org.modeshape.jcr.api.JcrConstants.JCR_MIXIN_TYPES;
import static org.slf4j.LoggerFactory.getLogger;

/**
 * Convenience class with static methods for manipulating Fedora types in the
 * JCR.
 *
 * @author ajs6f
 * @since Feb 14, 2013
 */
<span class="nc" id="L82">public abstract class FedoraTypesUtils implements FedoraTypes {</span>

    public static final String REFERENCE_PROPERTY_SUFFIX = &quot;_ref&quot;;

<span class="fc" id="L86">    private static final Logger LOGGER = getLogger(FedoraTypesUtils.class);</span>

<span class="fc" id="L88">    private static Set&lt;String&gt; privateProperties = of(</span>
            &quot;jcr:mime&quot;,
            &quot;jcr:mimeType&quot;,
            &quot;jcr:frozenUuid&quot;,
            &quot;jcr:uuid&quot;,
            JCR_CONTENT,
            JCR_PRIMARY_TYPE,
            JCR_LASTMODIFIED,
            JCR_MIXIN_TYPES,
            FROZEN_MIXIN_TYPES,
            FROZEN_PRIMARY_TYPE);

<span class="fc" id="L100">    private static Set&lt;String&gt; validJcrProperties = of(</span>
            JCR_CREATED,
            JCR_CREATEDBY,
            JCR_LASTMODIFIEDBY);

    /**
     * Predicate for determining whether this {@link Node} is a {@link org.fcrepo.kernel.api.models.Container}.
     */
<span class="fc" id="L108">    public static Predicate&lt;Node&gt; isContainer = new AnyTypesPredicate(FEDORA_CONTAINER);</span>

    /**
     * Predicate for determining whether this {@link Node} is a
     * {@link org.fcrepo.kernel.api.models.NonRdfSourceDescription}.
     */
<span class="fc" id="L114">    public static Predicate&lt;Node&gt; isNonRdfSourceDescription = new AnyTypesPredicate(FEDORA_NON_RDF_SOURCE_DESCRIPTION);</span>


    /**
     * Predicate for determining whether this {@link Node} is a Fedora
     * binary.
     */
<span class="fc" id="L121">    public static Predicate&lt;Node&gt; isFedoraBinary = new AnyTypesPredicate(FEDORA_BINARY);</span>

    /**
     * Predicate for determining whether this {@link FedoraResource} has a frozen node
     */
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">    public static Predicate&lt;FedoraResource&gt; isFrozenNode = f -&gt; f.hasType(FROZEN_NODE) ||</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">            f.getPath().contains(JCR_FROZEN_NODE);</span>

    /**
     * Predicate for determining whether this {@link Node} is a Fedora Skolem node.
     */
<span class="fc" id="L132">    public static Predicate&lt;Node&gt; isSkolemNode = new AnyTypesPredicate(FEDORA_SKOLEM);</span>

    /**
     * Check if a property is a reference property.
     */
<span class="fc bfc" id="L137" title="All 2 branches covered.">    public static Predicate&lt;Property&gt; isInternalReferenceProperty = uncheck(p -&gt; (p.getType() == REFERENCE ||</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">            p.getType() == WEAKREFERENCE) &amp;&amp;</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">            p.getName().endsWith(REFERENCE_PROPERTY_SUFFIX));</span>

    /**
     *  Check whether a type should be internal.
     */
<span class="fc" id="L144">    public static Predicate&lt;String&gt; hasInternalNamespace = type -&gt;</span>
<span class="fc bfc" id="L145" title="All 6 branches covered.">        type.startsWith(&quot;jcr:&quot;) || type.startsWith(&quot;mode:&quot;) || type.startsWith(&quot;nt:&quot;) ||</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">            type.startsWith(&quot;mix:&quot;);</span>

    /**
     * Predicate for determining whether a JCR property should be converted to the fedora namespace.
     */
<span class="fc" id="L151">    public static Predicate&lt;String&gt; isPublicJcrProperty = validJcrProperties::contains;</span>

    /**
     * Check whether a property is protected (ie, cannot be modified directly) but
     * is not one we've explicitly chosen to include.
     */
<span class="fc" id="L157">    private static Predicate&lt;Property&gt; isProtectedAndShouldBeHidden = uncheck(p -&gt; {</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (!p.getDefinition().isProtected()) {</span>
<span class="fc" id="L159">            return false;</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        } else if (p.getParent().isNodeType(FROZEN_NODE)) {</span>
            // everything on a frozen node is protected
            // but we wish to display it anyway and there's
            // another mechanism in place to make clear that
            // things cannot be edited.
<span class="nc" id="L165">            return false;</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        } else if (isPublicJcrProperty.test(p.getName())) {</span>
<span class="fc" id="L167">            return false;</span>
        }
<span class="fc" id="L169">        return hasInternalNamespace.test(p.getName());</span>
    });

    /**
    * Check whether a property is an internal property that should be suppressed
    * from external output.
    */
<span class="fc" id="L176">    public static Predicate&lt;Property&gt; isInternalProperty = isBinaryContentProperty</span>
<span class="fc" id="L177">                            .or(isProtectedAndShouldBeHidden::test)</span>
<span class="fc" id="L178">                            .or(uncheck(p -&gt; privateProperties.contains(p.getName())));</span>

    /**
     * Check if a node is &quot;internal&quot; and should not be exposed e.g. via the REST
     * API
     */
<span class="fc" id="L184">    public static Predicate&lt;Node&gt; isInternalNode = uncheck(n -&gt; n.isNodeType(&quot;mode:system&quot;));</span>

    /**
     * Check if a node is externally managed.
     *
     * Note: modeshape uses a source-workspace-identifier scheme
     * to identify whether a node is externally-managed.
     * Ordinary (non-external) nodes will have simple UUIDs
     * as an identifier. These are never external nodes.
     *
     * External nodes will have a 7-character hex code
     * identifying the &quot;source&quot;, followed by another
     * 7-character hex code identifying the &quot;workspace&quot;, followed
     * by a &quot;/&quot; and then the rest of the &quot;identifier&quot;.
     *
     * Following that scheme, if a node's &quot;source&quot; key does not
     * match the repository's configured store name, then it is an
     * external node.
     */
<span class="fc" id="L203">    public static Predicate&lt;Node&gt; isExternalNode = uncheck(n -&gt;  {</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        if (NodeKey.isValidRandomIdentifier(n.getIdentifier())) {</span>
<span class="fc" id="L205">            return false;</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        } else if (n.getPrimaryNodeType().getName().equals(ROOT)) {</span>
<span class="nc" id="L207">            return false;</span>
        } else {
<span class="nc" id="L209">            final NodeKey key = new NodeKey(n.getIdentifier());</span>
<span class="nc" id="L210">            final String source = NodeKey.keyForSourceName(</span>
<span class="nc" id="L211">                    ((JcrRepository)n.getSession().getRepository()).getConfiguration().getName());</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            return !key.getSourceKey().equals(source);</span>
        }
    });

    /**
     * Get the JCR property type ID for a given property name. If unsure, mark
     * it as UNDEFINED.
     *
     * @param node the JCR node to add the property on
     * @param propertyName the property name
     * @return a PropertyType value
     * @throws RepositoryException if repository exception occurred
     */
    public static Optional&lt;Integer&gt; getPropertyType(final Node node, final String propertyName)
            throws RepositoryException {
<span class="fc" id="L227">        LOGGER.debug(&quot;Getting type of property: {} from node: {}&quot;, propertyName, node);</span>
<span class="fc" id="L228">        return getDefinitionForPropertyName(node, propertyName).map(PropertyDefinition::getRequiredType);</span>
    }

    /**
     * Determine if a given JCR property name is single- or multi- valued.
     * If unsure, choose the least restrictive option (multivalued = true)
     *
     * @param node the JCR node to check
     * @param propertyName the property name (which may or may not already exist)
     * @return true if the property is multivalued
     * @throws RepositoryException if repository exception occurred
     */
    public static boolean isMultivaluedProperty(final Node node, final String propertyName)
            throws RepositoryException {
<span class="fc" id="L242">        return getDefinitionForPropertyName(node, propertyName).map(PropertyDefinition::isMultiple).orElse(true);</span>
    }

    /**
     * Get the property definition information (containing type and multi-value
     * information)
     *
     * @param node the node to use for inferring the property definition
     * @param propertyName the property name to retrieve a definition for
     * @return a JCR PropertyDefinition, if available
     * @throws javax.jcr.RepositoryException if repository exception occurred
     */
    public static Optional&lt;PropertyDefinition&gt; getDefinitionForPropertyName(final Node node, final String propertyName)
            throws RepositoryException {
<span class="fc" id="L256">        LOGGER.debug(&quot;Looking for property name: {}&quot;, propertyName);</span>
<span class="fc" id="L257">        final Predicate&lt;PropertyDefinition&gt; sameName = p -&gt; propertyName.equals(p.getName());</span>

<span class="fc" id="L259">        final PropertyDefinition[] propDefs = node.getPrimaryNodeType().getPropertyDefinitions();</span>
<span class="fc" id="L260">        final Optional&lt;PropertyDefinition&gt; primaryCandidate = stream(propDefs).filter(sameName).findFirst();</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        return primaryCandidate.isPresent() ? primaryCandidate :</span>
<span class="fc" id="L262">                stream(node.getMixinNodeTypes()).map(NodeType::getPropertyDefinitions).flatMap(Arrays::stream)</span>
<span class="fc" id="L263">                        .filter(sameName).findFirst();</span>
    }

    /**
     * When we add certain URI properties, we also want to leave a reference node
     * @param propertyName the property name
     * @return property name as a reference
     */
    public static String getReferencePropertyName(final String propertyName) {
<span class="fc" id="L272">        return propertyName + REFERENCE_PROPERTY_SUFFIX;</span>
    }

    /**
     * Given an internal reference node property, get the original name
     * @param refPropertyName the reference node property name
     * @return original property name of the reference property
     */
    public static String getReferencePropertyOriginalName(final String refPropertyName) {
<span class="fc" id="L281">        final int i = refPropertyName.lastIndexOf(REFERENCE_PROPERTY_SUFFIX);</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        return i &lt; 0 ? refPropertyName : refPropertyName.substring(0, i);</span>
    }

    /**
     * Check if a property definition is a reference property
     * @param node the given node
     * @param propertyName the property name
     * @return whether a property definition is a reference property
     * @throws RepositoryException if repository exception occurred
     */
    public static boolean isReferenceProperty(final Node node, final String propertyName) throws RepositoryException {
<span class="fc" id="L293">        final Optional&lt;PropertyDefinition&gt; propertyDefinition = getDefinitionForPropertyName(node, propertyName);</span>

<span class="fc bfc" id="L295" title="All 2 branches covered.">        return propertyDefinition.isPresent() &amp;&amp;</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">                (propertyDefinition.get().getRequiredType() == REFERENCE</span>
<span class="pc bnc" id="L297" title="All 2 branches missed.">                        || propertyDefinition.get().getRequiredType() == WEAKREFERENCE);</span>
    }


    /**
     * Get the closest ancestor that current exists
     *
     * @param session the given session
     * @param path the given path
     * @return the closest ancestor that current exists
     * @throws RepositoryException if repository exception occurred
     */
    public static Node getClosestExistingAncestor(final Session session, final String path)
            throws RepositoryException {

<span class="fc bfc" id="L312" title="All 2 branches covered.">        String potentialPath = path.startsWith(&quot;/&quot;) ? path : &quot;/&quot; + path;</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">        while (!potentialPath.isEmpty()) {</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">            if (session.nodeExists(potentialPath)) {</span>
<span class="fc" id="L315">                return session.getNode(potentialPath);</span>
            }
<span class="fc" id="L317">            potentialPath = potentialPath.substring(0, potentialPath.lastIndexOf('/'));</span>
        }
<span class="fc" id="L319">        return session.getRootNode();</span>
    }

    /**
     * Retrieve the underlying JCR Node from the FedoraResource
     *
     * @param resource the Fedora resource
     * @return the JCR Node
     */
    public static Node getJcrNode(final FedoraResource resource) {
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">        if (resource instanceof FedoraResourceImpl) {</span>
<span class="fc" id="L330">            return ((FedoraResourceImpl)resource).getNode();</span>
        }
<span class="nc" id="L332">        throw new IllegalArgumentException(&quot;FedoraResource is of the wrong type&quot;);</span>
    }

    /**
     * Given a JCR Node, fetch the parent's ldp:insertedContentRelation value, if
     * one exists.
     *
     * @param node the JCR Node
     * @return the ldp:insertedContentRelation Resource, if one exists.
     */
    public static Optional&lt;Resource&gt; ldpInsertedContentProperty(final Node node) {
<span class="fc bfc" id="L343" title="All 2 branches covered.">        return getContainingNode(node).filter(uncheck(parent -&gt; parent.hasProperty(LDP_MEMBER_RESOURCE) &amp;&amp;</span>
<span class="pc bpc" id="L344" title="1 of 4 branches missed.">                parent.isNodeType(LDP_INDIRECT_CONTAINER) &amp;&amp; parent.hasProperty(LDP_INSERTED_CONTENT_RELATION)))</span>
<span class="fc" id="L345">            .map(UncheckedFunction.uncheck(parent -&gt;</span>
<span class="fc" id="L346">                        createResource(parent.getProperty(LDP_INSERTED_CONTENT_RELATION).getString())));</span>
    }

    /**
     * Using a JCR session, return a function that maps an RDF Resource to a corresponding property name.
     *
     * @param session The JCR session
     * @return a Function that maps a Resource to an Optional-wrapped String
     */
    public static Function&lt;Resource, Optional&lt;String&gt;&gt; resourceToProperty(final Session session) {
<span class="fc" id="L356">        return resource -&gt; {</span>
            try {
<span class="fc" id="L358">                final NamespaceRegistry registry = getNamespaceRegistry(session);</span>
<span class="fc" id="L359">                return Optional.of(registry.getPrefix(resource.getNameSpace()) + &quot;:&quot; + resource.getLocalName());</span>
<span class="fc" id="L360">            } catch (final RepositoryException ex) {</span>
<span class="fc" id="L361">                LOGGER.debug(&quot;Could not resolve resource namespace ({}): {}&quot;, resource.toString(), ex.getMessage());</span>
            }
<span class="fc" id="L363">            return empty();</span>
        };
    }


    /**
     * Update the fedora:lastModified date of the parent's ldp:membershipResource if that node is a direct
     * or indirect container, provided the LDP constraints are valid.
     *
     * @param node The JCR node
     */
    public static void touchLdpMembershipResource(final Node node) {
<span class="fc" id="L375">        getContainingNode(node).filter(uncheck(parent -&gt; parent.hasProperty(LDP_MEMBER_RESOURCE))).ifPresent(parent -&gt; {</span>
            try {
<span class="fc" id="L377">                final Optional&lt;String&gt; hasInsertedContentProperty = ldpInsertedContentProperty(node)</span>
<span class="fc" id="L378">                        .flatMap(resourceToProperty(node.getSession())).filter(uncheck(node::hasProperty));</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">                if (parent.isNodeType(LDP_DIRECT_CONTAINER) ||</span>
<span class="pc bpc" id="L380" title="1 of 4 branches missed.">                        (parent.isNodeType(LDP_INDIRECT_CONTAINER) &amp;&amp; hasInsertedContentProperty.isPresent())) {</span>
<span class="fc" id="L381">                    touch(parent.getProperty(LDP_MEMBER_RESOURCE).getNode());</span>
                }
<span class="nc" id="L383">            } catch (final javax.jcr.AccessDeniedException ex) {</span>
<span class="nc" id="L384">                throw new AccessDeniedException(ex);</span>
<span class="nc" id="L385">            } catch (final RepositoryException ex) {</span>
<span class="nc" id="L386">                throw new RepositoryRuntimeException(ex);</span>
<span class="fc" id="L387">            }</span>
<span class="fc" id="L388">        });</span>
<span class="fc" id="L389">    }</span>

    /**
     * Update the fedora:lastModified date of the node.
     *
     * @param node The JCR node
     */
    public static void touch(final Node node) {
        try {
<span class="fc" id="L398">            node.setProperty(FEDORA_LASTMODIFIED, getInstance(getTimeZone(&quot;UTC&quot;)));</span>
<span class="nc" id="L399">        } catch (final javax.jcr.AccessDeniedException ex) {</span>
<span class="nc" id="L400">            throw new AccessDeniedException(ex);</span>
<span class="nc" id="L401">        } catch (final RepositoryException ex) {</span>
<span class="nc" id="L402">            throw new RepositoryRuntimeException(ex);</span>
<span class="fc" id="L403">        }</span>
<span class="fc" id="L404">    }</span>

    /**
     * Get the JCR Node that corresponds to the containing node in the repository.
     * This may be the direct parent node, but it may also be a more distant ancestor.
     *
     * @param node the JCR node
     * @return the containing node, if one is present
     */
    public static Optional&lt;Node&gt; getContainingNode(final Node node) {
        try {
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">            if (node.getDepth() == 0) {</span>
<span class="nc" id="L416">                return empty();</span>
            }

<span class="fc" id="L419">            final Node parent = node.getParent();</span>
<span class="fc bfc" id="L420" title="All 4 branches covered.">            if (parent.isNodeType(FEDORA_PAIRTREE) || parent.isNodeType(FEDORA_NON_RDF_SOURCE_DESCRIPTION)) {</span>
<span class="fc" id="L421">                return getContainingNode(parent);</span>
            }
<span class="fc" id="L423">            return Optional.of(parent);</span>
<span class="nc" id="L424">        } catch (final RepositoryException ex) {</span>
<span class="nc" id="L425">            throw new RepositoryRuntimeException(ex);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>