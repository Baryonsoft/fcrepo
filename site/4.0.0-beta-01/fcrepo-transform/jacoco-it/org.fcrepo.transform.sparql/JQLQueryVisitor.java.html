<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JQLQueryVisitor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fedora Repository RDF Transformations Module</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.transform.sparql</a> &gt; <span class="el_source">JQLQueryVisitor.java</span></div><h1>JQLQueryVisitor.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2014 DuraSpace, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.fcrepo.transform.sparql;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Triple;
import com.hp.hpl.jena.query.Query;
import com.hp.hpl.jena.query.QueryVisitor;
import com.hp.hpl.jena.query.SortCondition;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.sparql.core.Prologue;
import com.hp.hpl.jena.sparql.core.TriplePath;
import com.hp.hpl.jena.sparql.expr.Expr;
import com.hp.hpl.jena.sparql.expr.ExprAggregator;
import com.hp.hpl.jena.sparql.expr.ExprFunction0;
import com.hp.hpl.jena.sparql.expr.ExprFunction1;
import com.hp.hpl.jena.sparql.expr.ExprFunction2;
import com.hp.hpl.jena.sparql.expr.ExprFunction3;
import com.hp.hpl.jena.sparql.expr.ExprFunctionN;
import com.hp.hpl.jena.sparql.expr.ExprFunctionOp;
import com.hp.hpl.jena.sparql.expr.ExprVar;
import com.hp.hpl.jena.sparql.expr.ExprVisitor;
import com.hp.hpl.jena.sparql.expr.FunctionLabel;
import com.hp.hpl.jena.sparql.expr.NodeValue;
import com.hp.hpl.jena.sparql.syntax.Element;
import com.hp.hpl.jena.sparql.syntax.ElementAssign;
import com.hp.hpl.jena.sparql.syntax.ElementBind;
import com.hp.hpl.jena.sparql.syntax.ElementData;
import com.hp.hpl.jena.sparql.syntax.ElementDataset;
import com.hp.hpl.jena.sparql.syntax.ElementExists;
import com.hp.hpl.jena.sparql.syntax.ElementFilter;
import com.hp.hpl.jena.sparql.syntax.ElementGroup;
import com.hp.hpl.jena.sparql.syntax.ElementMinus;
import com.hp.hpl.jena.sparql.syntax.ElementNamedGraph;
import com.hp.hpl.jena.sparql.syntax.ElementNotExists;
import com.hp.hpl.jena.sparql.syntax.ElementOptional;
import com.hp.hpl.jena.sparql.syntax.ElementPathBlock;
import com.hp.hpl.jena.sparql.syntax.ElementService;
import com.hp.hpl.jena.sparql.syntax.ElementSubQuery;
import com.hp.hpl.jena.sparql.syntax.ElementTriplesBlock;
import com.hp.hpl.jena.sparql.syntax.ElementUnion;
import com.hp.hpl.jena.sparql.syntax.ElementVisitor;

import org.apache.commons.lang.NotImplementedException;
import org.fcrepo.kernel.rdf.IdentifierTranslator;
import org.fcrepo.kernel.impl.rdf.JcrRdfTools;
import org.fcrepo.transform.exception.JQLParsingException;
import org.modeshape.common.collection.Collections;
import org.modeshape.jcr.api.query.qom.Limit;
import org.modeshape.jcr.api.query.qom.SelectQuery;
import org.slf4j.Logger;

import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.Value;
import javax.jcr.query.QueryManager;
import javax.jcr.query.qom.Column;
import javax.jcr.query.qom.Constraint;
import javax.jcr.query.qom.JoinCondition;
import javax.jcr.query.qom.Literal;
import javax.jcr.query.qom.Ordering;
import javax.jcr.query.qom.PropertyValue;
import javax.jcr.query.qom.QueryObjectModel;
import javax.jcr.query.qom.QueryObjectModelFactory;
import javax.jcr.query.qom.Source;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.google.common.base.Throwables.propagate;
import static com.google.common.collect.Sets.difference;
import static com.google.common.primitives.Ints.checkedCast;
import static com.hp.hpl.jena.query.Query.ORDER_DESCENDING;
import static com.hp.hpl.jena.rdf.model.ModelFactory.createDefaultModel;
import static java.lang.Integer.MAX_VALUE;
import static javax.jcr.PropertyType.REFERENCE;
import static javax.jcr.PropertyType.URI;
import static javax.jcr.PropertyType.WEAKREFERENCE;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_JOIN_TYPE_INNER;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_JOIN_TYPE_LEFT_OUTER;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_EQUAL_TO;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_GREATER_THAN;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_LESS_THAN;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_LIKE;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_NOT_EQUAL_TO;
import static org.fcrepo.jcr.FedoraJcrTypes.FEDORA_RESOURCE;
import static org.fcrepo.kernel.impl.utils.NodePropertiesTools.getReferencePropertyName;
import static org.modeshape.jcr.api.JcrConstants.JCR_PATH;
import static org.slf4j.LoggerFactory.getLogger;

/**
 * Implements the Jena QueryVisitor pattern to translate a SPARQL query into
 * a JCR query
 *
 * @author cabeer
 */
public class JQLQueryVisitor implements QueryVisitor, ElementVisitor, ExprVisitor {

<span class="fc" id="L120">    private static final Logger LOGGER = getLogger(JQLQueryVisitor.class);</span>

    private QueryObjectModelFactory queryFactory;
    private Source source;
    private ImmutableSet.Builder&lt;Column&gt; columns;
    private ImmutableList.Builder&lt;Ordering&gt;  orderings;
    private Constraint constraint;
<span class="fc" id="L127">    private boolean hasLimit = false;</span>
    private long offset;
    private long limit;
    private Session session;
    private JcrRdfTools jcrTools;
    private Set&lt;String&gt; resultsVars;
    private Map&lt;String, Column&gt; variables;
    private boolean distinct;
    private boolean inOptional;
    private Map&lt;String, Source&gt; joins;
    private Map&lt;String, String&gt; joinTypes;
    private Map&lt;String, JoinCondition&gt; joinConditions;
    private IdentifierTranslator subjects;

    /**
     * Create a new query
     * @param session
     * @param jcrTools
     * @param queryManager
     */
    public JQLQueryVisitor(final Session session,
                           final JcrRdfTools jcrTools,
                           final QueryManager queryManager,
<span class="fc" id="L150">                           final IdentifierTranslator subjects) {</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (null == subjects) {</span>
<span class="nc" id="L152">            throw new IllegalArgumentException(&quot;IdentifierTranslator is null!&quot;);</span>
        }

<span class="fc" id="L155">        this.session = session;</span>
<span class="fc" id="L156">        this.jcrTools = jcrTools;</span>
<span class="fc" id="L157">        this.queryFactory = queryManager.getQOMFactory();</span>
<span class="fc" id="L158">        this.constraint = null;</span>
<span class="fc" id="L159">        this.variables = new HashMap&lt;&gt;();</span>
<span class="fc" id="L160">        this.joins = new HashMap&lt;&gt;();</span>
<span class="fc" id="L161">        this.joinTypes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L162">        this.joinConditions = new HashMap&lt;&gt;();</span>
<span class="fc" id="L163">        this.subjects = subjects;</span>
<span class="fc" id="L164">    }</span>

    /**
     * Create a subquery, using the same variables, joins, etc, but without existing constraints
     *
     * @param jqlQueryVisitor
     */
<span class="fc" id="L171">    public JQLQueryVisitor(final JQLQueryVisitor jqlQueryVisitor) {</span>
<span class="fc" id="L172">        this.session = jqlQueryVisitor.session;</span>
<span class="fc" id="L173">        this.jcrTools = jqlQueryVisitor.jcrTools;</span>
<span class="fc" id="L174">        this.queryFactory = jqlQueryVisitor.queryFactory;</span>
<span class="fc" id="L175">        this.constraint = null;</span>
<span class="fc" id="L176">        this.variables = jqlQueryVisitor.variables;</span>
<span class="fc" id="L177">        this.joins = jqlQueryVisitor.joins;</span>
<span class="fc" id="L178">        this.joinConditions = jqlQueryVisitor.joinConditions;</span>
<span class="fc" id="L179">        this.subjects = jqlQueryVisitor.subjects;</span>
<span class="fc" id="L180">    }</span>

    /**
     * Get the raw JCR query
     * @return the JCR query
     * @throws RepositoryException
     */
    public QueryObjectModel getQuery() throws RepositoryException {
<span class="fc" id="L188">        final org.modeshape.jcr.api.query.qom.QueryObjectModelFactory modeQueryFactory =</span>
            (org.modeshape.jcr.api.query.qom.QueryObjectModelFactory)queryFactory;
        final int actualLimit;

<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (this.hasLimit) {</span>
<span class="fc" id="L193">            actualLimit = checkedCast(this.limit);</span>
        } else {
<span class="fc" id="L195">            actualLimit = MAX_VALUE;</span>
        }

<span class="fc" id="L198">        final Limit selectLimit = modeQueryFactory.limit(actualLimit, checkedCast(this.offset));</span>
<span class="fc" id="L199">        final SelectQuery query = modeQueryFactory.select(getSource(),</span>
                                                             getConstraint(),
                                                             getOrderings(),
                                                             getColumns(),
                                                             selectLimit,
                                                             distinct);


<span class="fc" id="L207">        return modeQueryFactory.createQuery(query);</span>
    }

    /**
     * Get the JCR query source information
     * @return query source information
     */
    private Source getSource() {
<span class="fc" id="L215">        final Sets.SetView&lt;String&gt; difference = difference(joins.keySet(), joinConditions.keySet());</span>

        final Source parentSource;

<span class="fc" id="L219">        final Iterator&lt;String&gt; unmatchedJoins = difference.iterator();</span>

<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (unmatchedJoins.hasNext()) {</span>
<span class="fc" id="L222">            parentSource = joins.get(unmatchedJoins.next());</span>
<span class="fc" id="L223">            this.source = parentSource;</span>
        } else {
<span class="nc" id="L225">            throw new JQLParsingException(&quot;No primary source column found in query&quot;);</span>
        }

        try {
<span class="fc bfc" id="L229" title="All 2 branches covered.">            for (final Map.Entry&lt;String, Source&gt; entry : joins.entrySet()) {</span>

<span class="fc bfc" id="L231" title="All 2 branches covered.">                if (entry.getValue() != parentSource) {</span>
                    final String joinType;

<span class="fc bfc" id="L234" title="All 2 branches covered.">                    if (joinTypes.containsKey(entry.getKey())) {</span>
<span class="fc" id="L235">                        joinType = JCR_JOIN_TYPE_INNER;</span>
                    } else {
<span class="fc" id="L237">                        joinType = JCR_JOIN_TYPE_LEFT_OUTER;</span>
                    }

<span class="fc" id="L240">                    this.source =</span>
                        queryFactory.join(this.source, entry.getValue(),
                                joinType, joinConditions.get(entry.getKey()));
                }
<span class="fc" id="L244">            }</span>

<span class="nc" id="L246">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L247">            LOGGER.info(&quot;Repository exception building query source&quot;, e);</span>
<span class="fc" id="L248">        }</span>
<span class="fc" id="L249">        return this.source;</span>
    }

    /**
     * Get the columns for the JCR query
     * @return the query columns
     */
    private Column[] getColumns() {
<span class="fc" id="L257">        final ImmutableSet&lt;Column&gt; build = this.columns.build();</span>
<span class="fc" id="L258">        return build.toArray(new Column[build.size()]);</span>
    }

    /**
     * Get the ordering of the JCR query
     * @return the query ordering
     */
    private Ordering[] getOrderings() {
<span class="fc" id="L266">        final ImmutableList&lt;Ordering&gt; build = this.orderings.build();</span>
<span class="fc" id="L267">        return build.toArray(new Ordering[build.size()]);</span>
    }

    /**
     * Get the constraints imposed on the JCR query
     * @return the query constraints
     */
    private Constraint getConstraint() {
<span class="fc" id="L275">        return this.constraint;</span>
    }

    @Override
    public void startVisit(final Query query) {
<span class="fc" id="L280">        LOGGER.trace(&quot;START VISIT: {}&quot;, query);</span>
<span class="fc" id="L281">        this.columns = new ImmutableSet.Builder&lt;&gt;();</span>
<span class="fc" id="L282">        this.orderings = new ImmutableList.Builder&lt;&gt;();</span>
<span class="fc" id="L283">    }</span>

    @Override
    public void visitPrologue(final Prologue prologue) {
<span class="fc" id="L287">        LOGGER.trace(&quot;VISIT PROLOGUE: {}&quot;, prologue);</span>
<span class="fc" id="L288">    }</span>

    @Override
    public void visitResultForm(final Query query) {
<span class="fc" id="L292">        LOGGER.trace(&quot;VISIT RESULT FORM: {}&quot;, query);</span>
<span class="fc" id="L293">    }</span>

    @Override
    public void visitSelectResultForm(final Query query) {
<span class="fc" id="L297">        LOGGER.trace(&quot;VISIT SELECT RESULT FORM: {}&quot;, query.getResultVars());</span>
<span class="fc" id="L298">        resultsVars = Collections.unmodifiableSet(query.getResultVars());</span>

<span class="fc" id="L300">        this.distinct = query.isDistinct();</span>
<span class="fc" id="L301">    }</span>

    @Override
    public void visitConstructResultForm(final Query query) {
<span class="nc" id="L305">        LOGGER.trace(&quot;VISIT CONSTRUCT RESULT FORM: {}&quot;, query);</span>
<span class="nc" id="L306">    }</span>

    @Override
    public void visitDescribeResultForm(final Query query) {
<span class="nc" id="L310">        LOGGER.trace(&quot;VISIT DESCRIBE RESULT FORM: {}&quot;, query);</span>
<span class="nc" id="L311">    }</span>

    @Override
    public void visitAskResultForm(final Query query) {
<span class="nc" id="L315">        LOGGER.trace(&quot;VISIT ASK RESULT FORM: {}&quot;, query);</span>
<span class="nc" id="L316">    }</span>

    @Override
    public void visitDatasetDecl(final Query query) {
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">        if (query.hasDatasetDescription()) {</span>
<span class="nc" id="L321">            LOGGER.trace(&quot;VISIT DATASET DESC FORM: {}&quot;, query.getDatasetDescription());</span>
        }
<span class="fc" id="L323">    }</span>

    @Override
    public void visitQueryPattern(final Query query) {
<span class="fc" id="L327">        LOGGER.trace(&quot;VISIT QUERY PATTERN: {}&quot;, query.getQueryPattern());</span>
<span class="fc" id="L328">        final Element queryPattern = query.getQueryPattern();</span>
<span class="fc" id="L329">        queryPattern.visit(this);</span>
<span class="fc" id="L330">    }</span>

    @Override
    public void visitGroupBy(final Query query) {
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">        if (query.hasGroupBy()) {</span>
<span class="nc" id="L335">            LOGGER.trace(&quot;VISIT GROUP BY: {}&quot;, query.getGroupBy());</span>
<span class="nc" id="L336">            throw new NotImplementedException(&quot;GROUP BY&quot;);</span>
        }
<span class="fc" id="L338">    }</span>

    @Override
    public void visitHaving(final Query query) {
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">        if (query.hasHaving()) {</span>
<span class="nc" id="L343">            LOGGER.trace(&quot;VISIT HAVING: {}&quot;, query.getHavingExprs());</span>
<span class="nc" id="L344">            throw new NotImplementedException(&quot;HAVING&quot;);</span>
        }
<span class="fc" id="L346">    }</span>

    @Override
    public void visitOrderBy(final Query query) {
<span class="fc bfc" id="L350" title="All 2 branches covered.">        if (query.hasOrderBy()) {</span>
<span class="fc" id="L351">            LOGGER.trace(&quot;VISIT ORDER BY: {}&quot;, query.getOrderBy());</span>
            try {
<span class="fc bfc" id="L353" title="All 2 branches covered.">                for (final SortCondition sortCondition : query.getOrderBy()) {</span>

                    final PropertyValue property;
<span class="fc" id="L356">                    final Expr expression = sortCondition.getExpression();</span>

<span class="pc bpc" id="L358" title="1 of 2 branches missed.">                    if (expression.isConstant()) {</span>
<span class="nc" id="L359">                        property = queryFactory.propertyValue(FEDORA_RESOURCE, expression.getConstant().asString());</span>
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">                    } else if (expression.isVariable()) {</span>
<span class="fc" id="L361">                        final Column c = variables.get(expression.getVarName());</span>

<span class="fc" id="L363">                        property = queryFactory.propertyValue(c.getSelectorName(), c.getPropertyName());</span>
<span class="fc" id="L364">                    } else {</span>
<span class="nc" id="L365">                        property = null;</span>
                    }

<span class="pc bpc" id="L368" title="1 of 2 branches missed.">                    if (property != null) {</span>
                        final Ordering ordering;

<span class="fc bfc" id="L371" title="All 2 branches covered.">                        if (sortCondition.getDirection() == ORDER_DESCENDING) {</span>
<span class="fc" id="L372">                            ordering = queryFactory.descending(property);</span>
                        } else {
<span class="fc" id="L374">                            ordering = queryFactory.ascending(property);</span>

                        }

<span class="fc" id="L378">                        this.orderings.add(ordering);</span>
<span class="fc" id="L379">                    } else {</span>
<span class="nc" id="L380">                        LOGGER.debug(&quot;IGNORING UNKNOWN ORDER CONDITION {}&quot;, sortCondition);</span>
                    }
<span class="fc" id="L382">                }</span>

<span class="nc" id="L384">            } catch (final RepositoryException e) {</span>
<span class="nc" id="L385">                throw propagate(e);</span>
<span class="fc" id="L386">            }</span>
        }
<span class="fc" id="L388">    }</span>

    @Override
    public void visitLimit(final Query query) {
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (query.hasLimit()) {</span>
<span class="fc" id="L393">            LOGGER.trace(&quot;VISIT LIMIT: {}&quot;, query.getLimit());</span>
<span class="fc" id="L394">            this.hasLimit = true;</span>
<span class="fc" id="L395">            this.limit = query.getLimit();</span>
        }
<span class="fc" id="L397">    }</span>

    @Override
    public void visitOffset(final Query query) {
<span class="fc bfc" id="L401" title="All 2 branches covered.">        if (query.hasOffset()) {</span>
<span class="fc" id="L402">            LOGGER.trace(&quot;VISIT OFFSET: {}&quot;, query.getOffset());</span>
<span class="fc" id="L403">            this.offset = query.getOffset();</span>
        }
<span class="fc" id="L405">    }</span>

    @Override
    public void visitValues(final Query query) {
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">        if (query.hasValues()) {</span>
<span class="nc" id="L410">            LOGGER.trace(&quot;VISIT VALUES: {}&quot;, query.getValuesData());</span>
<span class="nc" id="L411">            throw new NotImplementedException(&quot;VALUES&quot;);</span>
        }
<span class="fc" id="L413">    }</span>

    @Override
    public void finishVisit(final Query query) {
<span class="fc" id="L417">        LOGGER.trace(&quot;FINISH VISIT: {}&quot;, query);</span>
<span class="fc" id="L418">    }</span>

    @Override
    public void visit(final ElementTriplesBlock el) {
<span class="nc" id="L422">        LOGGER.trace(&quot;VISIT TRIPLES: {}&quot;, el);</span>
<span class="nc" id="L423">        final Iterator&lt;Triple&gt; tripleIterator = el.patternElts();</span>

<span class="nc bnc" id="L425" title="All 2 branches missed.">        while (tripleIterator.hasNext()) {</span>
<span class="nc" id="L426">            final Triple next = tripleIterator.next();</span>
<span class="nc" id="L427">            next.getObject();</span>
<span class="nc" id="L428">        }</span>
<span class="nc" id="L429">    }</span>

    @Override
    public void visit(final ElementPathBlock el) {
<span class="fc" id="L433">        LOGGER.trace(&quot;VISIT PATH BLOCK: {}&quot;, el);</span>
<span class="fc" id="L434">        Iterator&lt;TriplePath&gt; triplePathIterator = el.patternElts();</span>


        try {
<span class="fc bfc" id="L438" title="All 2 branches covered.">            while (triplePathIterator.hasNext()) {</span>
<span class="fc" id="L439">                final TriplePath next = triplePathIterator.next();</span>
<span class="fc" id="L440">                final Node subject = next.getSubject();</span>

<span class="fc bfc" id="L442" title="All 2 branches covered.">                if (subject.isVariable()) {</span>
<span class="fc" id="L443">                    final String selectorName =</span>
                        &quot;fedoraResource_&quot; + subject.getName();

<span class="fc" id="L446">                    this.joins.put(subject.getName(), queryFactory.selector(</span>
                            FEDORA_RESOURCE, selectorName));

<span class="fc" id="L449">                    final Column c =</span>
                        queryFactory.column(selectorName, JCR_PATH, subject
                                .getName());
<span class="fc" id="L452">                    variables.put(subject.getName(), c);</span>
                }
<span class="fc" id="L454">            }</span>

<span class="fc" id="L456">            triplePathIterator = el.patternElts();</span>

<span class="fc bfc" id="L458" title="All 2 branches covered.">            while (triplePathIterator.hasNext()) {</span>
<span class="fc" id="L459">                final TriplePath next = triplePathIterator.next();</span>
<span class="fc" id="L460">                LOGGER.trace(&quot; - TRIPLE PATH: {}&quot;, next);</span>

<span class="fc" id="L462">                final Node subject = next.getSubject();</span>
<span class="fc" id="L463">                final Node predicate = next.getPredicate();</span>
<span class="fc" id="L464">                final Node object = next.getObject();</span>
<span class="fc" id="L465">                final Model defaultModel = createDefaultModel();</span>

<span class="fc bfc" id="L467" title="All 2 branches covered.">                if (subject.isVariable()) {</span>
<span class="fc" id="L468">                    final Column c = variables.get(subject.getName());</span>

<span class="fc bfc" id="L470" title="All 2 branches covered.">                    if (resultsVars.contains(subject.getName())) {</span>
<span class="fc" id="L471">                        columns.add(c);</span>
                    }

<span class="pc bpc" id="L474" title="1 of 2 branches missed.">                    if (predicate.isVariable()) {</span>
<span class="nc" id="L475">                        throw new NotImplementedException(</span>
                                &quot;Element path may not contain a variable predicate&quot;);
                    }

<span class="fc" id="L479">                    final String propertyName =</span>
                        jcrTools.getPropertyNameFromPredicate(defaultModel
                                .createProperty(predicate.getURI()));

<span class="pc bpc" id="L483" title="1 of 4 branches missed.">                    if (propertyName.equals(&quot;rdf:type&quot;) &amp;&amp; object.isURI()) {</span>
<span class="fc" id="L484">                        final String mixinName =</span>
                            jcrTools.getPropertyNameFromPredicate(defaultModel
                                    .createProperty(object.getURI()));

<span class="fc bfc" id="L488" title="All 2 branches covered.">                        if (session.getWorkspace().getNodeTypeManager()</span>
                                .hasNodeType(mixinName)) {
<span class="fc" id="L490">                            final String selectorName =</span>
                                &quot;ref_type_&quot; + mixinName.replace(&quot;:&quot;, &quot;_&quot;);

<span class="fc" id="L493">                            this.joins.put(selectorName, queryFactory.selector(</span>
                                    mixinName, selectorName));

<span class="fc" id="L496">                            joinTypes.put(selectorName, JCR_JOIN_TYPE_INNER);</span>
<span class="fc" id="L497">                            joinConditions.put(selectorName, queryFactory</span>
                                    .sameNodeJoinCondition(c.getSelectorName(),
                                            selectorName, &quot;.&quot;));
<span class="fc" id="L500">                            continue;</span>
                        }
                    }

<span class="fc" id="L504">                    final int propertyType = jcrTools.getPropertyType(FEDORA_RESOURCE, propertyName);</span>

<span class="fc bfc" id="L506" title="All 2 branches covered.">                    if (object.isVariable()) {</span>

                        final Column objectColumn;

<span class="pc bpc" id="L510" title="2 of 8 branches missed.">                        if ((propertyType == REFERENCE || propertyType == WEAKREFERENCE || propertyType == URI)</span>
                                &amp;&amp; variables.containsKey(object.getName()))  {

<span class="fc" id="L513">                            objectColumn = variables.get(object.getName());</span>

                            final String joinPropertyName;

<span class="pc bpc" id="L517" title="1 of 2 branches missed.">                            if (propertyType == URI) {</span>
<span class="nc" id="L518">                                joinPropertyName = getReferencePropertyName(propertyName);</span>
                            } else {
<span class="fc" id="L520">                                joinPropertyName = propertyName;</span>
                            }

<span class="fc" id="L523">                            joinConditions.put(object.getName(),</span>
                                                  queryFactory.equiJoinCondition(
                                                      c.getSelectorName(), joinPropertyName,
                                                      objectColumn.getSelectorName(), &quot;jcr:uuid&quot;));
<span class="fc" id="L527">                        } else {</span>
<span class="fc" id="L528">                            objectColumn = queryFactory.column(c.getSelectorName(),</span>
                                                                  propertyName,
                                                                  object.getName());

<span class="fc" id="L532">                            variables.put(object.getName(), objectColumn);</span>

<span class="pc bpc" id="L534" title="1 of 2 branches missed.">                            if (resultsVars.contains(object.getName())) {</span>
<span class="fc" id="L535">                                columns.add(objectColumn);</span>
                            }
                        }

<span class="fc bfc" id="L539" title="All 2 branches covered.">                        if (!inOptional) {</span>
<span class="fc" id="L540">                            appendConstraint(queryFactory.propertyExistence(c.getSelectorName(), propertyName));</span>
                        }
<span class="fc" id="L542">                    } else {</span>

<span class="pc bpc" id="L544" title="1 of 2 branches missed.">                        if (!inOptional) {</span>
<span class="fc" id="L545">                            final PropertyValue field = queryFactory.propertyValue(c.getSelectorName(), propertyName);</span>
<span class="fc" id="L546">                            final Value jcrValue = jcrTools.createValue(defaultModel.asRDFNode(object), propertyType);</span>
<span class="fc" id="L547">                            final Literal literal = queryFactory.literal(jcrValue);</span>
<span class="fc" id="L548">                            appendConstraint(queryFactory.comparison(field, JCR_OPERATOR_EQUAL_TO, literal));</span>
                        }

                    }

<span class="pc bpc" id="L553" title="1 of 2 branches missed.">                } else if (predicate.isVariable()) {</span>
<span class="nc" id="L554">                    throw new NotImplementedException(&quot;Element path with constant subject and variable predicate&quot;);</span>

<span class="pc bpc" id="L556" title="1 of 2 branches missed.">                } else if (object.isVariable()) {</span>
<span class="fc" id="L557">                    convertConstantSubjectElementBlock(subject, predicate, object, defaultModel);</span>
                } else {
<span class="nc" id="L559">                    throw new NotImplementedException(&quot;Element path with constant subject/predicate/object&quot;);</span>
                }

<span class="fc" id="L562">            }</span>
<span class="nc" id="L563">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L564">            throw propagate(e);</span>
<span class="fc" id="L565">        }</span>
<span class="fc" id="L566">    }</span>

    private void convertConstantSubjectElementBlock(final Node subject,
                                                    final Node predicate,
                                                    final Node object,
                                                    final Model model)
            throws RepositoryException {

<span class="fc" id="L574">        final String subjectUri = subject.getURI();</span>

        // Go through the IdentifierConverter for potential transparent hierarchy path conversion.
<span class="fc" id="L577">        final String path = subjects.getPathFromSubject(model.createResource(subjectUri));</span>

<span class="fc" id="L579">        final String subjectSelector = &quot;fedoraResource_&quot; + path.replace(&quot;/&quot;, &quot;_&quot;);</span>

<span class="fc" id="L581">        joins.put(subjectUri, queryFactory.selector(FEDORA_RESOURCE, subjectSelector));</span>

        // Trick to add constraint for the constant subject through the jcr internal property jcr:path
<span class="fc" id="L584">        addPathConstraint(subjectSelector, model, path);</span>

<span class="pc bpc" id="L586" title="1 of 2 branches missed.">        if (predicate.isVariable()) {</span>
<span class="nc" id="L587">            throw new NotImplementedException(&quot;Element path may not contain a variable predicate&quot;);</span>
        }

<span class="fc" id="L590">        final String propertyName = jcrTools.getPropertyNameFromPredicate(model.createProperty(predicate.getURI()));</span>
<span class="pc bpc" id="L591" title="3 of 4 branches missed.">        if (propertyName.equals(&quot;rdf:type&quot;) &amp;&amp; object.isURI()) {</span>
<span class="nc" id="L592">            final String mixinName = jcrTools.getPropertyNameFromPredicate(model.createProperty(object.getURI()));</span>

<span class="nc bnc" id="L594" title="All 2 branches missed.">            if (session.getWorkspace().getNodeTypeManager().hasNodeType(mixinName)) {</span>
<span class="nc" id="L595">                final String selectorName = &quot;ref_type_&quot; + mixinName.replace(&quot;:&quot;, &quot;_&quot;);</span>

<span class="nc" id="L597">                joins.put(selectorName, queryFactory.selector(mixinName, selectorName));</span>

<span class="nc" id="L599">                joinTypes.put(selectorName, JCR_JOIN_TYPE_INNER);</span>
<span class="nc" id="L600">                joinConditions.put(selectorName,</span>
                                   queryFactory.sameNodeJoinCondition(subject.getURI(), selectorName, &quot;.&quot;));
<span class="nc" id="L602">                return;</span>
            }
        }

        final Column objectColumn;
<span class="fc" id="L607">        final int propertyType = jcrTools.getPropertyType(FEDORA_RESOURCE, propertyName);</span>
<span class="pc bpc" id="L608" title="2 of 8 branches missed.">        if ((propertyType == REFERENCE || propertyType == WEAKREFERENCE || propertyType == URI)</span>
                &amp;&amp; variables.containsKey(object.getName()))  {

<span class="fc" id="L611">            objectColumn = variables.get(object.getName());</span>

            final String joinPropertyName;

<span class="pc bpc" id="L615" title="1 of 2 branches missed.">            if (propertyType == URI) {</span>
<span class="nc" id="L616">                joinPropertyName = getReferencePropertyName(propertyName);</span>
            } else {
<span class="fc" id="L618">                joinPropertyName = propertyName;</span>
            }

<span class="fc" id="L621">            joinConditions.put(object.getName(), queryFactory.equiJoinCondition(</span>
                    subjectSelector, joinPropertyName, objectColumn.getSelectorName(), &quot;jcr:uuid&quot;));
<span class="fc" id="L623">        } else {</span>
<span class="fc" id="L624">            objectColumn = queryFactory.column(subjectSelector, propertyName, object.getName());</span>

<span class="fc" id="L626">            variables.put(object.getName(), objectColumn);</span>

<span class="pc bpc" id="L628" title="1 of 2 branches missed.">            if (resultsVars.contains(object.getName())) {</span>
<span class="fc" id="L629">                columns.add(objectColumn);</span>
            }
        }

<span class="pc bpc" id="L633" title="1 of 2 branches missed.">        if (!inOptional) {</span>
<span class="fc" id="L634">            appendConstraint(queryFactory.propertyExistence(subjectSelector, propertyName));</span>
        }
<span class="fc" id="L636">    }</span>

    @Override
    public void visit(final ElementFilter el) {
<span class="fc" id="L640">        LOGGER.trace(&quot;VISIT FILTER: {}&quot;, el);</span>
<span class="fc" id="L641">        el.getExpr().visit(this);</span>
<span class="fc" id="L642">    }</span>

    @Override
    public void visit(final ElementAssign el) {
<span class="nc" id="L646">        LOGGER.trace(&quot;VISIT ASSIGN: {}&quot;, el);</span>
<span class="nc" id="L647">        throw new NotImplementedException(&quot;ASSIGN&quot;);</span>
    }

    @Override
    public void visit(final ElementBind el) {
<span class="nc" id="L652">        LOGGER.trace(&quot;VISIT BIND: {}&quot;, el);</span>
<span class="nc" id="L653">        throw new NotImplementedException(&quot;BIND&quot;);</span>
    }

    @Override
    public void visit(final ElementData el) {
<span class="nc" id="L658">        LOGGER.trace(&quot;VISIT DATA: {}&quot;, el);</span>
<span class="nc" id="L659">        throw new NotImplementedException(&quot;DATA&quot;);</span>
    }

    @Override
    public void visit(final ElementUnion el) {
<span class="nc" id="L664">        LOGGER.trace(&quot;VISIT UNION: {}&quot;, el);</span>
<span class="nc" id="L665">        throw new NotImplementedException(&quot;UNION&quot;);</span>
    }

    @Override
    public void visit(final ElementOptional el) {
<span class="fc" id="L670">        LOGGER.trace(&quot;VISIT OPTIONAL: {}&quot;, el);</span>
<span class="fc" id="L671">        this.inOptional = true;</span>
<span class="fc" id="L672">        el.getOptionalElement().visit(this);</span>
<span class="fc" id="L673">        this.inOptional = false;</span>
<span class="fc" id="L674">    }</span>

    @Override
    public void visit(final ElementGroup el) {
<span class="fc" id="L678">        LOGGER.trace(&quot;VISIT GROUP: {}&quot;, el);</span>

<span class="fc bfc" id="L680" title="All 2 branches covered.">        for (final Element element : el.getElements()) {</span>
<span class="fc" id="L681">            element.visit(this);</span>
<span class="fc" id="L682">        }</span>
<span class="fc" id="L683">    }</span>

    @Override
    public void visit(final ElementDataset el) {
<span class="nc" id="L687">        LOGGER.trace(&quot;VISIT DATASET: {}&quot;, el);</span>
<span class="nc" id="L688">        throw new NotImplementedException(&quot;DATASET&quot;);</span>
    }

    @Override
    public void visit(final ElementNamedGraph el) {
<span class="nc" id="L693">        LOGGER.trace(&quot;VISIT NAMED GRAPH: {}&quot;, el);</span>
<span class="nc" id="L694">        throw new NotImplementedException(&quot;NAMED GRAPH&quot;);</span>
    }

    @Override
    public void visit(final ElementExists el) {
<span class="nc" id="L699">        LOGGER.trace(&quot;VISIT EXISTS: {}&quot;, el);</span>
<span class="nc" id="L700">        throw new NotImplementedException(&quot;EXISTS&quot;);</span>
    }

    @Override
    public void visit(final ElementNotExists el) {
<span class="nc" id="L705">        LOGGER.trace(&quot;VISIT NOT EXISTS: {}&quot;, el);</span>
<span class="nc" id="L706">        throw new NotImplementedException(&quot;NOT EXISTS&quot;);</span>
    }

    @Override
    public void visit(final ElementMinus el) {
<span class="nc" id="L711">        LOGGER.trace(&quot;VISIT MINUS: {}&quot;, el);</span>
<span class="nc" id="L712">        throw new NotImplementedException(&quot;MINUS&quot;);</span>
    }

    @Override
    public void visit(final ElementService el) {
<span class="nc" id="L717">        LOGGER.trace(&quot;VISIT SERVICE: {}&quot;, el);</span>
<span class="nc" id="L718">        throw new NotImplementedException(&quot;SERVICE&quot;);</span>
    }

    @Override
    public void visit(final ElementSubQuery el) {
<span class="nc" id="L723">        LOGGER.trace(&quot;VISIT SUBQUERY: {}&quot;, el);</span>
<span class="nc" id="L724">        throw new NotImplementedException(&quot;SUB QUERY&quot;);</span>
    }

    @Override
    public void startVisit() {
<span class="nc" id="L729">    }</span>

    @Override
    public void visit(final ExprFunction0 func) {
<span class="nc" id="L733">        LOGGER.trace(&quot;VISIT EXPRFUNCTION0: {}&quot;, func);</span>
<span class="nc" id="L734">    }</span>

    @Override
    public void visit(final ExprFunction1 func) {
<span class="fc" id="L738">        LOGGER.trace(&quot;VISIT EXPRFUNCTION1: {}&quot;, func);</span>
<span class="fc" id="L739">        final String funcName = func.getFunctionSymbol().getSymbol().toLowerCase();</span>

        try {
<span class="pc bpc" id="L742" title="7 of 10 branches missed.">            switch (funcName) {</span>
                case &quot;not&quot;:
<span class="fc" id="L744">                    final JQLQueryVisitor subVisitor1 = new JQLQueryVisitor(this);</span>
<span class="fc" id="L745">                    func.getArg().visit(subVisitor1);</span>
<span class="fc" id="L746">                    appendConstraint(queryFactory.not(subVisitor1.getConstraint()));</span>
<span class="fc" id="L747">                    break;</span>
                case &quot;bound&quot;:
<span class="nc" id="L749">                    final Column column = variables.get(func.getArg().getVarName());</span>
<span class="nc" id="L750">                    appendConstraint(queryFactory.propertyExistence(column.getSelectorName(),</span>
                                                                    column.getPropertyName()));
<span class="nc" id="L752">                    break;</span>
                default:
<span class="nc" id="L754">                    throw new NotImplementedException(funcName);</span>
            }

<span class="nc" id="L757">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L758">            LOGGER.info(&quot;Got exception visiting ExprFunction1 method {}&quot;, funcName, e);</span>
<span class="fc" id="L759">        }</span>
<span class="fc" id="L760">    }</span>

    @Override
    public void visit(final ExprFunction2 func) {
<span class="fc" id="L764">        LOGGER.trace(&quot;VISIT EXPRFUNCTION2: {}&quot;, func);</span>
<span class="fc" id="L765">        final String funcName = func.getFunctionSymbol().getSymbol().toLowerCase();</span>

        try {
<span class="fc bfc" id="L768" title="All 4 branches covered.">            if (funcName.equals(&quot;and&quot;) || funcName.equals(&quot;or&quot;)) {</span>
<span class="fc" id="L769">                final JQLQueryVisitor subVisitor1 = new JQLQueryVisitor(this);</span>
<span class="fc" id="L770">                func.getArg1().visit(subVisitor1);</span>


<span class="fc" id="L773">                final JQLQueryVisitor subVisitor2 = new JQLQueryVisitor(this);</span>
<span class="fc" id="L774">                func.getArg2().visit(subVisitor2);</span>

<span class="pc bpc" id="L776" title="4 of 10 branches missed.">                switch (funcName) {</span>
                    case &quot;and&quot;:
<span class="fc" id="L778">                        appendConstraint(queryFactory.and(subVisitor1</span>
                                .getConstraint(), subVisitor2.getConstraint()));
<span class="fc" id="L780">                        break;</span>
                    case &quot;or&quot;:
<span class="fc" id="L782">                        appendConstraint(queryFactory.or(subVisitor1</span>
                                .getConstraint(), subVisitor2.getConstraint()));
<span class="fc" id="L784">                        break;</span>
                    default:
<span class="nc" id="L786">                        throw new NotImplementedException(funcName);</span>
                }
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">            } else if (!func.getArg2().isConstant()) {</span>
<span class="nc" id="L789">                throw new NotImplementedException(</span>
                        &quot;EXPRFUNCTION2 2nd argument must be a constant: &quot;
                                + func.getArg1() + &quot;; &quot; + func.getArg2());
            } else {
                final String op;
<span class="fc" id="L794">                String value = func.getArg2().getConstant().getString();</span>
<span class="pc bpc" id="L795" title="20 of 38 branches missed.">                switch(funcName) {</span>
                    case &quot;eq&quot;:
<span class="fc" id="L797">                        op = JCR_OPERATOR_EQUAL_TO;</span>
<span class="fc" id="L798">                        break;</span>
                    case &quot;ge&quot;:
<span class="fc" id="L800">                        op = JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO;</span>
<span class="fc" id="L801">                        break;</span>
                    case &quot;le&quot;:
<span class="nc" id="L803">                        op = JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO;</span>
<span class="nc" id="L804">                        break;</span>
                    case &quot;lt&quot;:
<span class="fc" id="L806">                        op = JCR_OPERATOR_LESS_THAN;</span>
<span class="fc" id="L807">                        break;</span>
                    case &quot;gt&quot;:
<span class="nc" id="L809">                        op = JCR_OPERATOR_GREATER_THAN;</span>
<span class="nc" id="L810">                        break;</span>
                    case &quot;ne&quot;:
<span class="nc" id="L812">                        op = JCR_OPERATOR_NOT_EQUAL_TO;</span>
<span class="nc" id="L813">                        break;</span>
                    case &quot;contains&quot;:
<span class="fc" id="L815">                        op = JCR_OPERATOR_LIKE;</span>
<span class="fc" id="L816">                        value = &quot;%&quot; + value + &quot;%&quot;;</span>
<span class="fc" id="L817">                        break;</span>
                    case &quot;strstarts&quot;:
<span class="fc" id="L819">                        op = JCR_OPERATOR_LIKE;</span>
<span class="fc" id="L820">                        value = value + &quot;%&quot;;</span>
<span class="fc" id="L821">                        break;</span>
                    case &quot;strends&quot;:
<span class="fc" id="L823">                        op = JCR_OPERATOR_LIKE;</span>
<span class="fc" id="L824">                        value = &quot;%&quot; + value;</span>
<span class="fc" id="L825">                        break;</span>
                    default:
<span class="nc" id="L827">                        throw new NotImplementedException(funcName);</span>
                }

<span class="fc" id="L830">                appendConstraint(queryFactory.comparison(getPropertyValue(func</span>
                        .getArg1()), op, queryFactory.literal(getValue(value))));

            }

<span class="nc" id="L835">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L836">            throw propagate(e);</span>
<span class="fc" id="L837">        }</span>


<span class="fc" id="L840">    }</span>

    @Override
    public void visit(final ExprFunction3 func) {
<span class="nc" id="L844">        LOGGER.trace(&quot;VISIT EXPRFUNCTION3: {}&quot;, func);</span>
<span class="nc" id="L845">    }</span>

    @Override
    public void visit(final ExprFunctionN func) {
<span class="fc" id="L849">        LOGGER.trace(&quot;VISIT EXPRFUNCTIONN: {}&quot;, func);</span>
        try {
<span class="fc" id="L851">            final FunctionLabel functionSymbol = func.getFunctionSymbol();</span>
<span class="fc" id="L852">            final List&lt;Expr&gt; args = func.getArgs();</span>

<span class="fc" id="L854">            final String symbol = functionSymbol.getSymbol().toLowerCase();</span>
<span class="pc bpc" id="L855" title="1 of 2 branches missed.">            if (symbol.equals(&quot;regex&quot;)) {</span>
<span class="fc" id="L856">                final Expr expr = args.get(0);</span>

<span class="pc bpc" id="L858" title="1 of 2 branches missed.">                if (expr.isVariable()) {</span>
<span class="fc" id="L859">                    appendConstraint(queryFactory.comparison(</span>
                            getPropertyValue(expr), JCR_OPERATOR_LIKE,
                            queryFactory.literal(getValue(args.get(1)))));
                } else {
<span class="nc" id="L863">                    throw new NotImplementedException(&quot;ExprFunctionN &quot; + symbol);</span>
                }

<span class="fc" id="L866">            } else {</span>
<span class="nc" id="L867">                throw new NotImplementedException(&quot;ExprFunctionN &quot; + symbol);</span>
            }

<span class="nc" id="L870">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L871">            throw propagate(e);</span>
<span class="fc" id="L872">        }</span>
<span class="fc" id="L873">    }</span>

    @Override
    public void visit(final ExprFunctionOp funcOp) {
<span class="nc" id="L877">        LOGGER.trace(&quot;VISIT EXPRFUNCTIONOp: {}&quot;, funcOp);</span>
<span class="nc" id="L878">    }</span>

    @Override
    public void visit(final NodeValue nv) {
<span class="nc" id="L882">        LOGGER.trace(&quot;VISIT NODEVALUE: {}&quot;, nv);</span>
<span class="nc" id="L883">    }</span>

    @Override
    public void visit(final ExprVar nv) {
<span class="nc" id="L887">        LOGGER.trace(&quot;VISIT EXPRVAR: {}&quot;, nv);</span>
<span class="nc" id="L888">    }</span>

    @Override
    public void visit(final ExprAggregator eAgg) {
<span class="nc" id="L892">        LOGGER.trace(&quot;VISIT EXPRAGGREGATOR: {}&quot;, eAgg);</span>
<span class="nc" id="L893">    }</span>

    @Override
    public void finishVisit() {
<span class="nc" id="L897">    }</span>

    private PropertyValue getPropertyValue(final Column column) {
        try {
<span class="fc" id="L901">            return queryFactory.propertyValue(column.getSelectorName(), column.getPropertyName());</span>
<span class="nc" id="L902">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L903">            throw propagate(e);</span>
        }
    }

    private PropertyValue getPropertyValue(final Expr expr) {
<span class="fc" id="L908">        return getPropertyValue(variables.get(expr.getVarName()));</span>
    }

    private Value getValue(final Expr e) throws RepositoryException {
<span class="fc" id="L912">        return getValue(e.getConstant().asString());</span>
    }

    private Value getValue(final String e) throws RepositoryException {
<span class="fc" id="L916">        return session.getValueFactory().createValue(e);</span>
    }

    private void appendConstraint(final Constraint c) throws RepositoryException {
<span class="fc bfc" id="L920" title="All 2 branches covered.">        if (constraint == null) {</span>
<span class="fc" id="L921">            constraint = c;</span>
        } else {
<span class="fc" id="L923">            constraint = queryFactory.and(constraint, c);</span>
        }
<span class="fc" id="L925">    }</span>

    /*
     * jcr:path property constraint for a constant subject
     */
    private void addPathConstraint(final String selector, final Model model, final String path)
            throws RepositoryException {
<span class="fc" id="L932">        final PropertyValue fieldPath = queryFactory.propertyValue(selector, &quot;jcr:path&quot;);</span>
<span class="fc" id="L933">        final Value jcrValuePath = jcrTools.createValue(model.createLiteral(path),</span>
                jcrTools.getPropertyType(FEDORA_RESOURCE, &quot;jcr:path&quot;));
<span class="fc" id="L935">        final Literal literalPath = queryFactory.literal(jcrValuePath);</span>
<span class="fc" id="L936">        appendConstraint(queryFactory.comparison(fieldPath, JCR_OPERATOR_EQUAL_TO, literalPath));</span>
<span class="fc" id="L937">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312101107</span></div></body></html>