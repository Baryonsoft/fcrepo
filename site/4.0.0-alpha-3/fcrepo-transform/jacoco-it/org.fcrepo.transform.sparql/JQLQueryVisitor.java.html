<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JQLQueryVisitor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fcrepo-transform</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.transform.sparql</a> &gt; <span class="el_source">JQLQueryVisitor.java</span></div><h1>JQLQueryVisitor.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2013 DuraSpace, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.fcrepo.transform.sparql;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Triple;
import com.hp.hpl.jena.query.Query;
import com.hp.hpl.jena.query.QueryVisitor;
import com.hp.hpl.jena.query.SortCondition;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.sparql.core.Prologue;
import com.hp.hpl.jena.sparql.core.TriplePath;
import com.hp.hpl.jena.sparql.expr.Expr;
import com.hp.hpl.jena.sparql.expr.ExprAggregator;
import com.hp.hpl.jena.sparql.expr.ExprFunction0;
import com.hp.hpl.jena.sparql.expr.ExprFunction1;
import com.hp.hpl.jena.sparql.expr.ExprFunction2;
import com.hp.hpl.jena.sparql.expr.ExprFunction3;
import com.hp.hpl.jena.sparql.expr.ExprFunctionN;
import com.hp.hpl.jena.sparql.expr.ExprFunctionOp;
import com.hp.hpl.jena.sparql.expr.ExprVar;
import com.hp.hpl.jena.sparql.expr.ExprVisitor;
import com.hp.hpl.jena.sparql.expr.FunctionLabel;
import com.hp.hpl.jena.sparql.expr.NodeValue;
import com.hp.hpl.jena.sparql.syntax.Element;
import com.hp.hpl.jena.sparql.syntax.ElementAssign;
import com.hp.hpl.jena.sparql.syntax.ElementBind;
import com.hp.hpl.jena.sparql.syntax.ElementData;
import com.hp.hpl.jena.sparql.syntax.ElementDataset;
import com.hp.hpl.jena.sparql.syntax.ElementExists;
import com.hp.hpl.jena.sparql.syntax.ElementFilter;
import com.hp.hpl.jena.sparql.syntax.ElementGroup;
import com.hp.hpl.jena.sparql.syntax.ElementMinus;
import com.hp.hpl.jena.sparql.syntax.ElementNamedGraph;
import com.hp.hpl.jena.sparql.syntax.ElementNotExists;
import com.hp.hpl.jena.sparql.syntax.ElementOptional;
import com.hp.hpl.jena.sparql.syntax.ElementPathBlock;
import com.hp.hpl.jena.sparql.syntax.ElementService;
import com.hp.hpl.jena.sparql.syntax.ElementSubQuery;
import com.hp.hpl.jena.sparql.syntax.ElementTriplesBlock;
import com.hp.hpl.jena.sparql.syntax.ElementUnion;
import com.hp.hpl.jena.sparql.syntax.ElementVisitor;
import org.apache.commons.lang.NotImplementedException;
import org.fcrepo.kernel.rdf.JcrRdfTools;
import org.fcrepo.kernel.utils.NodePropertiesTools;
import org.fcrepo.transform.exception.JQLParsingException;
import org.modeshape.common.collection.Collections;
import org.modeshape.jcr.api.query.qom.Limit;
import org.modeshape.jcr.api.query.qom.SelectQuery;
import org.slf4j.Logger;

import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.Value;
import javax.jcr.query.QueryManager;
import javax.jcr.query.qom.Column;
import javax.jcr.query.qom.Constraint;
import javax.jcr.query.qom.JoinCondition;
import javax.jcr.query.qom.Literal;
import javax.jcr.query.qom.Ordering;
import javax.jcr.query.qom.PropertyValue;
import javax.jcr.query.qom.QueryObjectModel;
import javax.jcr.query.qom.QueryObjectModelFactory;
import javax.jcr.query.qom.Source;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.google.common.base.Throwables.propagate;
import static com.google.common.collect.Sets.difference;
import static com.google.common.primitives.Ints.checkedCast;
import static com.hp.hpl.jena.query.Query.ORDER_DESCENDING;
import static com.hp.hpl.jena.rdf.model.ModelFactory.createDefaultModel;
import static java.lang.Integer.MAX_VALUE;
import static javax.jcr.PropertyType.REFERENCE;
import static javax.jcr.PropertyType.URI;
import static javax.jcr.PropertyType.WEAKREFERENCE;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_JOIN_TYPE_INNER;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_JOIN_TYPE_LEFT_OUTER;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_EQUAL_TO;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_GREATER_THAN;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_LESS_THAN;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_LIKE;
import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_NOT_EQUAL_TO;
import static org.fcrepo.jcr.FedoraJcrTypes.FEDORA_RESOURCE;
import static org.modeshape.jcr.api.JcrConstants.JCR_PATH;
import static org.slf4j.LoggerFactory.getLogger;

/**
 * Implements the Jena QueryVisitor pattern to translate a SPARQL query into
 * a JCR query
 *
 * @author cabeer
 */
public class JQLQueryVisitor implements QueryVisitor, ElementVisitor, ExprVisitor {

<span class="fc" id="L118">    private static final Logger LOGGER = getLogger(JQLQueryVisitor.class);</span>

    private QueryObjectModelFactory queryFactory;
    private Source source;
    private ImmutableSet.Builder&lt;Column&gt; columns;
    private ImmutableList.Builder&lt;Ordering&gt;  orderings;
    private Constraint constraint;
<span class="fc" id="L125">    private boolean hasLimit = false;</span>
    private long offset;
    private long limit;
    private Session session;
    private JcrRdfTools jcrTools;
    private Set&lt;String&gt; resultsVars;
    private Map&lt;String, Column&gt; variables;
    private boolean distinct;
    private boolean inOptional;
    private Map&lt;String, Source&gt; joins;
    private Map&lt;String, String&gt; joinTypes;
    private Map&lt;String, JoinCondition&gt; joinConditions;

<span class="fc" id="L138">    private NodePropertiesTools propertiesTools = new NodePropertiesTools();</span>

    /**
     * Create a new query
     * @param session
     * @param jcrTools
     * @param queryManager
     * @throws RepositoryException
     */
    public JQLQueryVisitor(final Session session,
                           final JcrRdfTools jcrTools,
<span class="fc" id="L149">                           final QueryManager queryManager) throws RepositoryException {</span>
<span class="fc" id="L150">        this.session = session;</span>
<span class="fc" id="L151">        this.jcrTools = jcrTools;</span>
<span class="fc" id="L152">        this.queryFactory = queryManager.getQOMFactory();</span>
<span class="fc" id="L153">        this.constraint = null;</span>
<span class="fc" id="L154">        this.variables = new HashMap&lt;String, Column&gt;();</span>
<span class="fc" id="L155">        this.joins = new HashMap&lt;String, Source&gt;();</span>
<span class="fc" id="L156">        this.joinTypes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L157">        this.joinConditions = new HashMap&lt;String, JoinCondition&gt;();</span>
<span class="fc" id="L158">    }</span>

    /**
     * Create a subquery, using the same variables, joins, etc, but without existing constraints
     *
     * @param jqlQueryVisitor
     */
<span class="fc" id="L165">    public JQLQueryVisitor(final JQLQueryVisitor jqlQueryVisitor) {</span>
<span class="fc" id="L166">        this.session = jqlQueryVisitor.session;</span>
<span class="fc" id="L167">        this.jcrTools = jqlQueryVisitor.jcrTools;</span>
<span class="fc" id="L168">        this.queryFactory = jqlQueryVisitor.queryFactory;</span>
<span class="fc" id="L169">        this.constraint = null;</span>
<span class="fc" id="L170">        this.variables = jqlQueryVisitor.variables;</span>
<span class="fc" id="L171">        this.joins = jqlQueryVisitor.joins;</span>
<span class="fc" id="L172">        this.joinConditions = jqlQueryVisitor.joinConditions;</span>
<span class="fc" id="L173">    }</span>

    /**
     * Get the raw JCR query
     * @return
     * @throws RepositoryException
     */
    public QueryObjectModel getQuery() throws RepositoryException {
<span class="fc" id="L181">        final org.modeshape.jcr.api.query.qom.QueryObjectModelFactory modeQueryFactory =</span>
            (org.modeshape.jcr.api.query.qom.QueryObjectModelFactory)queryFactory;
        final int actualLimit;

<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (this.hasLimit) {</span>
<span class="fc" id="L186">            actualLimit = checkedCast(this.limit);</span>
        } else {
<span class="fc" id="L188">            actualLimit = MAX_VALUE;</span>
        }

<span class="fc" id="L191">        final Limit selectLimit = modeQueryFactory.limit(actualLimit, checkedCast(this.offset));</span>
<span class="fc" id="L192">        final SelectQuery query = modeQueryFactory.select(getSource(),</span>
                                                             getConstraint(),
                                                             getOrderings(),
                                                             getColumns(),
                                                             selectLimit,
                                                             distinct);


<span class="fc" id="L200">        return modeQueryFactory.createQuery(query);</span>
    }

    /**
     * Get the JCR query source information
     * @return
     */
    private Source getSource() {
<span class="fc" id="L208">        final Sets.SetView&lt;String&gt; difference = difference(joins.keySet(), joinConditions.keySet());</span>

        final Source parentSource;

<span class="fc" id="L212">        final Iterator&lt;String&gt; unmatchedJoins = difference.iterator();</span>

<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        if (unmatchedJoins.hasNext()) {</span>
<span class="fc" id="L215">            parentSource = joins.get(unmatchedJoins.next());</span>
<span class="fc" id="L216">            this.source = parentSource;</span>
        } else {
<span class="nc" id="L218">            throw new JQLParsingException(&quot;No primary source column found in query&quot;);</span>
        }

        try {
<span class="fc bfc" id="L222" title="All 2 branches covered.">            for (final Map.Entry&lt;String, Source&gt; entry : joins.entrySet()) {</span>

<span class="fc bfc" id="L224" title="All 2 branches covered.">                if (entry.getValue() != parentSource) {</span>
                    final String joinType;

<span class="fc bfc" id="L227" title="All 2 branches covered.">                    if (joinTypes.containsKey(entry.getKey())) {</span>
<span class="fc" id="L228">                        joinType = JCR_JOIN_TYPE_INNER;</span>
                    } else {
<span class="fc" id="L230">                        joinType = JCR_JOIN_TYPE_LEFT_OUTER;</span>
                    }

<span class="fc" id="L233">                    this.source =</span>
                        queryFactory.join(this.source, entry.getValue(),
                                joinType, joinConditions.get(entry.getKey()));
                }
<span class="fc" id="L237">            }</span>

<span class="nc" id="L239">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L240">            LOGGER.info(&quot;Repository exception building query source&quot;, e);</span>
<span class="fc" id="L241">        }</span>
<span class="fc" id="L242">        return this.source;</span>
    }

    /**
     * Get the columns for the JCR query
     * @return
     */
    private Column[] getColumns() {
<span class="fc" id="L250">        final ImmutableSet&lt;Column&gt; build = this.columns.build();</span>
<span class="fc" id="L251">        return build.toArray(new Column[build.size()]);</span>
    }

    /**
     * Get the ordering of the JCR query
     * @return
     */
    private Ordering[] getOrderings() {
<span class="fc" id="L259">        final ImmutableList&lt;Ordering&gt; build = this.orderings.build();</span>
<span class="fc" id="L260">        return build.toArray(new Ordering[build.size()]);</span>
    }

    /**
     * Get the constraints imposed on the JCR query
     * @return
     */
    private Constraint getConstraint() {
<span class="fc" id="L268">        return this.constraint;</span>
    }

    @Override
    public void startVisit(final Query query) {
<span class="fc" id="L273">        LOGGER.trace(&quot;START VISIT: {}&quot;, query);</span>
<span class="fc" id="L274">        this.columns = new ImmutableSet.Builder&lt;&gt;();</span>
<span class="fc" id="L275">        this.orderings = new ImmutableList.Builder&lt;&gt;();</span>
<span class="fc" id="L276">    }</span>

    @Override
    public void visitPrologue(final Prologue prologue) {
<span class="fc" id="L280">        LOGGER.trace(&quot;VISIT PROLOGUE: {}&quot;, prologue);</span>
<span class="fc" id="L281">    }</span>

    @Override
    public void visitResultForm(final Query query) {
<span class="fc" id="L285">        LOGGER.trace(&quot;VISIT RESULT FORM: {}&quot;, query);</span>
<span class="fc" id="L286">    }</span>

    @Override
    public void visitSelectResultForm(final Query query) {
<span class="fc" id="L290">        LOGGER.trace(&quot;VISIT SELECT RESULT FORM: {}&quot;, query.getResultVars());</span>
<span class="fc" id="L291">        resultsVars = Collections.unmodifiableSet(query.getResultVars());</span>

<span class="fc" id="L293">        this.distinct = query.isDistinct();</span>
<span class="fc" id="L294">    }</span>

    @Override
    public void visitConstructResultForm(final Query query) {
<span class="nc" id="L298">        LOGGER.trace(&quot;VISIT CONSTRUCT RESULT FORM: {}&quot;, query);</span>
<span class="nc" id="L299">    }</span>

    @Override
    public void visitDescribeResultForm(final Query query) {
<span class="nc" id="L303">        LOGGER.trace(&quot;VISIT DESCRIBE RESULT FORM: {}&quot;, query);</span>
<span class="nc" id="L304">    }</span>

    @Override
    public void visitAskResultForm(final Query query) {
<span class="nc" id="L308">        LOGGER.trace(&quot;VISIT ASK RESULT FORM: {}&quot;, query);</span>
<span class="nc" id="L309">    }</span>

    @Override
    public void visitDatasetDecl(final Query query) {
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (query.hasDatasetDescription()) {</span>
<span class="nc" id="L314">            LOGGER.trace(&quot;VISIT DATASET DESC FORM: {}&quot;, query.getDatasetDescription());</span>
        }
<span class="fc" id="L316">    }</span>

    @Override
    public void visitQueryPattern(final Query query) {
<span class="fc" id="L320">        LOGGER.trace(&quot;VISIT QUERY PATTERN: {}&quot;, query.getQueryPattern());</span>
<span class="fc" id="L321">        final Element queryPattern = query.getQueryPattern();</span>
<span class="fc" id="L322">        queryPattern.visit(this);</span>
<span class="fc" id="L323">    }</span>

    @Override
    public void visitGroupBy(final Query query) {
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">        if (query.hasGroupBy()) {</span>
<span class="nc" id="L328">            LOGGER.trace(&quot;VISIT GROUP BY: {}&quot;, query.getGroupBy());</span>
<span class="nc" id="L329">            throw new NotImplementedException(&quot;GROUP BY&quot;);</span>
        }
<span class="fc" id="L331">    }</span>

    @Override
    public void visitHaving(final Query query) {
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">        if (query.hasHaving()) {</span>
<span class="nc" id="L336">            LOGGER.trace(&quot;VISIT HAVING: {}&quot;, query.getHavingExprs());</span>
<span class="nc" id="L337">            throw new NotImplementedException(&quot;HAVING&quot;);</span>
        }
<span class="fc" id="L339">    }</span>

    @Override
    public void visitOrderBy(final Query query) {
<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (query.hasOrderBy()) {</span>
<span class="fc" id="L344">            LOGGER.trace(&quot;VISIT ORDER BY: {}&quot;, query.getOrderBy());</span>
            try {
<span class="fc bfc" id="L346" title="All 2 branches covered.">                for (final SortCondition sortCondition : query.getOrderBy()) {</span>

                    final PropertyValue property;
<span class="fc" id="L349">                    final Expr expression = sortCondition.getExpression();</span>

<span class="pc bpc" id="L351" title="1 of 2 branches missed.">                    if (expression.isConstant()) {</span>
<span class="nc" id="L352">                        property = queryFactory.propertyValue(FEDORA_RESOURCE, expression.getConstant().asString());</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">                    } else if (expression.isVariable()) {</span>
<span class="fc" id="L354">                        final Column c = variables.get(expression.getVarName());</span>

<span class="fc" id="L356">                        property = queryFactory.propertyValue(c.getSelectorName(), c.getPropertyName());</span>
<span class="fc" id="L357">                    } else {</span>
<span class="nc" id="L358">                        property = null;</span>
                    }

<span class="pc bpc" id="L361" title="1 of 2 branches missed.">                    if (property != null) {</span>
                        final Ordering ordering;

<span class="fc bfc" id="L364" title="All 2 branches covered.">                        if (sortCondition.getDirection() == ORDER_DESCENDING) {</span>
<span class="fc" id="L365">                            ordering = queryFactory.descending(property);</span>
                        } else {
<span class="fc" id="L367">                            ordering = queryFactory.ascending(property);</span>

                        }

<span class="fc" id="L371">                        this.orderings.add(ordering);</span>
<span class="fc" id="L372">                    } else {</span>
<span class="nc" id="L373">                        LOGGER.debug(&quot;IGNORING UNKNOWN ORDER CONDITION {}&quot;, sortCondition);</span>
                    }
<span class="fc" id="L375">                }</span>

<span class="nc" id="L377">            } catch (final RepositoryException e) {</span>
<span class="nc" id="L378">                throw propagate(e);</span>
<span class="fc" id="L379">            }</span>
        }
<span class="fc" id="L381">    }</span>

    @Override
    public void visitLimit(final Query query) {
<span class="fc bfc" id="L385" title="All 2 branches covered.">        if (query.hasLimit()) {</span>
<span class="fc" id="L386">            LOGGER.trace(&quot;VISIT LIMIT: {}&quot;, query.getLimit());</span>
<span class="fc" id="L387">            this.hasLimit = true;</span>
<span class="fc" id="L388">            this.limit = query.getLimit();</span>
        }
<span class="fc" id="L390">    }</span>

    @Override
    public void visitOffset(final Query query) {
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (query.hasOffset()) {</span>
<span class="fc" id="L395">            LOGGER.trace(&quot;VISIT OFFSET: {}&quot;, query.getOffset());</span>
<span class="fc" id="L396">            this.offset = query.getOffset();</span>
        }
<span class="fc" id="L398">    }</span>

    @Override
    public void visitValues(final Query query) {
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        if (query.hasValues()) {</span>
<span class="nc" id="L403">            LOGGER.trace(&quot;VISIT VALUES: {}&quot;, query.getValuesData());</span>
<span class="nc" id="L404">            throw new NotImplementedException(&quot;VALUES&quot;);</span>
        }
<span class="fc" id="L406">    }</span>

    @Override
    public void finishVisit(final Query query) {
<span class="fc" id="L410">        LOGGER.trace(&quot;FINISH VISIT: {}&quot;, query);</span>
<span class="fc" id="L411">    }</span>

    @Override
    public void visit(final ElementTriplesBlock el) {
<span class="nc" id="L415">        LOGGER.trace(&quot;VISIT TRIPLES: {}&quot;, el);</span>
<span class="nc" id="L416">        final Iterator&lt;Triple&gt; tripleIterator = el.patternElts();</span>

<span class="nc bnc" id="L418" title="All 2 branches missed.">        while (tripleIterator.hasNext()) {</span>
<span class="nc" id="L419">            final Triple next = tripleIterator.next();</span>
<span class="nc" id="L420">            next.getObject();</span>
<span class="nc" id="L421">        }</span>
<span class="nc" id="L422">    }</span>

    @Override
    public void visit(final ElementPathBlock el) {
<span class="fc" id="L426">        LOGGER.trace(&quot;VISIT PATH BLOCK: {}&quot;, el);</span>
<span class="fc" id="L427">        Iterator&lt;TriplePath&gt; triplePathIterator = el.patternElts();</span>


        try {
<span class="fc bfc" id="L431" title="All 2 branches covered.">            while (triplePathIterator.hasNext()) {</span>
<span class="fc" id="L432">                final TriplePath next = triplePathIterator.next();</span>
<span class="fc" id="L433">                final Node subject = next.getSubject();</span>

<span class="pc bpc" id="L435" title="1 of 2 branches missed.">                if (subject.isVariable()) {</span>
<span class="fc" id="L436">                    final String selectorName =</span>
                        &quot;fedoraResource_&quot; + subject.getName();

<span class="fc" id="L439">                    this.joins.put(subject.getName(), queryFactory.selector(</span>
                            FEDORA_RESOURCE, selectorName));

<span class="fc" id="L442">                    final Column c =</span>
                        queryFactory.column(selectorName, JCR_PATH, subject
                                .getName());
<span class="fc" id="L445">                    variables.put(subject.getName(), c);</span>
                }
<span class="fc" id="L447">            }</span>

<span class="fc" id="L449">            triplePathIterator = el.patternElts();</span>

<span class="fc bfc" id="L451" title="All 2 branches covered.">            while (triplePathIterator.hasNext()) {</span>
<span class="fc" id="L452">                final TriplePath next = triplePathIterator.next();</span>
<span class="fc" id="L453">                LOGGER.trace(&quot; - TRIPLE PATH: {}&quot;, next);</span>

<span class="fc" id="L455">                final Node subject = next.getSubject();</span>
<span class="fc" id="L456">                final Node predicate = next.getPredicate();</span>
<span class="fc" id="L457">                final Node object = next.getObject();</span>
<span class="fc" id="L458">                final Model defaultModel = createDefaultModel();</span>

<span class="pc bpc" id="L460" title="1 of 2 branches missed.">                if (subject.isVariable()) {</span>
<span class="fc" id="L461">                    final Column c = variables.get(subject.getName());</span>

<span class="fc bfc" id="L463" title="All 2 branches covered.">                    if (resultsVars.contains(subject.getName())) {</span>
<span class="fc" id="L464">                        columns.add(c);</span>
                    }

<span class="pc bpc" id="L467" title="1 of 2 branches missed.">                    if (predicate.isVariable()) {</span>
<span class="nc" id="L468">                        throw new NotImplementedException(</span>
                                &quot;Element path may not contain a variable predicate&quot;);
                    }

<span class="fc" id="L472">                    final String propertyName =</span>
                        jcrTools.getPropertyNameFromPredicate(defaultModel
                                .createProperty(predicate.getURI()));

<span class="pc bpc" id="L476" title="1 of 4 branches missed.">                    if (propertyName.equals(&quot;rdf:type&quot;) &amp;&amp; object.isURI()) {</span>
<span class="fc" id="L477">                        final String mixinName =</span>
                            jcrTools.getPropertyNameFromPredicate(defaultModel
                                    .createProperty(object.getURI()));

<span class="fc bfc" id="L481" title="All 2 branches covered.">                        if (session.getWorkspace().getNodeTypeManager()</span>
                                .hasNodeType(mixinName)) {
<span class="fc" id="L483">                            final String selectorName =</span>
                                &quot;ref_type_&quot; + mixinName.replace(&quot;:&quot;, &quot;_&quot;);

<span class="fc" id="L486">                            this.joins.put(selectorName, queryFactory.selector(</span>
                                    mixinName, selectorName));

<span class="fc" id="L489">                            joinTypes.put(selectorName, JCR_JOIN_TYPE_INNER);</span>
<span class="fc" id="L490">                            joinConditions.put(selectorName, queryFactory</span>
                                    .sameNodeJoinCondition(c.getSelectorName(),
                                            selectorName, &quot;.&quot;));
<span class="fc" id="L493">                            continue;</span>
                        }
                    }

<span class="fc" id="L497">                    final int propertyType = jcrTools.getPropertyType(FEDORA_RESOURCE, propertyName);</span>

<span class="fc bfc" id="L499" title="All 2 branches covered.">                    if (object.isVariable()) {</span>

                        final Column objectColumn;

<span class="pc bpc" id="L503" title="2 of 8 branches missed.">                        if ((propertyType == REFERENCE || propertyType == WEAKREFERENCE || propertyType == URI)</span>
                                &amp;&amp; variables.containsKey(object.getName()))  {

<span class="fc" id="L506">                            objectColumn = variables.get(object.getName());</span>

                            final String joinPropertyName;

<span class="pc bpc" id="L510" title="1 of 2 branches missed.">                            if (propertyType == URI) {</span>
<span class="nc" id="L511">                                joinPropertyName =</span>
                                    propertiesTools
                                            .getReferencePropertyName(propertyName);
                            } else {
<span class="fc" id="L515">                                joinPropertyName = propertyName;</span>
                            }

<span class="fc" id="L518">                            joinConditions.put(object.getName(),</span>
                                                  queryFactory.equiJoinCondition(
                                                      c.getSelectorName(), joinPropertyName,
                                                      objectColumn.getSelectorName(), &quot;jcr:uuid&quot;));
<span class="fc" id="L522">                        } else {</span>
<span class="fc" id="L523">                            objectColumn = queryFactory.column(c.getSelectorName(),</span>
                                                                  propertyName,
                                                                  object.getName());

<span class="fc" id="L527">                            variables.put(object.getName(), objectColumn);</span>

<span class="pc bpc" id="L529" title="1 of 2 branches missed.">                            if (resultsVars.contains(object.getName())) {</span>
<span class="fc" id="L530">                                columns.add(objectColumn);</span>
                            }
                        }

<span class="fc bfc" id="L534" title="All 2 branches covered.">                        if (!inOptional) {</span>
<span class="fc" id="L535">                            appendConstraint(queryFactory.propertyExistence(c.getSelectorName(), propertyName));</span>
                        }
<span class="fc" id="L537">                    } else {</span>

<span class="pc bpc" id="L539" title="1 of 2 branches missed.">                        if (!inOptional) {</span>
<span class="fc" id="L540">                            final PropertyValue field = queryFactory.propertyValue(c.getSelectorName(), propertyName);</span>
<span class="fc" id="L541">                            final Value jcrValue = jcrTools.createValue(defaultModel.asRDFNode(object), propertyType);</span>
<span class="fc" id="L542">                            final Literal literal = queryFactory.literal(jcrValue);</span>
<span class="fc" id="L543">                            appendConstraint(queryFactory.comparison(field, JCR_OPERATOR_EQUAL_TO, literal));</span>
                        }

                    }

<span class="pc bnc" id="L548" title="All 2 branches missed.">                } else if (predicate.isVariable()) {</span>
<span class="nc" id="L549">                    throw new NotImplementedException(&quot;Element path with constant subject and variable predicate&quot;);</span>

<span class="nc bnc" id="L551" title="All 2 branches missed.">                } else if (object.isVariable()) {</span>
<span class="nc" id="L552">                    throw new NotImplementedException(</span>
                            &quot;Element path with constant subject and predicate, and a variable object&quot;);

                } else {
<span class="nc" id="L556">                    throw new NotImplementedException(&quot;Element path with constant subject/predicate/object&quot;);</span>
                }

<span class="fc" id="L559">            }</span>
<span class="nc" id="L560">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L561">            throw propagate(e);</span>
<span class="fc" id="L562">        }</span>
<span class="fc" id="L563">    }</span>

    @Override
    public void visit(final ElementFilter el) {
<span class="fc" id="L567">        LOGGER.trace(&quot;VISIT FILTER: {}&quot;, el);</span>
<span class="fc" id="L568">        el.getExpr().visit(this);</span>
<span class="fc" id="L569">    }</span>

    @Override
    public void visit(final ElementAssign el) {
<span class="nc" id="L573">        LOGGER.trace(&quot;VISIT ASSIGN: {}&quot;, el);</span>
<span class="nc" id="L574">        throw new NotImplementedException(&quot;ASSIGN&quot;);</span>
    }

    @Override
    public void visit(final ElementBind el) {
<span class="nc" id="L579">        LOGGER.trace(&quot;VISIT BIND: {}&quot;, el);</span>
<span class="nc" id="L580">        throw new NotImplementedException(&quot;BIND&quot;);</span>
    }

    @Override
    public void visit(final ElementData el) {
<span class="nc" id="L585">        LOGGER.trace(&quot;VISIT DATA: {}&quot;, el);</span>
<span class="nc" id="L586">        throw new NotImplementedException(&quot;DATA&quot;);</span>
    }

    @Override
    public void visit(final ElementUnion el) {
<span class="nc" id="L591">        LOGGER.trace(&quot;VISIT UNION: {}&quot;, el);</span>
<span class="nc" id="L592">        throw new NotImplementedException(&quot;UNION&quot;);</span>
    }

    @Override
    public void visit(final ElementOptional el) {
<span class="fc" id="L597">        LOGGER.trace(&quot;VISIT OPTIONAL: {}&quot;, el);</span>
<span class="fc" id="L598">        this.inOptional = true;</span>
<span class="fc" id="L599">        el.getOptionalElement().visit(this);</span>
<span class="fc" id="L600">        this.inOptional = false;</span>
<span class="fc" id="L601">    }</span>

    @Override
    public void visit(final ElementGroup el) {
<span class="fc" id="L605">        LOGGER.trace(&quot;VISIT GROUP: {}&quot;, el);</span>

<span class="fc bfc" id="L607" title="All 2 branches covered.">        for (final Element element : el.getElements()) {</span>
<span class="fc" id="L608">            element.visit(this);</span>
<span class="fc" id="L609">        }</span>
<span class="fc" id="L610">    }</span>

    @Override
    public void visit(final ElementDataset el) {
<span class="nc" id="L614">        LOGGER.trace(&quot;VISIT DATASET: {}&quot;, el);</span>
<span class="nc" id="L615">        throw new NotImplementedException(&quot;DATASET&quot;);</span>
    }

    @Override
    public void visit(final ElementNamedGraph el) {
<span class="nc" id="L620">        LOGGER.trace(&quot;VISIT NAMED GRAPH: {}&quot;, el);</span>
<span class="nc" id="L621">        throw new NotImplementedException(&quot;NAMED GRAPH&quot;);</span>
    }

    @Override
    public void visit(final ElementExists el) {
<span class="nc" id="L626">        LOGGER.trace(&quot;VISIT EXISTS: {}&quot;, el);</span>
<span class="nc" id="L627">        throw new NotImplementedException(&quot;EXISTS&quot;);</span>
    }

    @Override
    public void visit(final ElementNotExists el) {
<span class="nc" id="L632">        LOGGER.trace(&quot;VISIT NOT EXISTS: {}&quot;, el);</span>
<span class="nc" id="L633">        throw new NotImplementedException(&quot;NOT EXISTS&quot;);</span>
    }

    @Override
    public void visit(final ElementMinus el) {
<span class="nc" id="L638">        LOGGER.trace(&quot;VISIT MINUS: {}&quot;, el);</span>
<span class="nc" id="L639">        throw new NotImplementedException(&quot;MINUS&quot;);</span>
    }

    @Override
    public void visit(final ElementService el) {
<span class="nc" id="L644">        LOGGER.trace(&quot;VISIT SERVICE: {}&quot;, el);</span>
<span class="nc" id="L645">        throw new NotImplementedException(&quot;SERVICE&quot;);</span>
    }

    @Override
    public void visit(final ElementSubQuery el) {
<span class="nc" id="L650">        LOGGER.trace(&quot;VISIT SUBQUERY: {}&quot;, el);</span>
<span class="nc" id="L651">        throw new NotImplementedException(&quot;SUB QUERY&quot;);</span>
    }

    @Override
    public void startVisit() {
<span class="nc" id="L656">    }</span>

    @Override
    public void visit(final ExprFunction0 func) {
<span class="nc" id="L660">        LOGGER.trace(&quot;VISIT EXPRFUNCTION0: {}&quot;, func);</span>
<span class="nc" id="L661">    }</span>

    @Override
    public void visit(final ExprFunction1 func) {
<span class="fc" id="L665">        LOGGER.trace(&quot;VISIT EXPRFUNCTION1: {}&quot;, func);</span>
<span class="fc" id="L666">        final String funcName = func.getFunctionSymbol().getSymbol().toLowerCase();</span>

        try {
<span class="pc bpc" id="L669" title="7 of 10 branches missed.">            switch (funcName) {</span>
                case &quot;not&quot;:
<span class="fc" id="L671">                    final JQLQueryVisitor subVisitor1 = new JQLQueryVisitor(this);</span>
<span class="fc" id="L672">                    func.getArg().visit(subVisitor1);</span>
<span class="fc" id="L673">                    appendConstraint(queryFactory.not(subVisitor1.getConstraint()));</span>
<span class="fc" id="L674">                    break;</span>
                case &quot;bound&quot;:
<span class="nc" id="L676">                    final Column column = variables.get(func.getArg().getVarName());</span>
<span class="nc" id="L677">                    appendConstraint(queryFactory.propertyExistence(column.getSelectorName(),</span>
                                                                    column.getPropertyName()));
<span class="nc" id="L679">                    break;</span>
                default:
<span class="nc" id="L681">                    throw new NotImplementedException(funcName);</span>
            }

<span class="nc" id="L684">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L685">            LOGGER.info(&quot;Got exception visiting ExprFunction1 method {}&quot;, funcName, e);</span>
<span class="fc" id="L686">        }</span>
<span class="fc" id="L687">    }</span>

    @Override
    public void visit(final ExprFunction2 func) {
<span class="fc" id="L691">        LOGGER.trace(&quot;VISIT EXPRFUNCTION2: {}&quot;, func);</span>
<span class="fc" id="L692">        final String funcName = func.getFunctionSymbol().getSymbol().toLowerCase();</span>

        try {
<span class="fc bfc" id="L695" title="All 4 branches covered.">            if (funcName.equals(&quot;and&quot;) || funcName.equals(&quot;or&quot;)) {</span>
<span class="fc" id="L696">                final JQLQueryVisitor subVisitor1 = new JQLQueryVisitor(this);</span>
<span class="fc" id="L697">                func.getArg1().visit(subVisitor1);</span>


<span class="fc" id="L700">                final JQLQueryVisitor subVisitor2 = new JQLQueryVisitor(this);</span>
<span class="fc" id="L701">                func.getArg2().visit(subVisitor2);</span>

<span class="pc bpc" id="L703" title="4 of 10 branches missed.">                switch (funcName) {</span>
                    case &quot;and&quot;:
<span class="fc" id="L705">                        appendConstraint(queryFactory.and(subVisitor1</span>
                                .getConstraint(), subVisitor2.getConstraint()));
<span class="fc" id="L707">                        break;</span>
                    case &quot;or&quot;:
<span class="fc" id="L709">                        appendConstraint(queryFactory.or(subVisitor1</span>
                                .getConstraint(), subVisitor2.getConstraint()));
<span class="fc" id="L711">                        break;</span>
                    default:
<span class="nc" id="L713">                        throw new NotImplementedException(funcName);</span>
                }
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">            } else if (!func.getArg2().isConstant()) {</span>
<span class="nc" id="L716">                throw new NotImplementedException(</span>
                        &quot;EXPRFUNCTION2 2nd argument must be a constant: &quot;
                                + func.getArg1() + &quot;; &quot; + func.getArg2());
            } else {
                final String op;
<span class="fc" id="L721">                String value = func.getArg2().getConstant().getString();</span>
<span class="pc bpc" id="L722" title="20 of 38 branches missed.">                switch(funcName) {</span>
                    case &quot;eq&quot;:
<span class="fc" id="L724">                        op = JCR_OPERATOR_EQUAL_TO;</span>
<span class="fc" id="L725">                        break;</span>
                    case &quot;ge&quot;:
<span class="fc" id="L727">                        op = JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO;</span>
<span class="fc" id="L728">                        break;</span>
                    case &quot;le&quot;:
<span class="nc" id="L730">                        op = JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO;</span>
<span class="nc" id="L731">                        break;</span>
                    case &quot;lt&quot;:
<span class="fc" id="L733">                        op = JCR_OPERATOR_LESS_THAN;</span>
<span class="fc" id="L734">                        break;</span>
                    case &quot;gt&quot;:
<span class="nc" id="L736">                        op = JCR_OPERATOR_GREATER_THAN;</span>
<span class="nc" id="L737">                        break;</span>
                    case &quot;ne&quot;:
<span class="nc" id="L739">                        op = JCR_OPERATOR_NOT_EQUAL_TO;</span>
<span class="nc" id="L740">                        break;</span>
                    case &quot;contains&quot;:
<span class="fc" id="L742">                        op = JCR_OPERATOR_LIKE;</span>
<span class="fc" id="L743">                        value = &quot;%&quot; + value + &quot;%&quot;;</span>
<span class="fc" id="L744">                        break;</span>
                    case &quot;strstarts&quot;:
<span class="fc" id="L746">                        op = JCR_OPERATOR_LIKE;</span>
<span class="fc" id="L747">                        value = value + &quot;%&quot;;</span>
<span class="fc" id="L748">                        break;</span>
                    case &quot;strends&quot;:
<span class="fc" id="L750">                        op = JCR_OPERATOR_LIKE;</span>
<span class="fc" id="L751">                        value = &quot;%&quot; + value;</span>
<span class="fc" id="L752">                        break;</span>
                    default:
<span class="nc" id="L754">                        throw new NotImplementedException(funcName);</span>
                }

<span class="fc" id="L757">                appendConstraint(queryFactory.comparison(getPropertyValue(func</span>
                        .getArg1()), op, queryFactory.literal(getValue(value))));

            }

<span class="nc" id="L762">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L763">            throw propagate(e);</span>
<span class="fc" id="L764">        }</span>


<span class="fc" id="L767">    }</span>

    @Override
    public void visit(final ExprFunction3 func) {
<span class="nc" id="L771">        LOGGER.trace(&quot;VISIT EXPRFUNCTION3: {}&quot;, func);</span>
<span class="nc" id="L772">    }</span>

    @Override
    public void visit(final ExprFunctionN func) {
<span class="fc" id="L776">        LOGGER.trace(&quot;VISIT EXPRFUNCTIONN: {}&quot;, func);</span>
        try {
<span class="fc" id="L778">            final FunctionLabel functionSymbol = func.getFunctionSymbol();</span>
<span class="fc" id="L779">            final List&lt;Expr&gt; args = func.getArgs();</span>

<span class="fc" id="L781">            final String symbol = functionSymbol.getSymbol().toLowerCase();</span>
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">            if (symbol.equals(&quot;regex&quot;)) {</span>
<span class="fc" id="L783">                final Expr expr = args.get(0);</span>

<span class="pc bpc" id="L785" title="1 of 2 branches missed.">                if (expr.isVariable()) {</span>
<span class="fc" id="L786">                    appendConstraint(queryFactory.comparison(</span>
                            getPropertyValue(expr), JCR_OPERATOR_LIKE,
                            queryFactory.literal(getValue(args.get(1)))));
                } else {
<span class="nc" id="L790">                    throw new NotImplementedException(&quot;ExprFunctionN &quot; + symbol);</span>
                }

<span class="fc" id="L793">            } else {</span>
<span class="nc" id="L794">                throw new NotImplementedException(&quot;ExprFunctionN &quot; + symbol);</span>
            }

<span class="nc" id="L797">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L798">            throw propagate(e);</span>
<span class="fc" id="L799">        }</span>
<span class="fc" id="L800">    }</span>

    @Override
    public void visit(final ExprFunctionOp funcOp) {
<span class="nc" id="L804">        LOGGER.trace(&quot;VISIT EXPRFUNCTIONOp: {}&quot;, funcOp);</span>
<span class="nc" id="L805">    }</span>

    @Override
    public void visit(final NodeValue nv) {
<span class="nc" id="L809">        LOGGER.trace(&quot;VISIT NODEVALUE: {}&quot;, nv);</span>
<span class="nc" id="L810">    }</span>

    @Override
    public void visit(final ExprVar nv) {
<span class="nc" id="L814">        LOGGER.trace(&quot;VISIT EXPRVAR: {}&quot;, nv);</span>
<span class="nc" id="L815">    }</span>

    @Override
    public void visit(final ExprAggregator eAgg) {
<span class="nc" id="L819">        LOGGER.trace(&quot;VISIT EXPRAGGREGATOR: {}&quot;, eAgg);</span>
<span class="nc" id="L820">    }</span>

    @Override
    public void finishVisit() {
<span class="nc" id="L824">    }</span>

    private PropertyValue getPropertyValue(final Column column) {
        try {
<span class="fc" id="L828">            return queryFactory.propertyValue(column.getSelectorName(), column.getPropertyName());</span>
<span class="nc" id="L829">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L830">            throw propagate(e);</span>
        }
    }

    private PropertyValue getPropertyValue(final Expr expr) {
<span class="fc" id="L835">        return getPropertyValue(variables.get(expr.getVarName()));</span>
    }

    private Value getValue(final Expr e) throws RepositoryException {
<span class="fc" id="L839">        return getValue(e.getConstant().asString());</span>
    }

    private Value getValue(final String e) throws RepositoryException {
<span class="fc" id="L843">        return session.getValueFactory().createValue(e);</span>
    }

    private void appendConstraint(final Constraint c) throws RepositoryException {
<span class="fc bfc" id="L847" title="All 2 branches covered.">        if (constraint == null) {</span>
<span class="fc" id="L848">            constraint = c;</span>
        } else {
<span class="fc" id="L850">            constraint = queryFactory.and(constraint, c);</span>
        }
<span class="fc" id="L852">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312101107</span></div></body></html>