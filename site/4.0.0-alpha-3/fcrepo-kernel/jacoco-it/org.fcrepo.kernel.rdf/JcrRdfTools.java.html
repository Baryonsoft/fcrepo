<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JcrRdfTools.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fcrepo-kernel</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.kernel.rdf</a> &gt; <span class="el_source">JcrRdfTools.java</span></div><h1>JcrRdfTools.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2013 DuraSpace, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.fcrepo.kernel.rdf;

import static com.google.common.collect.Iterables.any;
import static com.hp.hpl.jena.graph.Triple.create;
import static com.hp.hpl.jena.rdf.model.ModelFactory.createDefaultModel;
import static java.util.Collections.emptyMap;
import static java.util.Collections.singleton;
import static javax.jcr.PropertyType.REFERENCE;
import static javax.jcr.PropertyType.STRING;
import static javax.jcr.PropertyType.UNDEFINED;
import static javax.jcr.PropertyType.URI;
import static javax.jcr.PropertyType.WEAKREFERENCE;
import static org.fcrepo.kernel.RdfLexicon.HAS_MEMBER_OF_RESULT;
import static org.fcrepo.kernel.RdfLexicon.JCR_NAMESPACE;
import static org.fcrepo.kernel.RdfLexicon.LDP_NAMESPACE;
import static org.fcrepo.kernel.RdfLexicon.REPOSITORY_NAMESPACE;
import static org.fcrepo.kernel.utils.NamespaceTools.getNamespaceRegistry;
import static org.slf4j.LoggerFactory.getLogger;

import java.util.Iterator;
import java.util.Map;

import javax.jcr.Node;
import javax.jcr.PropertyType;
import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.Value;
import javax.jcr.ValueFactory;
import javax.jcr.nodetype.NodeType;
import javax.jcr.nodetype.PropertyDefinition;

import org.fcrepo.kernel.RdfLexicon;
import org.fcrepo.kernel.rdf.impl.DefaultGraphSubjects;
import org.fcrepo.kernel.rdf.impl.FixityRdfContext;
import org.fcrepo.kernel.rdf.impl.HierarchyRdfContext;
import org.fcrepo.kernel.rdf.impl.NamespaceRdfContext;
import org.fcrepo.kernel.rdf.impl.PropertiesRdfContext;
import org.fcrepo.kernel.rdf.impl.VersionsRdfContext;
import org.fcrepo.kernel.rdf.impl.WorkspaceRdfContext;
import org.fcrepo.kernel.services.LowLevelStorageService;
import org.fcrepo.kernel.utils.FixityResult;
import org.fcrepo.kernel.utils.iterators.RdfStream;
import org.modeshape.jcr.api.NamespaceRegistry;
import org.slf4j.Logger;

import com.google.common.base.Predicate;
import com.google.common.collect.BiMap;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableList;
import com.hp.hpl.jena.datatypes.RDFDatatype;
import com.hp.hpl.jena.datatypes.xsd.XSDDateTime;
import com.hp.hpl.jena.rdf.model.Literal;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.RDFNode;
import com.hp.hpl.jena.rdf.model.Resource;

/**
 * A set of helpful tools for converting JCR properties to RDF
 *
 * @author Chris Beer
 * @date May 10, 2013
 */
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">public class JcrRdfTools {</span>

<span class="fc" id="L81">    private static final Logger LOGGER = getLogger(JcrRdfTools.class);</span>

    /**
     * A map of JCR namespaces to Fedora's RDF namespaces
     */
<span class="fc" id="L86">    public static BiMap&lt;String, String&gt; jcrNamespacesToRDFNamespaces =</span>
        ImmutableBiMap.of(JCR_NAMESPACE,
                RdfLexicon.REPOSITORY_NAMESPACE);

    /**
     * A map of Fedora's RDF namespaces to the JCR equivalent
     */
<span class="fc" id="L93">    public static BiMap&lt;String, String&gt; rdfNamespacesToJcrNamespaces =</span>
        jcrNamespacesToRDFNamespaces.inverse();

    private LowLevelStorageService llstore;

    private final GraphSubjects graphSubjects;

    private Session session;

    /**
     * Factory method to create a new JcrRdfTools utility with a graph subjects
     * converter
     *
     * @param graphSubjects
     */
    public JcrRdfTools(final GraphSubjects graphSubjects) {
<span class="nc" id="L109">        this(graphSubjects, null, null);</span>
<span class="nc" id="L110">    }</span>

    /**
     * Factory method to create a new JcrRdfTools utility with a graph subjects
     * converter
     *
     * @param graphSubjects
     * @param session
     */
    public JcrRdfTools(final GraphSubjects graphSubjects, final Session session) {
<span class="fc" id="L120">        this(graphSubjects, session, null);</span>
<span class="fc" id="L121">    }</span>

    /**
     * Contructor with even more context.
     *
     * @param graphSubjects
     * @param session
     * @param lls
     */
    public JcrRdfTools(final GraphSubjects graphSubjects,
<span class="fc" id="L131">            final Session session, final LowLevelStorageService lls) {</span>
<span class="fc" id="L132">        this.graphSubjects = graphSubjects;</span>
<span class="fc" id="L133">        this.session = session;</span>
<span class="fc" id="L134">        this.llstore = lls;</span>
<span class="fc" id="L135">    }</span>

    /**
     * Factory method to create a new JcrRdfTools instance
     *
     * @param graphSubjects
     * @return
     */
    public static JcrRdfTools withContext(final GraphSubjects graphSubjects) {
<span class="nc" id="L144">        return new JcrRdfTools(graphSubjects);</span>
    }

    /**
     * Factory method to create a new JcrRdfTools instance
     *
     * @param graphSubjects
     * @param session
     * @return
     */
    public static JcrRdfTools withContext(final GraphSubjects graphSubjects,
        final Session session) {
<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (graphSubjects == null) {</span>
<span class="fc" id="L157">            return new JcrRdfTools(new DefaultGraphSubjects(session), session);</span>
        } else {
<span class="fc" id="L159">            return new JcrRdfTools(graphSubjects, session);</span>
        }
    }

    /**
     * Factory method to create a new JcrRdfTools instance with full context.
     *
     * @param graphSubjects
     * @param session
     * @param lls
     * @return
     */
    public static JcrRdfTools withContext(final GraphSubjects graphSubjects,
            final Session session, final LowLevelStorageService lls) {
<span class="nc" id="L173">        return new JcrRdfTools(graphSubjects, session, lls);</span>
    }

    /**
     * Convert a Fedora RDF Namespace into its JCR equivalent
     *
     * @param rdfNamespaceUri a namespace from an RDF document
     * @return the JCR namespace, or the RDF namespace if no matching JCR
     *         namespace is found
     */
    public static String getJcrNamespaceForRDFNamespace(
            final String rdfNamespaceUri) {
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if (rdfNamespacesToJcrNamespaces.containsKey(rdfNamespaceUri)) {</span>
<span class="nc" id="L186">            return rdfNamespacesToJcrNamespaces.get(rdfNamespaceUri);</span>
        } else {
<span class="fc" id="L188">            return rdfNamespaceUri;</span>
        }
    }

    /**
     * Convert a JCR namespace into an RDF namespace fit for downstream
     * consumption.
     *
     * @param jcrNamespaceUri a namespace from the JCR NamespaceRegistry
     * @return an RDF namespace for downstream consumption.
     */
    public static String getRDFNamespaceForJcrNamespace(
            final String jcrNamespaceUri) {
<span class="fc bfc" id="L201" title="All 2 branches covered.">        if (jcrNamespacesToRDFNamespaces.containsKey(jcrNamespaceUri)) {</span>
<span class="fc" id="L202">            return jcrNamespacesToRDFNamespaces.get(jcrNamespaceUri);</span>
        } else {
<span class="fc" id="L204">            return jcrNamespaceUri;</span>
        }
    }

    /**
     * Get a model in which to collect statements of RDF extraction problems
     *
     * @return
     */
    public static Model getProblemsModel() {
<span class="nc" id="L214">        return createDefaultModel();</span>
    }

    /**
     * Using the same graph subjects, create a new JcrRdfTools with the given
     * session
     *
     * @param session
     * @return
     */
    public JcrRdfTools withSession(final Session session) {
<span class="nc" id="L225">        return new JcrRdfTools(graphSubjects, session);</span>
    }

    /**
     * Get an {@link RdfStream} for the given JCR NodeIterator
     *
     * @param nodeIterator
     * @param iteratorSubject
     * @return
     * @throws RepositoryException
     */
    public RdfStream getJcrPropertiesModel(final Iterator&lt;Node&gt; nodeIterator,
            final Resource iteratorSubject) throws RepositoryException {

<span class="nc" id="L239">        final RdfStream results = new RdfStream();</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        while (nodeIterator.hasNext()) {</span>
<span class="nc" id="L241">            final Node node = nodeIterator.next();</span>
<span class="nc" id="L242">            results.concat(new PropertiesRdfContext(node, graphSubjects,</span>
                    llstore));
<span class="nc bnc" id="L244" title="All 2 branches missed.">            if (iteratorSubject != null) {</span>
<span class="nc" id="L245">                results.concat(singleton(create(iteratorSubject.asNode(),</span>
                        HAS_MEMBER_OF_RESULT.asNode(), graphSubjects
                                .getGraphSubject(node).asNode())));
            }
<span class="nc" id="L249">        }</span>
<span class="nc" id="L250">        return results;</span>
    }

    /**
     * Get an {@link RdfStream} for a node that includes all its own JCR properties,
     * as well as the properties of its immediate children. TODO add triples for
     * root node, ala addRepositoryMetricsToModel()
     *
     * @param node
     * @return
     * @throws RepositoryException
     */
    public RdfStream getJcrTriples(final Node node) throws RepositoryException {
<span class="fc" id="L263">        return new PropertiesRdfContext(node, graphSubjects, llstore);</span>
    }

    /**
     * Get an {@link RdfStream} for the JCR version history information for a node
     *
     * @param node
     * @return
     * @throws RepositoryException
     */
    public RdfStream getVersionTriples(final Node node)
        throws RepositoryException {
<span class="fc" id="L275">        return new VersionsRdfContext(node, graphSubjects, llstore);</span>
    }

    /**
     * Serialize the JCR fixity information in an {@link RdfStream}
     *
     * @param node
     * @param blobs
     * @return
     * @throws RepositoryException
     */
    public RdfStream getJcrTriples(final Node node,
        final Iterable&lt;FixityResult&gt; blobs) throws RepositoryException {
<span class="nc" id="L288">        return new FixityRdfContext(node, graphSubjects, llstore, blobs);</span>
    }

    /**
     * Get an {@link RdfStream} of the registered JCR namespaces
     *
     * @return
     * @throws RepositoryException
     */
    public RdfStream getNamespaceTriples() throws RepositoryException {
<span class="fc" id="L298">        return new NamespaceRdfContext(session);</span>
    }

    /**
     * Get an {@link RdfStream} of the registered JCR workspaces
     *
     * @return
     * @throws RepositoryException
     */
    public RdfStream getWorkspaceTriples(final GraphSubjects subjects) throws RepositoryException {
<span class="nc" id="L308">        return new WorkspaceRdfContext(session, subjects);</span>
    }

    /**
     * Add the properties of a Node's parent and immediate children (as well as
     * the jcr:content of children) to the given {@link RdfStream}
     *
     * @param node
     * @throws RepositoryException
     */
    public RdfStream getTreeTriples(final Node node) throws RepositoryException {
<span class="fc" id="L319">        return new HierarchyRdfContext(node, graphSubjects, llstore);</span>
    }

    /**
     * Decides whether the RDF representation of this {@link Node} will receive LDP Container status.
     *
     * @param node
     * @return
     * @throws RepositoryException
     */
    public static boolean isContainer(final Node node) throws RepositoryException {
<span class="pc bpc" id="L330" title="3 of 4 branches missed.">        return HAS_CHILD_NODE_DEFINITIONS.apply(node.getPrimaryNodeType())</span>
                || any(ImmutableList.copyOf(node.getMixinNodeTypes()),
                        HAS_CHILD_NODE_DEFINITIONS);
    }

<span class="fc" id="L335">    static Predicate&lt;NodeType&gt; HAS_CHILD_NODE_DEFINITIONS =</span>
<span class="fc" id="L336">        new Predicate&lt;NodeType&gt;() {</span>

            @Override
            public boolean apply(final NodeType input) {
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">                return input.getChildNodeDefinitions().length &gt; 0;</span>
            }
        };

    /**
     * Determine if a predicate is an internal property of a node (and should
     * not be modified from external sources)
     *
     * @param subjectNode
     * @param predicate
     * @return
     */
    public boolean isInternalProperty(final Node subjectNode,
            final Resource predicate) {
<span class="pc bpc" id="L354" title="10 of 12 branches missed.">        switch (predicate.getNameSpace()) {</span>
            case REPOSITORY_NAMESPACE:
            case JCR_NAMESPACE:
            case LDP_NAMESPACE:
<span class="nc" id="L358">                return true;</span>
            default:
<span class="fc" id="L360">                return false;</span>
        }
    }

    /**
     * Create a JCR value from an RDFNode, either by using the given JCR
     * PropertyType or by looking at the RDFNode Datatype
     *
     * @param data an RDF Node (possibly with a DataType)
     * @param type a JCR PropertyType value
     * @return a JCR Value
     * @throws javax.jcr.RepositoryException
     */
    public Value createValue(final Node node, final RDFNode data, final int type)
        throws RepositoryException {
<span class="fc" id="L375">        final ValueFactory valueFactory = node.getSession().getValueFactory();</span>
<span class="fc" id="L376">        return createValue(valueFactory, data, type);</span>

    }

    /**
     * Create a JCR value (with an undefined type) from a RDFNode
     * @param data
     * @return
     * @throws RepositoryException
     */
    public Value createValue(final RDFNode data) throws RepositoryException {
<span class="nc" id="L387">        return createValue(data, UNDEFINED);</span>
    }

    /**
     * Create a JCR value from an RDFNode with the given JCR type
     * @param data
     * @param type
     * @return
     * @throws RepositoryException
     */
    public Value createValue(final RDFNode data, final int type) throws RepositoryException {
<span class="nc" id="L398">        return createValue(session.getValueFactory(), data, type);</span>
    }

    /**
     * Create a JCR value from an RDF node with the given JCR type
     * @param valueFactory
     * @param data
     * @param type
     * @return
     * @throws RepositoryException
     */
    public Value createValue(final ValueFactory valueFactory, final RDFNode data, final int type)
        throws RepositoryException {
<span class="pc bpc" id="L411" title="2 of 4 branches missed.">        assert (valueFactory != null);</span>

<span class="pc bpc" id="L413" title="1 of 6 branches missed.">        if (data.isURIResource()</span>
                &amp;&amp; (type == REFERENCE || type == WEAKREFERENCE)) {
            // reference to another node (by path)
<span class="fc" id="L416">            final Node nodeFromGraphSubject =</span>
                graphSubjects.getNodeFromGraphSubject(data.asResource());
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">            return valueFactory.createValue(nodeFromGraphSubject,</span>
                    type == WEAKREFERENCE);
<span class="pc bpc" id="L420" title="1 of 4 branches missed.">        } else if (data.isURIResource() || type == URI) {</span>
            // some random opaque URI
<span class="fc" id="L422">            return valueFactory.createValue(data.toString(), PropertyType.URI);</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">        } else if (data.isResource()) {</span>
            // a non-URI resource (e.g. a blank node)
<span class="nc" id="L425">            return valueFactory.createValue(data.toString(), UNDEFINED);</span>
<span class="pc bpc" id="L426" title="1 of 4 branches missed.">        } else if (data.isLiteral() &amp;&amp; type == UNDEFINED) {</span>
            // the JCR schema doesn't know what this should be; so introspect
            // the RDF and try to figure it out
<span class="fc" id="L429">            final Literal literal = data.asLiteral();</span>
<span class="fc" id="L430">            final RDFDatatype dataType = literal.getDatatype();</span>
<span class="fc" id="L431">            final Object rdfValue = literal.getValue();</span>

<span class="pc bpc" id="L433" title="1 of 2 branches missed.">            if (rdfValue instanceof Boolean) {</span>
<span class="nc" id="L434">                return valueFactory.createValue((Boolean) rdfValue);</span>
<span class="pc bpc" id="L435" title="2 of 6 branches missed.">            } else if (rdfValue instanceof Byte</span>
                    || (dataType != null &amp;&amp; dataType.getJavaClass() == Byte.class)) {
<span class="nc" id="L437">                return valueFactory.createValue(literal.getByte());</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">            } else if (rdfValue instanceof Double) {</span>
<span class="nc" id="L439">                return valueFactory.createValue((Double) rdfValue);</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">            } else if (rdfValue instanceof Float) {</span>
<span class="nc" id="L441">                return valueFactory.createValue((Float) rdfValue);</span>
<span class="pc bpc" id="L442" title="1 of 6 branches missed.">            } else if (rdfValue instanceof Long</span>
                    || (dataType != null &amp;&amp; dataType.getJavaClass() == Long.class)) {
<span class="fc" id="L444">                return valueFactory.createValue(literal.getLong());</span>
<span class="pc bpc" id="L445" title="2 of 6 branches missed.">            } else if (rdfValue instanceof Short</span>
                    || (dataType != null &amp;&amp; dataType.getJavaClass() == Short.class)) {
<span class="nc" id="L447">                return valueFactory.createValue(literal.getShort());</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">            } else if (rdfValue instanceof Integer) {</span>
<span class="nc" id="L449">                return valueFactory.createValue((Integer) rdfValue);</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">            } else if (rdfValue instanceof XSDDateTime) {</span>
<span class="nc" id="L451">                return valueFactory.createValue(((XSDDateTime) rdfValue)</span>
                        .asCalendar());
            } else {
<span class="fc" id="L454">                return valueFactory.createValue(literal.getString(), STRING);</span>
            }

        } else {
<span class="fc" id="L458">            LOGGER.debug(&quot;Using default JCR value creation for RDF literal: {}&quot;,</span>
                    data);
<span class="fc" id="L460">            return valueFactory.createValue(data.asLiteral().getString(), type);</span>
        }
    }

    /**
     * Given an RDF predicate value (namespace URI + local name), figure out
     * what JCR property to use
     *
     * @param node the JCR node we want a property for
     * @param predicate the predicate to map to a property name
     * @return
     * @throws RepositoryException
     */
    public String getPropertyNameFromPredicate(final Node node,
        final com.hp.hpl.jena.rdf.model.Property predicate)
        throws RepositoryException {
<span class="fc" id="L476">        final Map&lt;String, String&gt; s = emptyMap();</span>
<span class="fc" id="L477">        return getPropertyNameFromPredicate(node, predicate, s);</span>

    }

    /**
     * Given an RDF predicate value (namespace URI + local name), figure out
     * what JCR property to use
     *
     * @param node the JCR node we want a property for
     * @param predicate the predicate to map to a property name
     * @param namespaceMapping prefix =&gt; uri namespace mapping
     * @return the JCR property name
     * @throws RepositoryException
     */

    public String getPropertyNameFromPredicate(final Node node, final com.hp.hpl.jena.rdf.model.Property predicate,
                                               final Map&lt;String, String&gt; namespaceMapping) throws RepositoryException {

<span class="fc" id="L495">        final NamespaceRegistry namespaceRegistry =</span>
            getNamespaceRegistry.apply(node);

<span class="fc" id="L498">        return getPropertyNameFromPredicate(namespaceRegistry, predicate, namespaceMapping);</span>
    }

    /**
     * Get the property name for an RDF predicate
     * @param predicate
     * @param namespaceMapping
     * @return
     * @throws RepositoryException
     */
    public String getPropertyNameFromPredicate(final com.hp.hpl.jena.rdf.model.Property predicate,
                                               final Map&lt;String, String&gt; namespaceMapping) throws RepositoryException {

<span class="nc" id="L511">        final NamespaceRegistry namespaceRegistry = (org.modeshape.jcr.api.NamespaceRegistry) session.getWorkspace()</span>
                .getNamespaceRegistry();

<span class="nc" id="L514">        return getPropertyNameFromPredicate(namespaceRegistry, predicate, namespaceMapping);</span>
    }

    /**
     * Get a property name for an RDF predicate
     * @param predicate
     * @return
     * @throws RepositoryException
     */
    public String getPropertyNameFromPredicate(final com.hp.hpl.jena.rdf.model.Property predicate)
        throws RepositoryException {


<span class="nc" id="L527">        final Map&lt;String, String&gt; emptyNamespaceMapping = emptyMap();</span>
<span class="nc" id="L528">        return getPropertyNameFromPredicate(predicate, emptyNamespaceMapping);</span>
    }


    /**
     * Get the JCR property name for an RDF predicate
     * @param namespaceRegistry
     * @param predicate
     * @param namespaceMapping
     * @return
     * @throws RepositoryException
     */
    public String getPropertyNameFromPredicate(final NamespaceRegistry namespaceRegistry,
                                               final com.hp.hpl.jena.rdf.model.Property predicate,
                                               final Map&lt;String, String&gt; namespaceMapping) throws RepositoryException {

        final String prefix;

<span class="fc" id="L546">        final String namespace =</span>
            getJcrNamespaceForRDFNamespace(predicate.getNameSpace());

<span class="pc bpc" id="L549" title="2 of 4 branches missed.">        assert (namespaceRegistry != null);</span>

<span class="fc bfc" id="L551" title="All 2 branches covered.">        if (namespaceRegistry.isRegisteredUri(namespace)) {</span>
<span class="fc" id="L552">            LOGGER.debug(&quot;Discovered namespace: {} in namespace registry.&quot;,namespace);</span>
<span class="fc" id="L553">            prefix = namespaceRegistry.getPrefix(namespace);</span>
        } else {
<span class="fc" id="L555">            LOGGER.debug(&quot;Didn't discover namespace: {} in namespace registry.&quot;,namespace);</span>
<span class="fc" id="L556">            final ImmutableBiMap&lt;String, String&gt; nsMap =</span>
                ImmutableBiMap.copyOf(namespaceMapping);
<span class="fc bfc" id="L558" title="All 2 branches covered.">            if (nsMap.containsValue(namespace)) {</span>
<span class="fc" id="L559">                LOGGER.debug(&quot;Discovered namespace: {} in namespace map: {}.&quot;, namespace,</span>
                        nsMap);
<span class="fc" id="L561">                prefix = nsMap.inverse().get(namespace);</span>
<span class="fc" id="L562">                namespaceRegistry.registerNamespace(prefix, namespace);</span>
            } else {
<span class="fc" id="L564">                prefix = namespaceRegistry.registerNamespace(namespace);</span>
            }
        }

<span class="fc" id="L568">        final String localName = predicate.getLocalName();</span>

<span class="fc" id="L570">        final String propertyName = prefix + &quot;:&quot; + localName;</span>

<span class="fc" id="L572">        LOGGER.debug(&quot;Took RDF predicate {} and translated it to JCR property {}&quot;, predicate, propertyName);</span>

<span class="fc" id="L574">        return propertyName;</span>

    }

    /**
     * Set the Low-level storage server implementation
     */
    public void setLlstore(final LowLevelStorageService lowLevelStorageService) {
<span class="nc" id="L582">        llstore = lowLevelStorageService;</span>
<span class="nc" id="L583">    }</span>

    /**
     * Given a node type and a property name, figure out an appropriate jcr value type
     * @param nodeType
     * @param propertyName
     * @return
     * @throws RepositoryException
     */
    public int getPropertyType(final String nodeType, final String propertyName) throws RepositoryException {
<span class="nc" id="L593">        return getPropertyType(session.getWorkspace().getNodeTypeManager().getNodeType(nodeType), propertyName);</span>

    }

    /**
     * Given a node type and a property name, figure out an appropraite jcr value type
     * @param nodeType
     * @param propertyName
     * @return
     * @throws RepositoryException
     */
    public int getPropertyType(final NodeType nodeType, final String propertyName) throws RepositoryException {
<span class="nc" id="L605">        final PropertyDefinition[] propertyDefinitions = nodeType.getPropertyDefinitions();</span>
<span class="nc" id="L606">        int type = UNDEFINED;</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">        for (final PropertyDefinition propertyDefinition : propertyDefinitions) {</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">            if (propertyDefinition.getName().equals(propertyName)) {</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">                if (type != UNDEFINED) {</span>
<span class="nc" id="L610">                    return UNDEFINED;</span>
                }

<span class="nc" id="L613">                type = propertyDefinition.getRequiredType();</span>
            }
        }

<span class="nc" id="L617">        return type;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312101107</span></div></body></html>