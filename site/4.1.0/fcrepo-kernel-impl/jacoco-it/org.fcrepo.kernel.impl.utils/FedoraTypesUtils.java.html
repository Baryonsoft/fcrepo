<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FedoraTypesUtils.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fedora Repository Kernel Implementation</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.kernel.impl.utils</a> &gt; <span class="el_source">FedoraTypesUtils.java</span></div><h1>FedoraTypesUtils.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2015 DuraSpace, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.fcrepo.kernel.impl.utils;

import com.google.common.base.Predicate;
import org.fcrepo.kernel.FedoraJcrTypes;
import org.fcrepo.kernel.models.FedoraResource;
import org.fcrepo.kernel.exception.RepositoryRuntimeException;
import org.fcrepo.kernel.services.functions.AnyTypesPredicate;
import org.fcrepo.kernel.services.functions.JcrPropertyFunctions;
import org.slf4j.Logger;

import javax.jcr.Node;
import javax.jcr.Property;
import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.nodetype.NodeType;
import javax.jcr.nodetype.PropertyDefinition;

import static com.google.common.base.Preconditions.checkNotNull;
import static javax.jcr.PropertyType.REFERENCE;
import static javax.jcr.PropertyType.UNDEFINED;
import static javax.jcr.PropertyType.WEAKREFERENCE;
import static org.slf4j.LoggerFactory.getLogger;

/**
 * Convenience class with static methods for manipulating Fedora types in the
 * JCR.
 *
 * @author ajs6f
 * @since Feb 14, 2013
 */
<span class="nc" id="L46">public abstract class FedoraTypesUtils implements FedoraJcrTypes {</span>

    public static final String REFERENCE_PROPERTY_SUFFIX = &quot;_ref&quot;;

<span class="fc" id="L50">    private static final Logger LOGGER = getLogger(FedoraTypesUtils.class);</span>

    /**
     * Predicate for determining whether this {@link Node} is a {@link org.fcrepo.kernel.models.Container}.
     */
<span class="fc" id="L55">    public static Predicate&lt;Node&gt; isContainer =</span>
            new AnyTypesPredicate(FEDORA_CONTAINER);

    /**
     * Predicate for determining whether this {@link Node} is a {@link org.fcrepo.kernel.models.NonRdfSourceDescription}
     */
<span class="fc" id="L61">    public static Predicate&lt;Node&gt; isNonRdfSourceDescription =</span>
            new AnyTypesPredicate(FEDORA_NON_RDF_SOURCE_DESCRIPTION);


    /**
     * Predicate for determining whether this {@link Node} is a Fedora
     * binary.
     */
<span class="fc" id="L69">    public static Predicate&lt;Node&gt; isFedoraBinary =</span>
            new AnyTypesPredicate(FEDORA_BINARY);

    /**
     * Predicate for determining whether this {@link FedoraResource} has a frozen node
     */
<span class="fc" id="L75">    public static Predicate&lt;FedoraResource&gt; isFrozenNode =</span>
<span class="fc" id="L76">            new Predicate&lt;FedoraResource&gt;() {</span>

                @Override
                public boolean apply(final FedoraResource f) {
<span class="pc bpc" id="L80" title="2 of 4 branches missed.">                    return f.hasType(FROZEN_NODE) || f.getPath().contains(JCR_FROZEN_NODE);</span>
                }
     };

    /**
     * Predicate for determining whether this {@link Node} is a Fedora
     * binary.
     */
<span class="fc" id="L88">    public static Predicate&lt;Node&gt; isBlankNode =</span>
            new AnyTypesPredicate(FEDORA_BLANKNODE);

    /**
     * Check if a property is a reference property.
     */
<span class="fc" id="L94">    public static Predicate&lt;Property&gt; isInternalReferenceProperty =</span>
<span class="fc" id="L95">        new Predicate&lt;Property&gt;() {</span>

            @Override
            public boolean apply(final Property p) {
                try {
<span class="fc bfc" id="L100" title="All 4 branches covered.">                    return (p.getType() == REFERENCE || p.getType() == WEAKREFERENCE)</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">                        &amp;&amp; p.getName().endsWith(REFERENCE_PROPERTY_SUFFIX);</span>
<span class="nc" id="L102">                } catch (final RepositoryException e) {</span>
<span class="nc" id="L103">                    throw new RepositoryRuntimeException(e);</span>
                }
            }
        };

    /**
    * Check whether a property is an internal property that should be suppressed
    * from external output.
    */
<span class="fc" id="L112">    public static Predicate&lt;Property&gt; isInternalProperty =</span>
<span class="fc" id="L113">        new Predicate&lt;Property&gt;() {</span>

            @Override
            public boolean apply(final Property p) {
<span class="fc bfc" id="L117" title="All 2 branches covered.">                return JcrPropertyFunctions.isBinaryContentProperty.apply(p)</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">                        || isProtectedAndShouldBeHidden.apply(p);</span>
            }
        };

    /**
     * Check whether a property is protected (ie, cannot be modified directly) but
     * is not one we've explicitly chosen to include.
     */
<span class="fc" id="L126">    public static Predicate&lt;Property&gt; isProtectedAndShouldBeHidden =</span>
<span class="fc" id="L127">        new Predicate&lt;Property&gt;() {</span>

            @Override
            public boolean apply(final Property p) {
                try {
<span class="fc bfc" id="L132" title="All 2 branches covered.">                    if (!p.getDefinition().isProtected()) {</span>
<span class="fc" id="L133">                        return false;</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">                    } else if (p.getParent().isNodeType(FROZEN_NODE)) {</span>
                        // everything on a frozen node is protected
                        // but we wish to display it anyway and there's
                        // another mechanism in place to make clear that
                        // things cannot be edited.
<span class="nc" id="L139">                        return false;</span>
                    } else {
<span class="fc" id="L141">                        final String name = p.getName();</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">                        for (String exposedName : EXPOSED_PROTECTED_JCR_TYPES) {</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">                            if (name.equals(exposedName)) {</span>
<span class="fc" id="L144">                                return false;</span>
                            }
                        }
<span class="nc" id="L147">                        return true;</span>
                    }
<span class="nc" id="L149">                } catch (final RepositoryException e) {</span>
<span class="nc" id="L150">                    throw new RepositoryRuntimeException(e);</span>
                }
            }
        };

    /**
     * Check if a node is &quot;internal&quot; and should not be exposed e.g. via the REST
     * API
     */
<span class="fc" id="L159">    public static Predicate&lt;Node&gt; isInternalNode = new Predicate&lt;Node&gt;() {</span>

        @Override
        public boolean apply(final Node n) {
<span class="fc" id="L163">            checkNotNull(n, &quot;null is neither internal nor not internal!&quot;);</span>
            try {
<span class="fc" id="L165">                return n.isNodeType(&quot;mode:system&quot;);</span>
<span class="nc" id="L166">            } catch (final RepositoryException e) {</span>
<span class="nc" id="L167">                throw new RepositoryRuntimeException(e);</span>
            }
        }
    };

    /**
     * Get the JCR property type ID for a given property name. If unsure, mark
     * it as UNDEFINED.
     *
     * @param node the JCR node to add the property on
     * @param propertyName the property name
     * @return a PropertyType value
     * @throws RepositoryException
     */
    public static int getPropertyType(final Node node, final String propertyName)
            throws RepositoryException {
<span class="fc" id="L183">        LOGGER.debug(&quot;Getting type of property: {} from node: {}&quot;,</span>
                propertyName, node);
<span class="fc" id="L185">        final PropertyDefinition def =</span>
<span class="fc" id="L186">                getDefinitionForPropertyName(node, propertyName);</span>

<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (def == null) {</span>
<span class="fc" id="L189">            return UNDEFINED;</span>
        }

<span class="nc" id="L192">        return def.getRequiredType();</span>
    }

    /**
     * Determine if a given JCR property name is single- or multi- valued.
     * If unsure, choose the least restrictive
     * option (multivalued)
     *
     * @param node the JCR node to check
     * @param propertyName the property name
     *   (which may or may not already exist)
     * @return true if the property is (or could be) multivalued
     * @throws RepositoryException
     */
    public static boolean isMultivaluedProperty(final Node node,
                                                final String propertyName)
            throws RepositoryException {
<span class="fc" id="L209">        final PropertyDefinition def =</span>
<span class="fc" id="L210">                getDefinitionForPropertyName(node, propertyName);</span>

<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        if (def == null) {</span>
<span class="fc" id="L213">            return true;</span>
        }

<span class="nc" id="L216">        return def.isMultiple();</span>
    }

    /**
     * Get the property definition information (containing type and multi-value
     * information)
     *
     * @param node the node to use for inferring the property definition
     * @param propertyName the property name to retrieve a definition for
     * @return a JCR PropertyDefinition, if available, or null
     * @throws javax.jcr.RepositoryException
     */
    public static PropertyDefinition getDefinitionForPropertyName(final Node node,
                                                                  final String propertyName)
            throws RepositoryException {

<span class="fc" id="L232">        final NodeType primaryNodeType = node.getPrimaryNodeType();</span>
<span class="fc" id="L233">        final PropertyDefinition[] propertyDefinitions = primaryNodeType.getPropertyDefinitions();</span>
<span class="fc" id="L234">        LOGGER.debug(&quot;Looking for property name: {}&quot;, propertyName);</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">        for (final PropertyDefinition p : propertyDefinitions) {</span>
<span class="fc" id="L236">            LOGGER.debug(&quot;Checking property: {}&quot;, p.getName());</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">            if (p.getName().equals(propertyName)) {</span>
<span class="nc" id="L238">                return p;</span>
            }
        }

<span class="fc bfc" id="L242" title="All 2 branches covered.">        for (final NodeType nodeType : node.getMixinNodeTypes()) {</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">            for (final PropertyDefinition p : nodeType.getPropertyDefinitions()) {</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">                if (p.getName().equals(propertyName)) {</span>
<span class="nc" id="L245">                    return p;</span>
                }
            }
        }
<span class="fc" id="L249">        return null;</span>
    }

    /**
     * When we add certain URI properties, we also want to leave a reference node
     * @param propertyName
     * @return property name as a reference
     */
    public static String getReferencePropertyName(final String propertyName) {
<span class="fc" id="L258">        return propertyName + REFERENCE_PROPERTY_SUFFIX;</span>
    }

    /**
     * Given an internal reference node property, get the original name
     * @param refPropertyName
     * @return original property name of the reference property
     */
    public static String getReferencePropertyOriginalName(final String refPropertyName) {
<span class="fc" id="L267">        final int i = refPropertyName.lastIndexOf(REFERENCE_PROPERTY_SUFFIX);</span>

<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if (i &lt; 0) {</span>
<span class="nc" id="L270">            return refPropertyName;</span>
        }
<span class="fc" id="L272">        return refPropertyName.substring(0, i);</span>
    }

    /**
     * Check if a property definition is a reference property
     * @param node
     * @param propertyName
     * @return
     * @throws RepositoryException
     */
    public static boolean isReferenceProperty(final Node node, final String propertyName) throws RepositoryException {
<span class="fc" id="L283">        final PropertyDefinition propertyDefinition = getDefinitionForPropertyName(node, propertyName);</span>

<span class="pc bpc" id="L285" title="1 of 2 branches missed.">        return propertyDefinition != null &amp;&amp;</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">                (propertyDefinition.getRequiredType() == REFERENCE</span>
<span class="pc bnc" id="L287" title="All 2 branches missed.">                        || propertyDefinition.getRequiredType() == WEAKREFERENCE);</span>
    }


    /**
     * Get the closest ancestor that current exists
     *
     * @param session
     * @param path
     * @return
     * @throws RepositoryException
     */
    public static Node getClosestExistingAncestor(final Session session,
                                                  final String path) throws RepositoryException {
<span class="fc" id="L301">        final String[] pathSegments = path.replaceAll(&quot;^/+&quot;, &quot;&quot;).replaceAll(&quot;/+$&quot;, &quot;&quot;).split(&quot;/&quot;);</span>

<span class="fc" id="L303">        final StringBuilder existingAncestorPath = new StringBuilder(path.length());</span>
<span class="fc" id="L304">        existingAncestorPath.append(&quot;/&quot;);</span>

<span class="fc" id="L306">        final int len = pathSegments.length;</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">        for (int i = 0; i != len; ++i) {</span>
<span class="fc" id="L308">            final String pathSegment = pathSegments[i];</span>

<span class="fc bfc" id="L310" title="All 2 branches covered.">            if (session.nodeExists(existingAncestorPath.toString() + pathSegment)) {</span>
                // Add to existingAncestorPath  ...
<span class="fc" id="L312">                existingAncestorPath.append(pathSegment);</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">                if (i != (len - 1)) {</span>
<span class="fc" id="L314">                existingAncestorPath.append(&quot;/&quot;);</span>
                }
            } else {
<span class="fc bfc" id="L317" title="All 2 branches covered.">                if (i != 0) {</span>
<span class="fc" id="L318">                    existingAncestorPath.deleteCharAt(existingAncestorPath.length() - 1);</span>
                }
                break;
            }

        }

<span class="fc" id="L325">        return session.getNode(existingAncestorPath.toString());</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>