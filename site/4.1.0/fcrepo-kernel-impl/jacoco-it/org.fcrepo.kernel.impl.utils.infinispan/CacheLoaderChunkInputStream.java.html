<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CacheLoaderChunkInputStream.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fedora Repository Kernel Implementation</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.kernel.impl.utils.infinispan</a> &gt; <span class="el_source">CacheLoaderChunkInputStream.java</span></div><h1>CacheLoaderChunkInputStream.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2015 DuraSpace, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.fcrepo.kernel.impl.utils.infinispan;

import org.infinispan.persistence.spi.CacheLoader;
import org.modeshape.common.logging.Logger;

import java.io.IOException;
import java.io.InputStream;

/**
 * @author cabeer
 */
public class CacheLoaderChunkInputStream extends InputStream {

<span class="nc" id="L29">    private static final Logger LOGGER = Logger.getLogger(CacheLoaderChunkInputStream.class);</span>

    private final CacheLoader&lt;String, byte[]&gt; blobCache;
    private final String key;
    private final int chunkSize;
    private final long totalSize;
    private final int chunksCount;

    protected int indexInBuffer;
    protected byte[] buffer;
    private int chunkNumber;

    /**
     * Appease checkstyles..
     * @param blobCache
     * @param key
     * @param chunkSize
     * @param totalSize
     */
    public CacheLoaderChunkInputStream( final CacheLoader&lt;String, byte[]&gt; blobCache,
                             final String key,
                             final int chunkSize,
<span class="nc" id="L51">                             final long totalSize ) {</span>
<span class="nc" id="L52">        this.blobCache = blobCache;</span>
<span class="nc" id="L53">        this.key = key;</span>
<span class="nc" id="L54">        this.chunkSize = chunkSize;</span>
<span class="nc" id="L55">        this.totalSize = totalSize;</span>
<span class="nc" id="L56">        this.chunkNumber = 0;</span>
<span class="nc" id="L57">        this.indexInBuffer = 0;</span>
<span class="nc" id="L58">        final int remainderSize = (int) (totalSize % chunkSize);</span>
<span class="nc" id="L59">        final int numberOfChunks = (int) totalSize / chunkSize;</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">        this.chunksCount = remainderSize &gt; 0 ? numberOfChunks + 1 : numberOfChunks;</span>
<span class="nc" id="L61">    }</span>

    @Override
    public int read() throws IOException {
<span class="nc bnc" id="L65" title="All 2 branches missed.">        if (indexInBuffer == -1) {</span>
<span class="nc" id="L66">            return -1;</span>
        }
<span class="nc bnc" id="L68" title="All 2 branches missed.">        if (buffer == null) {</span>
<span class="nc" id="L69">            fillBufferWithFirstChunk();</span>
<span class="nc" id="L70">            return read();</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">        } else if (indexInBuffer &gt;= buffer.length) {</span>
<span class="nc" id="L72">            fillBufferWithNextChunk();</span>
<span class="nc" id="L73">            return read();</span>
        }
<span class="nc" id="L75">        return buffer[indexInBuffer++] &amp; 0xff;</span>
    }

    @Override
    public int read( final byte[] b,
                     final int off,
                     final int len ) throws IOException {
<span class="nc bnc" id="L82" title="All 2 branches missed.">        if (indexInBuffer == -1) {</span>
<span class="nc" id="L83">            return -1;</span>
        }
<span class="nc bnc" id="L85" title="All 2 branches missed.">        if (buffer == null) {</span>
<span class="nc" id="L86">            fillBufferWithFirstChunk();</span>
<span class="nc" id="L87">            return read(b, off, len);</span>
        }
<span class="nc bnc" id="L89" title="All 2 branches missed.">        if (indexInBuffer &gt;= buffer.length) {</span>
<span class="nc" id="L90">            return -1;</span>
        }
        final int newlen;
<span class="nc bnc" id="L93" title="All 2 branches missed.">        if (indexInBuffer + len &gt; buffer.length) {</span>
<span class="nc" id="L94">            newlen = buffer.length - indexInBuffer;</span>
        } else {
<span class="nc" id="L96">            newlen = len;</span>
        }
<span class="nc" id="L98">        System.arraycopy(buffer, indexInBuffer, b, off, newlen);</span>
<span class="nc" id="L99">        indexInBuffer += newlen;</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (indexInBuffer &gt;= buffer.length) {</span>
<span class="nc" id="L101">            fillBufferWithNextChunk();</span>
        }
<span class="nc" id="L103">        return newlen;</span>
    }

    @Override
    public int available() {
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (buffer == null) {</span>
<span class="nc" id="L109">            fillBufferWithFirstChunk();</span>
        }
<span class="nc" id="L111">        return buffer.length - indexInBuffer;</span>
    }

    @Override
    public final long skip( final long n ) {
<span class="nc bnc" id="L116" title="All 6 branches missed.">        if (n &lt;= 0 || indexInBuffer == -1 || totalSize == 0) {</span>
<span class="nc" id="L117">            return 0;</span>
        }
<span class="nc" id="L119">        return directSkip(n);</span>
    }

    @Override
    public void close() {
<span class="nc" id="L124">        endOfStream();</span>
<span class="nc" id="L125">    }</span>

    private long directSkip( final long n ) {
<span class="nc bnc" id="L128" title="All 2 branches missed.">        final long availableInBuffer = buffer != null ? (buffer.length - indexInBuffer) : chunkSize;</span>

<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (n &lt; availableInBuffer) {</span>
            //we can skip &quot;n&quot; without requiring any additional chunks
<span class="nc bnc" id="L132" title="All 2 branches missed.">            if (buffer == null) {</span>
                //we haven't been initialized yet, so load the first chunk
<span class="nc" id="L134">                fillBufferWithFirstChunk();</span>
            }
<span class="nc" id="L136">            indexInBuffer += n;</span>
<span class="nc" id="L137">            return n;</span>
        }

        //we need to skip past the current chunk, so find the chunk which needs to be loaded
<span class="nc" id="L141">        final long lastChunkSize = totalSize - (chunksCount - 1) * chunkSize;</span>
<span class="nc" id="L142">        final int chunksAvailableToSkip = chunksCount - chunkNumber - 1;</span>
<span class="nc" id="L143">        final long bytesAvailableToSkip = (chunksAvailableToSkip - 1) * chunkSize + lastChunkSize;</span>

<span class="nc" id="L145">        final long stillRequiredToSkip = n - availableInBuffer;</span>
<span class="nc" id="L146">        final int chunksToSkipOver = (int) (stillRequiredToSkip / chunkSize);</span>
<span class="nc" id="L147">        final int leftToReadAfterSkip = (int) (stillRequiredToSkip % chunkSize);</span>
<span class="nc" id="L148">        chunkNumber = chunkNumber + chunksToSkipOver + 1;   //chunk# is 0 based</span>

<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (chunkNumber &gt;= chunksCount) {</span>
            //we would need to skip more chunks than we have
<span class="nc" id="L152">            endOfStream();</span>
<span class="nc" id="L153">            return availableInBuffer + bytesAvailableToSkip;</span>
        }
        //move directly to the required chunk
<span class="nc" id="L156">        fillBuffer(chunkNumber);</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (buffer.length &gt; leftToReadAfterSkip) {</span>
            //move the pointer in this chunk
<span class="nc" id="L159">            indexInBuffer = leftToReadAfterSkip;</span>
<span class="nc" id="L160">            return n;</span>
        }
        //we jumped to a valid chunk, but it doesn't have enough data
<span class="nc" id="L163">        endOfStream();</span>
<span class="nc" id="L164">        return availableInBuffer + bytesAvailableToSkip;</span>
    }

    private void fillBufferWithNextChunk() {
<span class="nc" id="L168">        this.chunkNumber++;</span>
<span class="nc" id="L169">        fillBuffer(this.chunkNumber);</span>
<span class="nc" id="L170">    }</span>

    private void fillBufferWithFirstChunk() {
<span class="nc" id="L173">        fillBuffer(0);</span>
<span class="nc" id="L174">    }</span>

    private void fillBuffer(final int chunkNumber) {
<span class="nc" id="L177">        buffer = readChunk(chunkNumber);</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">        if (buffer == null) {</span>
<span class="nc" id="L179">            endOfStream();</span>
        } else {
<span class="nc" id="L181">            indexInBuffer = 0;</span>
        }
<span class="nc" id="L183">    }</span>

    private void endOfStream() {
<span class="nc" id="L186">        buffer = new byte[0];</span>
<span class="nc" id="L187">        indexInBuffer = -1;</span>
<span class="nc" id="L188">        chunkNumber = -1;</span>
<span class="nc" id="L189">    }</span>

    private byte[] readChunk( final int chunkNumber ) {
<span class="nc" id="L192">        final String chunkKey = key + &quot;-&quot; + chunkNumber;</span>
<span class="nc" id="L193">        LOGGER.debug(&quot;Read chunk {0}&quot;, chunkKey);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (blobCache.contains(chunkKey)) {</span>
<span class="nc" id="L195">            return blobCache.load(chunkKey).getValue();</span>
        }
<span class="nc" id="L197">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>