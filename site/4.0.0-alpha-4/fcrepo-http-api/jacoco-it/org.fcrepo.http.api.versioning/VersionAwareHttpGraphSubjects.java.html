<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>VersionAwareHttpGraphSubjects.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fedora Repository HTTP API Module</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.http.api.versioning</a> &gt; <span class="el_source">VersionAwareHttpGraphSubjects.java</span></div><h1>VersionAwareHttpGraphSubjects.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2013 DuraSpace, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.fcrepo.http.api.versioning;

import com.hp.hpl.jena.rdf.model.Resource;
import org.fcrepo.http.commons.api.rdf.HttpGraphSubjects;
import org.slf4j.Logger;

import javax.jcr.ItemNotFoundException;
import javax.jcr.Node;
import javax.jcr.Property;
import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.version.VersionHistory;
import javax.validation.constraints.NotNull;
import javax.ws.rs.core.UriInfo;
import java.net.URI;
import java.util.Map;

import static com.hp.hpl.jena.rdf.model.ResourceFactory.createResource;
import static java.util.Collections.singletonMap;
import static org.fcrepo.jcr.FedoraJcrTypes.FCR_CONTENT;
import static org.fcrepo.jcr.FedoraJcrTypes.FCR_VERSIONS;
import static org.modeshape.jcr.api.JcrConstants.JCR_CONTENT;
import static org.slf4j.LoggerFactory.getLogger;

/**
 * An extension of HttpGraphSubjects that includes mapping from JCR frozen nodes
 * that represent versions of versionable nodes to a URI pattern that presents
 * them as children of the original node.  The URL patterns are as follows:
 *
 * If node &quot;node&quot; is versionable, and has the unversionable subgraph
 * &quot;path/to/versioned/part&quot; and a version snapshot exists with the label
 * &quot;label&quot;, the path to access the frozen nodes
 * is:
 * &quot; ../node/fcr:versions/label/path/to/versioned/part&quot;.
 *
 * The &quot;label&quot; referred to here is either the cannonical identifier assigned
 * to the version or the user label optionally assinged at version creation
 * time.  When this class translates JCR nodes to subjects, it will always
 * return that cannonical identifier, but when mapping from graph subjects to
 * JCR nodes, either the user label or cannonical ID are supported.
 *
 * @author Mike Durbin
 */
public class VersionAwareHttpGraphSubjects extends HttpGraphSubjects {

<span class="fc" id="L61">    private static final Logger LOGGER = getLogger(VersionAwareHttpGraphSubjects.class);</span>

    private Session internalSession;

    /**
     * Creates a GraphSubject implementation that has all of the functionality
     * of HttpGraphSubjects with the additional mapping versioned frozen nodes
     * to URIs that appear in the hierarchy of the original node.
     *
     * This mapping can be heavyweight in that it has to do version lookups and
     * other expensive operations for nodes that appear to be historic versions.
     *
     * @param session the current session (may contain transaction information)
     * @param internalSession a session with read access to all content
     * @param relativeTo a class whose path annotation will be used as the
     *                   base for all relative paths
     * @param uris a UriInfo implementation with information about the request
     *             URI.
     */
    public VersionAwareHttpGraphSubjects(final Session session,
        final Session internalSession, final Class&lt;?&gt; relativeTo, final UriInfo uris) {
<span class="fc" id="L82">        super(session, relativeTo, uris);</span>
<span class="fc" id="L83">        this.internalSession = internalSession;</span>
<span class="fc" id="L84">    }</span>

    @Override
    public String getPathFromGraphSubject(@NotNull final String subjectUri) throws RepositoryException {
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">        if (subjectUri.matches(&quot;^.*\\Q&quot; + FCR_VERSIONS + &quot;/\\E.+$&quot;)) {</span>
<span class="nc" id="L89">            final Node node = getNodeFromGraphSubjectForVersionNode(subjectUri);</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">            if (node == null) {</span>
<span class="nc" id="L91">                return null;</span>
            }
<span class="nc" id="L93">            return node.getPath();</span>
        }
<span class="fc" id="L95">        return super.getPathFromGraphSubject(subjectUri);</span>
    }

    @Override
    public Resource getGraphSubject(final String absPath) throws RepositoryException {
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (absPath.contains(&quot;jcr:versionStorage&quot;)) {</span>
<span class="nc" id="L101">            final Node probableFrozenNode = internalSession.getNode(absPath);</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">            if (probableFrozenNode.getPrimaryNodeType().getName().equals(&quot;nt:frozenNode&quot;)) {</span>
<span class="nc" id="L103">                final URI result = nodesBuilder.buildFromMap(getPathMapForVersionNode(probableFrozenNode));</span>
<span class="nc" id="L104">                LOGGER.debug(&quot;Translated path {} into RDF subject {}&quot;, absPath, result);</span>
<span class="nc" id="L105">                return createResource(result.toString());</span>
            }
<span class="nc" id="L107">            LOGGER.debug(&quot;{} was not a frozen node... no version-specific translation required&quot;, absPath);</span>
        }
<span class="nc" id="L109">        return super.getGraphSubject(absPath);</span>
    }

    @Override
    public Resource getGraphSubject(final Node node) throws RepositoryException {
<span class="fc bfc" id="L114" title="All 2 branches covered.">        if (node.getPrimaryNodeType().getName().equals(&quot;nt:frozenNode&quot;)) {</span>
<span class="fc" id="L115">            final URI result = nodesBuilder.buildFromMap(getPathMapForVersionNode(node));</span>
<span class="fc" id="L116">            LOGGER.debug(&quot;Translated node {} into RDF subject {}&quot;, node, result);</span>
<span class="fc" id="L117">            return createResource(result.toString());</span>
        }
<span class="fc" id="L119">        return super.getGraphSubject(node);</span>
    }

    /**
     * For frozen nodes (which represent version snapshots) we translate the
     * paths from their frozen storage URI to
     * &quot;../node/fcr:versions/label/path/to/versioned/part&quot;.
     * @see #getNodeFromGraphSubjectForVersionNode
     * @param frozenNode an nt:frozenNode whose fedora-specific URI path is to be
     *             retrieved
     * @return a map with a single entry with the key &quot;path&quot; and the value
     *         equal to the fedora path for the version node.
     * @throws NullPointerException if session is null
     */
    private Map&lt;String,String&gt; getPathMapForVersionNode(final Node frozenNode)
        throws RepositoryException {
<span class="fc" id="L135">        Node versionableFrozenNode = frozenNode;</span>
<span class="fc" id="L136">        Node versionableNode = internalSession.getNodeByIdentifier(</span>
                versionableFrozenNode.getProperty(&quot;jcr:frozenUuid&quot;).getString());
<span class="fc" id="L138">        String pathWithinVersionable = &quot;&quot;;</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        while (!versionableNode.isNodeType(&quot;mix:versionable&quot;)) {</span>
<span class="fc" id="L140">            LOGGER.debug(&quot;node {} is not versionable, checking parent...&quot;, versionableNode.getIdentifier());</span>
<span class="fc" id="L141">            pathWithinVersionable = &quot;/&quot; + getRelativePath(versionableNode,</span>
                    versionableNode.getParent()) + pathWithinVersionable;
<span class="fc" id="L143">            versionableFrozenNode = versionableFrozenNode.getParent();</span>
<span class="fc" id="L144">            versionableNode = internalSession.getNodeByIdentifier(</span>
                    versionableFrozenNode.getProperty(&quot;jcr:frozenUuid&quot;).getString());
        }

<span class="fc bfc" id="L148" title="All 2 branches covered.">        pathWithinVersionable = versionableFrozenNode.getIdentifier()</span>
                + (pathWithinVersionable.length() &gt; 0 ? pathWithinVersionable : &quot;&quot;);
<span class="fc" id="L150">        final String pathToVersionable = versionableNode.getPath();</span>
<span class="fc" id="L151">        LOGGER.debug(&quot;frozen node found with id {}.&quot;, versionableFrozenNode.getIdentifier());</span>
<span class="fc" id="L152">        String path =  pathToVersionable + &quot;/&quot; + FCR_VERSIONS + &quot;/&quot; + pathWithinVersionable;</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (path.endsWith(JCR_CONTENT)) {</span>
<span class="fc" id="L154">            path = path.replace(JCR_CONTENT, FCR_CONTENT);</span>
        }
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        return singletonMap(&quot;path&quot;, path.startsWith(&quot;/&quot;) ? path.substring(1) : path);</span>
    }

    private static String getRelativePath(final Node node, final Node ancestor) throws RepositoryException {
<span class="fc" id="L160">        return node.getPath().substring(ancestor.getPath().length() + 1);</span>
    }

    /**
     * Gets the frozen node in the system for the version described as the
     * passed subject.
     * @see #getPathMapForVersionNode
     * @param subjectUri a subject containing the fedora identifier as a URI
     * @return the node that represents the version snapshot of the subject.
     * @throws RepositoryException
     * @throws NullPointerException if session is null
     */
    public Node getNodeFromGraphSubjectForVersionNode(final String subjectUri)
        throws RepositoryException {

        /*
         * Get the part of the URI after fcr:versions/ that represents the label
         * optionally followed by a path into the versioned subgraph).
         */
<span class="fc" id="L179">        final String labelAndPath</span>
            = subjectUri.substring(subjectUri.indexOf(FCR_VERSIONS + &quot;/&quot;) + FCR_VERSIONS.length() + 1);

<span class="pc bpc" id="L182" title="1 of 2 branches missed.">        if (labelAndPath.contains(&quot;/&quot;)) {</span>
            /*
             * The subjectUri references a node within a version snapshot
             * (identified by label) of a subgraph.
             */
<span class="nc" id="L187">            final int firstSlash = labelAndPath.indexOf('/');</span>
<span class="nc" id="L188">            final String label = labelAndPath.substring(0, firstSlash);</span>
<span class="nc" id="L189">            final String pathIntoVersionedGraph = labelAndPath.substring(firstSlash + 1);</span>
<span class="nc" id="L190">            LOGGER.trace(&quot;subjectUri={}, label={}, pathIntoVersionedGraph={}&quot;, subjectUri, label,</span>
                    pathIntoVersionedGraph);
<span class="nc" id="L192">            final Node versionedFrozenNode = getFrozenNodeByLabel(subjectUri, label);</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">            if (versionedFrozenNode == null) {</span>
                // there is no version with the given label!
<span class="nc" id="L195">                return null;</span>
            }
<span class="nc" id="L197">            return internalSession.getNode(versionedFrozenNode.getPath() + &quot;/&quot;</span>
                    + pathIntoVersionedGraph.replace(FCR_CONTENT, JCR_CONTENT));
        }
        /**
         * The subjectUri references a version of a verisonable node identified
         * by label (the root of the versioned subgraph).
         */
<span class="fc" id="L204">        final String label = labelAndPath;</span>
<span class="fc" id="L205">        LOGGER.trace(&quot;subjectUri={}, label={}&quot;, subjectUri, label);</span>
<span class="fc" id="L206">        return getFrozenNodeByLabel(subjectUri, label);</span>
    }

    /**
     * A private helper method that tries to look up frozen node for the given subject
     * by a label.  That label may either be one that was assigned at creation time
     * (and is a version label in the JCR sense) or a system assigned identifier that
     * was used for versions created without a label.  The current implementation
     * uses the JCR UUID for the frozen node as the system-assigned label.
     */
    private Node getFrozenNodeByLabel(final String subjectUri, final String label) throws RepositoryException {
<span class="fc" id="L217">        final String baseResourcePath</span>
            = getPathFromGraphSubject(subjectUri.substring(0, subjectUri.indexOf(&quot;/&quot; + FCR_VERSIONS)));
        try {
<span class="fc" id="L220">            final Node frozenNode = internalSession.getNodeByIdentifier(label);</span>

            /*
             * We found a node whose identifier is the &quot;label&quot; for the version.  Now
             * we must do due dilligence to make sure it's a frozen node representing
             * a version of the subject node.
             */
<span class="fc" id="L227">            final Property p = frozenNode.getProperty(&quot;jcr:frozenUuid&quot;);</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">            if (p != null) {</span>
<span class="fc" id="L229">                final Node subjectNode = internalSession.getNode(baseResourcePath);</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">                if (p.getString().equals(subjectNode.getIdentifier())) {</span>
<span class="fc" id="L231">                    return frozenNode;</span>
                }
            }
            /*
             * Though a node with an id of the label was found, it wasn't the
             * node we were looking for, so fall through and look for a labeled
             * node.
             */
<span class="fc" id="L239">        } catch (final ItemNotFoundException ex) {</span>
            /*
             * the label wasn't a uuid of a frozen node but
             * instead possibly a version label.
             */
<span class="nc" id="L244">        }</span>

<span class="fc" id="L246">        final VersionHistory hist =</span>
            internalSession.getWorkspace().getVersionManager().getVersionHistory(baseResourcePath);
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (hist.hasVersionLabel(label)) {</span>
<span class="fc" id="L249">            LOGGER.debug(&quot;Found version for {} by label {}.&quot;,  subjectUri, label);</span>
<span class="fc" id="L250">            return hist.getVersionByLabel(label).getFrozenNode();</span>
        }
<span class="fc" id="L252">        LOGGER.warn(&quot;Unknown version {} with label or uuid {}!&quot;, subjectUri, label);</span>
<span class="fc" id="L253">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312101107</span></div></body></html>