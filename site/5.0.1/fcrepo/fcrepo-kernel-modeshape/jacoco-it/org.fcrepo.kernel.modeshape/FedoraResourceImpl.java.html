<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FedoraResourceImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fedora Repository Kernel Implementation (ModeShape)</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.kernel.modeshape</a> &gt; <span class="el_source">FedoraResourceImpl.java</span></div><h1>FedoraResourceImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to DuraSpace under one or more contributor license agreements.
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * DuraSpace licenses this file to you under the Apache License,
 * Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.fcrepo.kernel.modeshape;

import static com.google.common.net.MediaType.parse;
import static java.time.Instant.ofEpochMilli;
import static java.util.Arrays.asList;
import static java.util.Collections.singleton;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Stream.concat;
import static java.util.stream.Stream.empty;
import static java.util.stream.Stream.of;
import static org.apache.commons.codec.digest.DigestUtils.sha1Hex;
import static org.apache.jena.graph.NodeFactory.createURI;
import static org.apache.jena.rdf.model.ResourceFactory.createProperty;
import static org.apache.jena.rdf.model.ResourceFactory.createResource;
import static org.apache.jena.rdf.model.ResourceFactory.createTypedLiteral;
import static org.apache.jena.update.UpdateAction.execute;
import static org.apache.jena.update.UpdateFactory.create;
import static org.fcrepo.kernel.api.RdfCollectors.toModel;
import static org.fcrepo.kernel.api.RdfLexicon.HAS_MEMBER_RELATION;
import static org.fcrepo.kernel.api.RdfLexicon.INTERACTION_MODELS;
import static org.fcrepo.kernel.api.RdfLexicon.LAST_MODIFIED_DATE;
import static org.fcrepo.kernel.api.RdfLexicon.LDP_NAMESPACE;
import static org.fcrepo.kernel.api.RdfLexicon.RDF_NAMESPACE;
import static org.fcrepo.kernel.api.RdfLexicon.isManagedNamespace;
import static org.fcrepo.kernel.api.RdfLexicon.isManagedPredicate;
import static org.fcrepo.kernel.api.RdfLexicon.isRelaxed;
import static org.fcrepo.kernel.api.RequiredRdfContext.EMBED_RESOURCES;
import static org.fcrepo.kernel.api.RequiredRdfContext.INBOUND_REFERENCES;
import static org.fcrepo.kernel.api.RequiredRdfContext.LDP_CONTAINMENT;
import static org.fcrepo.kernel.api.RequiredRdfContext.LDP_MEMBERSHIP;
import static org.fcrepo.kernel.api.RequiredRdfContext.MINIMAL;
import static org.fcrepo.kernel.api.RequiredRdfContext.PROPERTIES;
import static org.fcrepo.kernel.api.RequiredRdfContext.SERVER_MANAGED;
import static org.fcrepo.kernel.modeshape.FedoraJcrConstants.FROZEN_MIXIN_TYPES;
import static org.fcrepo.kernel.modeshape.FedoraJcrConstants.JCR_CREATED;
import static org.fcrepo.kernel.modeshape.FedoraJcrConstants.JCR_LASTMODIFIED;
import static org.fcrepo.kernel.modeshape.FedoraJcrConstants.ROOT;
import static org.fcrepo.kernel.modeshape.RdfJcrLexicon.jcrProperties;
import static org.fcrepo.kernel.modeshape.identifiers.NodeResourceConverter.nodeConverter;
import static org.fcrepo.kernel.modeshape.rdf.JcrRdfTools.getRDFNamespaceForJcrNamespace;
import static org.fcrepo.kernel.modeshape.services.functions.JcrPropertyFunctions.isFrozen;
import static org.fcrepo.kernel.modeshape.services.functions.JcrPropertyFunctions.property2values;
import static org.fcrepo.kernel.modeshape.utils.FedoraTypesUtils.getContainingNode;
import static org.fcrepo.kernel.modeshape.utils.FedoraTypesUtils.getJcrNode;
import static org.fcrepo.kernel.modeshape.utils.FedoraTypesUtils.hasInternalNamespace;
import static org.fcrepo.kernel.modeshape.utils.FedoraTypesUtils.isAcl;
import static org.fcrepo.kernel.modeshape.utils.FedoraTypesUtils.isInternalNode;
import static org.fcrepo.kernel.modeshape.utils.FedoraTypesUtils.isMemento;
import static org.fcrepo.kernel.modeshape.utils.FedoraTypesUtils.ldpInsertedContentProperty;
import static org.fcrepo.kernel.modeshape.utils.FedoraTypesUtils.resourceToProperty;
import static org.fcrepo.kernel.modeshape.utils.FedoraTypesUtils.touchLdpMembershipResource;
import static org.fcrepo.kernel.modeshape.utils.NamespaceTools.getNamespaceRegistry;
import static org.fcrepo.kernel.modeshape.utils.StreamUtils.iteratorToStream;
import static org.fcrepo.kernel.modeshape.utils.UncheckedFunction.uncheck;
import static org.modeshape.jcr.api.JcrConstants.JCR_CONTENT;
import static org.modeshape.jcr.api.JcrConstants.NT_FOLDER;
import static org.slf4j.LoggerFactory.getLogger;

import java.net.URI;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.time.temporal.Temporal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.jcr.NamespaceRegistry;
import javax.jcr.Node;
import javax.jcr.PathNotFoundException;
import javax.jcr.Property;
import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.Value;
import javax.jcr.nodetype.NodeType;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Converter;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import org.apache.commons.lang3.StringUtils;
import org.apache.jena.graph.Triple;
import org.apache.jena.rdf.model.Model;
import org.apache.jena.rdf.model.Resource;
import org.apache.jena.rdf.model.Statement;
import org.apache.jena.rdf.model.StmtIterator;
import org.apache.jena.sparql.core.Quad;
import org.apache.jena.sparql.modify.request.UpdateData;
import org.apache.jena.sparql.modify.request.UpdateDeleteWhere;
import org.apache.jena.sparql.modify.request.UpdateModify;
import org.apache.jena.update.Update;
import org.apache.jena.update.UpdateRequest;
import org.fcrepo.kernel.api.FedoraTypes;
import org.fcrepo.kernel.api.RdfLexicon;
import org.fcrepo.kernel.api.RdfStream;
import org.fcrepo.kernel.api.TripleCategory;
import org.fcrepo.kernel.api.exception.AccessDeniedException;
import org.fcrepo.kernel.api.exception.ConstraintViolationException;
import org.fcrepo.kernel.api.exception.InteractionModelViolationException;
import org.fcrepo.kernel.api.exception.InvalidPrefixException;
import org.fcrepo.kernel.api.exception.MalformedRdfException;
import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;
import org.fcrepo.kernel.api.exception.RepositoryRuntimeException;
import org.fcrepo.kernel.api.exception.ServerManagedPropertyException;
import org.fcrepo.kernel.api.exception.ServerManagedTypeException;
import org.fcrepo.kernel.api.identifiers.IdentifierConverter;
import org.fcrepo.kernel.api.models.FedoraResource;
import org.fcrepo.kernel.api.models.FedoraTimeMap;
import org.fcrepo.kernel.api.models.NonRdfSourceDescription;
import org.fcrepo.kernel.api.rdf.DefaultRdfStream;
import org.fcrepo.kernel.api.utils.GraphDifferencer;
import org.fcrepo.kernel.api.utils.RelaxedPropertiesHelper;
import org.fcrepo.kernel.modeshape.rdf.converters.PropertyConverter;
import org.fcrepo.kernel.modeshape.rdf.impl.ChildrenRdfContext;
import org.fcrepo.kernel.modeshape.rdf.impl.ContentRdfContext;
import org.fcrepo.kernel.modeshape.rdf.impl.HashRdfContext;
import org.fcrepo.kernel.modeshape.rdf.impl.InternalIdentifierTranslator;
import org.fcrepo.kernel.modeshape.rdf.impl.LdpContainerRdfContext;
import org.fcrepo.kernel.modeshape.rdf.impl.LdpIsMemberOfRdfContext;
import org.fcrepo.kernel.modeshape.rdf.impl.LdpRdfContext;
import org.fcrepo.kernel.modeshape.rdf.impl.PropertiesRdfContext;
import org.fcrepo.kernel.modeshape.rdf.impl.ReferencesRdfContext;
import org.fcrepo.kernel.modeshape.rdf.impl.RootRdfContext;
import org.fcrepo.kernel.modeshape.rdf.impl.SkolemNodeRdfContext;
import org.fcrepo.kernel.modeshape.rdf.impl.TypeRdfContext;
import org.fcrepo.kernel.modeshape.utils.FedoraTypesUtils;
import org.fcrepo.kernel.modeshape.utils.FilteringJcrPropertyStatementListener;
import org.fcrepo.kernel.modeshape.utils.PropertyChangedListener;
import org.fcrepo.kernel.modeshape.utils.UncheckedPredicate;
import org.fcrepo.kernel.modeshape.utils.iterators.RdfAdder;
import org.fcrepo.kernel.modeshape.utils.iterators.RdfRemover;
import org.modeshape.jcr.api.JcrTools;
import org.slf4j.Logger;

/**
 * Common behaviors across {@link org.fcrepo.kernel.api.models.Container} and
 * {@link org.fcrepo.kernel.api.models.NonRdfSourceDescription} types; also used
 * when the exact type of an object is irrelevant
 *
 * @author ajs6f
 */
public class FedoraResourceImpl extends JcrTools implements FedoraTypes, FedoraResource {

<span class="fc" id="L172">    private static final Logger LOGGER = getLogger(FedoraResourceImpl.class);</span>

    private static final long NO_TIME = 0L;

<span class="fc" id="L176">    private static final PropertyConverter propertyConverter = new PropertyConverter();</span>

    public static final String LDPCV_TIME_MAP = &quot;fedora:timemap&quot;;

    public static final String CONTAINER_WEBAC_ACL = &quot;fedora:acl&quot;;

    private static final String RDF_TYPE_URI = RDF_NAMESPACE + &quot;type&quot;;

    // A curried type accepting resource, translator, and &quot;minimality&quot;, returning triples.
    protected interface RdfGenerator extends Function&lt;FedoraResource,
    Function&lt;IdentifierConverter&lt;Resource, FedoraResource&gt;, Function&lt;Boolean, Stream&lt;Triple&gt;&gt;&gt;&gt; {}

<span class="fc" id="L188">    private static final RdfGenerator getDefaultTriples = resource -&gt; translator -&gt; uncheck(minimal -&gt; {</span>
<span class="fc" id="L189">        final Stream&lt;Stream&lt;Triple&gt;&gt; min = of(</span>
            new TypeRdfContext(resource, translator),
            new PropertiesRdfContext(resource, translator));
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (!minimal) {</span>
<span class="fc" id="L193">            final Stream&lt;Stream&lt;Triple&gt;&gt; extra = of(</span>
                new HashRdfContext(resource, translator),
                new SkolemNodeRdfContext(resource, translator));
<span class="fc" id="L196">            return concat(min, extra).reduce(empty(), Stream::concat);</span>
        }
<span class="nc" id="L198">        return min.reduce(empty(), Stream::concat);</span>
    });

<span class="pc" id="L201">    private static final RdfGenerator getEmbeddedResourceTriples = resource -&gt; translator -&gt; uncheck(minimal -&gt;</span>
<span class="nc" id="L202">            resource.getChildren().flatMap(child -&gt; child.getTriples(translator, PROPERTIES)));</span>

<span class="fc" id="L204">    private static final RdfGenerator getInboundTriples = resource -&gt; translator -&gt; uncheck(_minimal -&gt; {</span>
<span class="fc" id="L205">        return new ReferencesRdfContext(resource, translator);</span>
    });

<span class="fc" id="L208">    private static final RdfGenerator getLdpContainsTriples = resource -&gt; translator -&gt; uncheck(_minimal -&gt; {</span>
<span class="fc" id="L209">        return new ChildrenRdfContext(resource, translator);</span>
    });

<span class="fc" id="L212">    private static final RdfGenerator getServerManagedTriples = resource -&gt; translator -&gt; uncheck(minimal -&gt; {</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (minimal) {</span>
<span class="nc" id="L214">            return new LdpRdfContext(resource, translator);</span>
        }
<span class="fc" id="L216">        final Stream&lt;Stream&lt;Triple&gt;&gt; streams = of(</span>
            new LdpRdfContext(resource, translator),
            new RootRdfContext(resource, translator),
            new ContentRdfContext(resource, translator));
<span class="fc" id="L220">        return streams.reduce(empty(), Stream::concat);</span>
    });

<span class="fc" id="L223">    private static final RdfGenerator getLdpMembershipTriples = resource -&gt; translator -&gt; uncheck(_minimal -&gt; {</span>
<span class="fc" id="L224">        final Stream&lt;Stream&lt;Triple&gt;&gt; streams = of(</span>
            new LdpContainerRdfContext(resource, translator),
            new LdpIsMemberOfRdfContext(resource, translator));
<span class="fc" id="L227">        return streams.reduce(empty(), Stream::concat);</span>
    });

    protected static final Map&lt;TripleCategory, RdfGenerator&gt; contextMap =
<span class="fc" id="L231">            ImmutableMap.&lt;TripleCategory, RdfGenerator&gt;builder()</span>
<span class="fc" id="L232">                    .put(PROPERTIES, getDefaultTriples)</span>
<span class="fc" id="L233">                    .put(EMBED_RESOURCES, getEmbeddedResourceTriples)</span>
<span class="fc" id="L234">                    .put(INBOUND_REFERENCES, getInboundTriples)</span>
<span class="fc" id="L235">                    .put(SERVER_MANAGED, getServerManagedTriples)</span>
<span class="fc" id="L236">                    .put(LDP_MEMBERSHIP, getLdpMembershipTriples)</span>
<span class="fc" id="L237">                    .put(LDP_CONTAINMENT, getLdpContainsTriples)</span>
<span class="fc" id="L238">                    .build();</span>

    protected final Node node;

    /*
     * A terminating slash means ModeShape has trouble extracting the localName, e.g., for http://myurl.org/.
     *
     * @see &lt;a href=&quot;https://jira.duraspace.org/browse/FCREPO-1409&quot;&gt; FCREPO-1409 &lt;/a&gt; for details.
     */
<span class="fc" id="L247">    private static final Function&lt;Triple, ConstraintViolationException&gt; validatePredicateEndsWithSlash = uncheck(x -&gt; {</span>
<span class="pc bpc" id="L248" title="1 of 4 branches missed.">        if (x.getPredicate().isURI() &amp;&amp; x.getPredicate().getURI().endsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L249">            return new MalformedRdfException(&quot;Invalid predicate ends with '/': &quot; + x.getPredicate().getURI());</span>
        }
<span class="fc" id="L251">        return null;</span>
    });

    /*
     * Ensures the object URI is valid
     */
<span class="fc" id="L257">    private static final Function&lt;Triple, ConstraintViolationException&gt; validateObjectUrl = uncheck(x -&gt; {</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">        if (x.getObject().isURI()) {</span>
<span class="fc" id="L259">            final String uri = x.getObject().toString();</span>
            try {
<span class="fc" id="L261">                new URI(uri);</span>
<span class="nc" id="L262">            } catch (final Exception ex) {</span>
<span class="nc" id="L263">                return new MalformedRdfException(&quot;Invalid object URI (&quot; + uri + &quot; ) : &quot; + ex.getMessage());</span>
<span class="fc" id="L264">            }</span>
        }
<span class="fc" id="L266">        return null;</span>
    });

<span class="fc" id="L269">    private static final Function&lt;Triple, ConstraintViolationException&gt; validateMimeTypeTriple = uncheck(x -&gt; {</span>
        /* only look at the mime type if it's not a sparql variable */
<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (x.getPredicate().toString().equals(RdfLexicon.HAS_MIME_TYPE.toString()) &amp;&amp;</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">                !x.getObject().toString(false).startsWith(&quot;?&quot;)) {</span>
            try {
<span class="nc" id="L274">                parse(x.getObject().toString(false));</span>
<span class="fc" id="L275">            } catch (final Exception ex) {</span>
<span class="fc" id="L276">                return new MalformedRdfException(&quot;Invalid value for '&quot; + RdfLexicon.HAS_MIME_TYPE +</span>
<span class="fc" id="L277">                        &quot;' encountered : &quot; + x.getObject().toString());</span>
<span class="nc" id="L278">            }</span>
        }
<span class="fc" id="L280">        return null;</span>
    });


<span class="fc" id="L284">    private static final Function&lt;Triple, ConstraintViolationException&gt; validateNoManagedTypes = uncheck(x -&gt;  {</span>
<span class="fc" id="L285">        final org.apache.jena.graph.Node object = x.getObject();</span>
<span class="fc" id="L286">        final String predicateUri = x.getPredicate().getURI();</span>
<span class="fc bfc" id="L287" title="All 4 branches covered.">        if (object.isURI() &amp;&amp; RDF_TYPE_URI.equals(predicateUri) &amp;&amp;</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">            isManagedNamespace.test(object.getNameSpace())) {</span>
<span class="nc" id="L289">            return new ServerManagedTypeException(</span>
                &quot;The &quot; + predicateUri + &quot; predicate may not take an object in the server managed namespaces (&quot; +
<span class="nc" id="L291">                object.getNameSpace() + &quot;).&quot;);</span>
        }
<span class="fc" id="L293">        return null;</span>
    });

<span class="fc" id="L296">    private static final Function&lt;Triple, ConstraintViolationException&gt; validateNoManagedPredicates  = uncheck(x -&gt;  {</span>
<span class="fc" id="L297">        final String predicateUri = x.getPredicate().getURI();</span>
<span class="fc" id="L298">        final org.apache.jena.rdf.model.Property predicateProperty = createProperty(predicateUri);</span>
<span class="pc bpc" id="L299" title="1 of 4 branches missed.">        if (isManagedPredicate.test(predicateProperty) &amp;&amp; !isRelaxed.test(predicateProperty)) {</span>
<span class="fc" id="L300">            return new ServerManagedPropertyException(</span>
                &quot;The server managed predicates (&quot; + predicateUri + &quot;) cannot be modified by the client.&quot;);
        }

<span class="fc" id="L304">        return null;</span>
    });

<span class="fc" id="L307">    private static final Function&lt;Triple, ConstraintViolationException&gt; validateMemberRelation = uncheck(x -&gt; {</span>
<span class="fc" id="L308">        final org.apache.jena.graph.Node object = x.getObject();</span>
<span class="fc bfc" id="L309" title="All 4 branches covered.">        if (object.isURI() &amp;&amp; x.getPredicate().getURI().equals(HAS_MEMBER_RELATION.toString()) &amp;&amp;</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">            isManagedPredicate.test(createProperty(object.getURI()))) {</span>
<span class="nc" id="L311">            return new ServerManagedPropertyException(</span>
                &quot;The &quot; + HAS_MEMBER_RELATION + &quot; predicate may not take the server managed type. (&quot; +
<span class="nc" id="L313">                object.getURI() + &quot;).&quot;);</span>
        }

<span class="fc" id="L316">        return null;</span>
    });

    private static final List&lt;Function&lt;Triple, ConstraintViolationException&gt;&gt; tripleValidators =
<span class="fc" id="L320">            ImmutableList.&lt;Function&lt;Triple, ConstraintViolationException&gt;&gt;builder()</span>
<span class="fc" id="L321">                    .add(validatePredicateEndsWithSlash)</span>
<span class="fc" id="L322">                    .add(validateObjectUrl)</span>
<span class="fc" id="L323">                    .add(validateMimeTypeTriple)</span>
<span class="fc" id="L324">                    .add(validateNoManagedTypes)</span>
<span class="fc" id="L325">                    .add(validateNoManagedPredicates)</span>
<span class="fc" id="L326">                    .add(validateMemberRelation).build();</span>

    /**
     * Construct a {@link org.fcrepo.kernel.api.models.FedoraResource} from an existing JCR Node
     * @param node an existing JCR node to treat as an fcrepo object
     */
<span class="fc" id="L332">    public FedoraResourceImpl(final Node node) {</span>
<span class="fc" id="L333">        this.node = node;</span>
<span class="fc" id="L334">    }</span>

    /**
     * Return the underlying JCR Node for this resource
     *
     * @return the JCR Node
     */
    public Node getNode() {
<span class="fc" id="L342">        return node;</span>
    }

    /* (non-Javadoc)
     * @see org.fcrepo.kernel.api.models.FedoraResource#getPath()
     */
    @Override
    public String getPath() {
        try {
<span class="fc" id="L351">            final String path = node.getPath();</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">            return path.endsWith(&quot;/&quot; + JCR_CONTENT) ? path.substring(0, path.length() - JCR_CONTENT.length() - 1)</span>
                : path;
<span class="fc" id="L354">        } catch (final RepositoryException e) {</span>
<span class="fc" id="L355">            throw new RepositoryRuntimeException(e);</span>
        }
    }

    /* (non-Javadoc)
     * @see org.fcrepo.kernel.api.models.FedoraResource#getChildren(Boolean recursive)
     */
    @Override
    public Stream&lt;FedoraResource&gt; getChildren(final Boolean recursive) {
        try {
<span class="fc bfc" id="L365" title="All 2 branches covered.">            if (recursive) {</span>
<span class="fc" id="L366">                return nodeToGoodChildren(node).flatMap(FedoraResourceImpl::getAllChildren);</span>
            }
<span class="fc" id="L368">            return nodeToGoodChildren(node);</span>
<span class="nc" id="L369">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L370">            throw new RepositoryRuntimeException(e);</span>
        }
    }

    /* (non-Javadoc)
     * @see org.fcrepo.kernel.api.models.FedoraResource#getDescription()
     */
    @Override
    public FedoraResource getDescription() {
<span class="fc" id="L379">        return this;</span>
    }

    protected Node getDescriptionNode() {
<span class="nc" id="L383">        return getNode();</span>
    }

    /* (non-Javadoc)
     * @see org.fcrepo.kernel.api.models.FedoraResource#getDescribedResource()
     */
    @Override
    public FedoraResource getDescribedResource() {
<span class="fc" id="L391">        return this;</span>
    }

    /**
     * Get the &quot;good&quot; children for a node by skipping all pairtree nodes in the way.
     * @param input Node containing children
     * @return Stream of good children
     * @throws RepositoryException on error
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private Stream&lt;FedoraResource&gt; nodeToGoodChildren(final Node input) throws RepositoryException {
<span class="fc" id="L402">        return iteratorToStream(input.getNodes()).filter(nastyChildren.negate())</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">            .flatMap(uncheck((final Node child) -&gt; child.isNodeType(FEDORA_PAIRTREE) ? nodeToGoodChildren(child) :</span>
<span class="fc" id="L404">                        of(nodeConverter.convert(child))));</span>
    }

    /**
     * Get all children recursively, and flatten into a single Stream.
     */
    private static Stream&lt;FedoraResource&gt; getAllChildren(final FedoraResource resource) {
<span class="fc" id="L411">        return concat(of(resource), resource.getChildren().flatMap(FedoraResourceImpl::getAllChildren));</span>
    }

    /**
     * Children for whom we will not generate triples.
     */
<span class="fc" id="L417">    private static final Predicate&lt;Node&gt; nastyChildren = isInternalNode</span>
<span class="fc" id="L418">                    .or(TombstoneImpl::hasMixin)</span>
<span class="fc" id="L419">                    .or(FedoraTimeMapImpl::hasMixin)</span>
<span class="fc" id="L420">                    .or(FedoraWebacAclImpl::hasMixin)</span>
<span class="fc" id="L421">                    .or(UncheckedPredicate.uncheck(p -&gt; p.getName().equals(JCR_CONTENT)))</span>
<span class="fc" id="L422">                    .or(UncheckedPredicate.uncheck(p -&gt; p.getName().equals(&quot;#&quot;)));</span>

    @Override
    public FedoraResource getContainer() {
<span class="fc" id="L426">        return getContainingNode(getNode()).map(nodeConverter::convert).orElse(null);</span>
    }

    @Override
    public FedoraResource getOriginalResource() {
<span class="fc bfc" id="L431" title="All 2 branches covered.">        if (!isMemento()) {</span>
<span class="fc" id="L432">            return this;</span>
        }

        try {
<span class="fc" id="L436">            return nodeConverter.convert(node.getParent().getParent());</span>
<span class="nc" id="L437">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L438">            throw new RepositoryRuntimeException(e);</span>
        }
    }

    @Override
    public FedoraResource getTimeMap() {
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">        if (this instanceof FedoraTimeMap) {</span>
<span class="nc" id="L445">            return this;</span>
        }

        try {
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">            if (isOriginalResource()) {</span>
<span class="fc" id="L450">                return findOrCreateTimeMap();</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">            } else if (isMemento()) {</span>
<span class="nc" id="L452">                return Optional.of(node.getParent()).map(nodeConverter::convert).orElse(null);</span>
            } else {
<span class="nc" id="L454">                throw new PathNotFoundException(</span>
<span class="nc" id="L455">                    &quot;getTimeMap() is not supported for this node: &quot; + node.getPath());</span>
            }
<span class="nc" id="L457">        } catch (final PathNotFoundException e) {</span>
<span class="nc" id="L458">            throw new PathNotFoundRuntimeException(e);</span>
<span class="nc" id="L459">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L460">            throw new RepositoryRuntimeException(e);</span>
        }
    }


    private FedoraResource findOrCreateTimeMap() {
        final Node ldpcvNode;
        try {
<span class="fc" id="L468">            ldpcvNode = findOrCreateChild(getNode(), LDPCV_TIME_MAP, NT_FOLDER);</span>

<span class="fc bfc" id="L470" title="All 2 branches covered.">            if (ldpcvNode.isNew()) {</span>
<span class="fc" id="L471">                LOGGER.debug(&quot;Created TimeMap LDPCv {}&quot;, ldpcvNode.getPath());</span>

                // add mixin type fedora:Resource
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">                if (node.canAddMixin(FEDORA_RESOURCE)) {</span>
<span class="fc" id="L475">                    node.addMixin(FEDORA_RESOURCE);</span>
                }

                // add mixin type fedora:TimeMap
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">                if (ldpcvNode.canAddMixin(FEDORA_TIME_MAP)) {</span>
<span class="fc" id="L480">                    ldpcvNode.addMixin(FEDORA_TIME_MAP);</span>
                }

                // Set reference from timegate/map to original resource
<span class="fc" id="L484">                ldpcvNode.setProperty(MEMENTO_ORIGINAL, getNode());</span>
            }
<span class="nc" id="L486">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L487">            throw new RepositoryRuntimeException(e);</span>
<span class="fc" id="L488">        }</span>
<span class="fc" id="L489">        return Optional.of(ldpcvNode).map(nodeConverter::convert).orElse(null);</span>
    }

    @Override
    public Instant getMementoDatetime() {
        try {
<span class="fc" id="L495">            final Node node = getNode();</span>
<span class="pc bpc" id="L496" title="2 of 4 branches missed.">            if (!isMemento() || !node.hasProperty(MEMENTO_DATETIME)) {</span>
<span class="nc" id="L497">                return null;</span>
            }

<span class="fc" id="L500">            final Calendar calDate = node.getProperty(MEMENTO_DATETIME).getDate();</span>
<span class="fc" id="L501">            return calDate.toInstant();</span>
<span class="nc" id="L502">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L503">            throw new RepositoryRuntimeException(e);</span>
        }
    }

    @Override
    public boolean isOriginalResource() {
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">        return !isMemento();</span>
    }

    @Override
    public boolean isMemento() {
<span class="fc" id="L514">        return isMemento.test(getNode());</span>
    }

    @Override
    public boolean isAcl() {
<span class="fc" id="L519">        return isAcl.test(getNode());</span>
    }

    @Override
    public FedoraResource getAcl() {
        final Node parentNode;

        try {
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">            if (this instanceof NonRdfSourceDescription) {</span>
<span class="nc" id="L528">                parentNode = getNode().getParent();</span>
            } else {
<span class="fc" id="L530">                parentNode = getNode();</span>
            }

<span class="fc bfc" id="L533" title="All 2 branches covered.">            if (!parentNode.hasNode(CONTAINER_WEBAC_ACL)) {</span>
<span class="fc" id="L534">                return null;</span>
            }

<span class="fc" id="L537">            final Node aclNode = parentNode.getNode(CONTAINER_WEBAC_ACL);</span>
<span class="fc" id="L538">            return Optional.of(aclNode).map(nodeConverter::convert).orElse(null);</span>
<span class="nc" id="L539">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L540">            throw new RepositoryRuntimeException(e);</span>
        }
    }

    @Override
    public FedoraResource findOrCreateAcl() {
        final Node aclNode;
        try {
            final Node parentNode;
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">            if (this instanceof NonRdfSourceDescription) {</span>
<span class="nc" id="L550">                parentNode = getNode().getParent();</span>
            } else {
<span class="fc" id="L552">                parentNode = getNode();</span>
            }

<span class="fc" id="L555">            aclNode = findOrCreateChild(parentNode, CONTAINER_WEBAC_ACL, NT_FOLDER);</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">            if (aclNode.isNew()) {</span>
<span class="fc" id="L557">                LOGGER.debug(&quot;Created Webac ACL {}&quot;, aclNode.getPath());</span>

                // add mixin type fedora:Resource
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">                if (aclNode.canAddMixin(FEDORA_RESOURCE)) {</span>
<span class="fc" id="L561">                    aclNode.addMixin(FEDORA_RESOURCE);</span>
                }

                // add mixin type webac:Acl
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">                if (aclNode.canAddMixin(FEDORA_WEBAC_ACL)) {</span>
<span class="fc" id="L566">                    aclNode.addMixin(FEDORA_WEBAC_ACL);</span>
                }
            }
<span class="nc" id="L569">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L570">            throw new RepositoryRuntimeException(e);</span>
<span class="fc" id="L571">        }</span>
<span class="fc" id="L572">        return Optional.of(aclNode).map(nodeConverter::convert).orElse(null);</span>
    }

    @Override
    public FedoraResource getChild(final String relPath) {
        try {
<span class="fc" id="L578">            return nodeConverter.convert(getNode().getNode(relPath));</span>
<span class="nc" id="L579">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L580">            throw new RepositoryRuntimeException(e);</span>
        }
    }

    @Override
    public boolean hasProperty(final String relPath) {
        try {
<span class="fc" id="L587">            return getNode().hasProperty(relPath);</span>
<span class="nc" id="L588">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L589">            throw new RepositoryRuntimeException(e);</span>
        }
    }

    @Override
    public void delete() {
        try {
            // Precalculate before node is removed
<span class="fc" id="L597">            final boolean isMemento = isMemento();</span>
<span class="fc" id="L598">            final boolean isAcl = isAcl();</span>

            // Remove inbound references to this resource and, recursively, any of its children
<span class="fc" id="L601">            removeReferences(node);</span>

<span class="pc bpc" id="L603" title="1 of 2 branches missed.">            final Node parent = getNode().getDepth() &gt; 0 ? getNode().getParent() : null;</span>

<span class="fc" id="L605">            final String name = getNode().getName();</span>

            // This is resolved immediately b/c we delete the node before updating an indirect container's target
<span class="fc" id="L608">            final boolean shouldUpdateIndirectResource = ldpInsertedContentProperty(node)</span>
<span class="fc" id="L609">                .flatMap(resourceToProperty(getSession())).filter(this::hasProperty).isPresent();</span>

<span class="fc" id="L611">            final Optional&lt;Node&gt; containingNode = getContainingNode(getNode());</span>

<span class="fc" id="L613">            node.remove();</span>

<span class="pc bpc" id="L615" title="1 of 2 branches missed.">            if (parent != null) {</span>
<span class="pc bpc" id="L616" title="2 of 4 branches missed.">                if (!isMemento &amp;&amp; !isAcl) {</span>
<span class="fc" id="L617">                    createTombstone(parent, name);</span>
                }

                // also update membershipResources for Direct/Indirect Containers
<span class="fc" id="L621">                containingNode.filter(UncheckedPredicate.uncheck((final Node ancestor) -&gt;</span>
<span class="pc bpc" id="L622" title="1 of 6 branches missed.">                            ancestor.hasProperty(LDP_MEMBER_RESOURCE) &amp;&amp; (ancestor.isNodeType(LDP_DIRECT_CONTAINER) ||</span>
                            shouldUpdateIndirectResource)))
<span class="fc" id="L624">                    .ifPresent(ancestor -&gt; {</span>
                        try {
<span class="fc" id="L626">                            FedoraTypesUtils.touch(ancestor.getProperty(LDP_MEMBER_RESOURCE).getNode());</span>
<span class="nc" id="L627">                        } catch (final RepositoryException ex) {</span>
<span class="nc" id="L628">                            throw new RepositoryRuntimeException(ex);</span>
<span class="fc" id="L629">                        }</span>
<span class="fc" id="L630">                    });</span>

                // update the lastModified date on the parent node
<span class="fc" id="L633">                containingNode.ifPresent(ancestor -&gt; {</span>
<span class="fc" id="L634">                    FedoraTypesUtils.touch(ancestor);</span>
<span class="fc" id="L635">                });</span>
            }
<span class="nc" id="L637">        } catch (final javax.jcr.AccessDeniedException e) {</span>
<span class="nc" id="L638">            throw new AccessDeniedException(e);</span>
<span class="nc" id="L639">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L640">            throw new RepositoryRuntimeException(e);</span>
<span class="fc" id="L641">        }</span>
<span class="fc" id="L642">    }</span>

    protected void removeReferences(final Node n) {
        try {
            // Remove references to this resource
<span class="fc" id="L647">            doRemoveReferences(n);</span>

            // Recurse over children of this resource
<span class="fc bfc" id="L650" title="All 2 branches covered.">            if (n.hasNodes()) {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L652">                final Iterator&lt;Node&gt; nodes = n.getNodes();</span>
<span class="fc" id="L653">                nodes.forEachRemaining(this::removeReferences);</span>
            }
<span class="nc" id="L655">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L656">            throw new RepositoryRuntimeException(e);</span>
<span class="fc" id="L657">        }</span>
<span class="fc" id="L658">    }</span>

    private void doRemoveReferences(final Node n) throws RepositoryException {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L662">        final Iterator&lt;Property&gt; references = n.getReferences();</span>
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L664">        final Iterator&lt;Property&gt; weakReferences = n.getWeakReferences();</span>
<span class="fc" id="L665">        concat(iteratorToStream(references), iteratorToStream(weakReferences)).forEach(prop -&gt; {</span>
            try {
<span class="fc" id="L667">                final List&lt;Value&gt; newVals = property2values.apply(prop).filter(</span>
<span class="fc" id="L668">                        UncheckedPredicate.uncheck(value -&gt;</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">                                !n.equals(getSession().getNodeByIdentifier(value.getString()))))</span>
<span class="fc" id="L670">                        .collect(toList());</span>

<span class="fc bfc" id="L672" title="All 2 branches covered.">                if (newVals.size() == 0) {</span>
<span class="fc" id="L673">                    prop.remove();</span>
                } else {
<span class="fc" id="L675">                    prop.setValue(newVals.toArray(new Value[newVals.size()]));</span>
                }
<span class="nc" id="L677">            } catch (final RepositoryException ex) {</span>
<span class="nc" id="L678">                throw new RepositoryRuntimeException(ex);</span>
<span class="fc" id="L679">            }</span>
<span class="fc" id="L680">        });</span>
<span class="fc" id="L681">    }</span>

    private void createTombstone(final Node parent, final String path) throws RepositoryException {
<span class="fc" id="L684">        findOrCreateChild(parent, path, FEDORA_TOMBSTONE);</span>
<span class="fc" id="L685">    }</span>

    /* (non-Javadoc)
     * @see org.fcrepo.kernel.api.models.FedoraResource#getCreatedDate()
     */
    @Override
    public Instant getCreatedDate() {
        try {
<span class="fc bfc" id="L693" title="All 2 branches covered.">            if (hasProperty(FEDORA_CREATED)) {</span>
<span class="fc" id="L694">                return ofEpochMilli(getTimestamp(FEDORA_CREATED, NO_TIME));</span>
            }
<span class="fc bfc" id="L696" title="All 2 branches covered.">            if (hasProperty(JCR_CREATED)) {</span>
<span class="fc" id="L697">                return ofEpochMilli(getTimestamp(JCR_CREATED, NO_TIME));</span>
            }
<span class="nc" id="L699">        } catch (final PathNotFoundException e) {</span>
<span class="nc" id="L700">            throw new PathNotFoundRuntimeException(e);</span>
<span class="nc" id="L701">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L702">            throw new RepositoryRuntimeException(e);</span>
<span class="fc" id="L703">        }</span>
<span class="fc" id="L704">        LOGGER.debug(&quot;Node {} does not have a createdDate&quot;, node);</span>
<span class="fc" id="L705">        return null;</span>
    }

    /* (non-Javadoc)
     * @see org.fcrepo.kernel.api.models.FedoraResource#getLastModifiedDate()
     */

    /**
     * This method gets the last modified date for this FedoraResource.  Because
     * the last modified date is managed by fcrepo (not ModeShape) while the created
     * date *is* sometimes managed by ModeShape in the current implementation it's
     * possible that the last modified date will be before the created date.  Instead
     * of making a second update to correct the modified date, in cases where the modified
     * date is ealier than the created date, this class presents the created date instead.
     *
     * Any method that exposes the last modified date must maintain this illusion so
     * that that external callers are presented with a sensible and consistent
     * representation of this resource.
     * @return the last modified Instant (or the created Instant if it was after the last
     *         modified date)
     */
    @Override
    public Instant getLastModifiedDate() {

<span class="fc" id="L729">        final Instant createdDate = getCreatedDate();</span>
        try {
<span class="fc bfc" id="L731" title="All 2 branches covered.">            final long created = createdDate == null ? NO_TIME : createdDate.toEpochMilli();</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">            if (hasProperty(FEDORA_LASTMODIFIED)) {</span>
<span class="fc" id="L733">                return ofEpochMilli(getTimestamp(FEDORA_LASTMODIFIED, created));</span>
<span class="pc bpc" id="L734" title="1 of 2 branches missed.">            } else if (hasProperty(JCR_LASTMODIFIED)) {</span>
<span class="fc" id="L735">                return ofEpochMilli(getTimestamp(JCR_LASTMODIFIED, created));</span>
            }
<span class="nc" id="L737">        } catch (final PathNotFoundException e) {</span>
<span class="nc" id="L738">            throw new PathNotFoundRuntimeException(e);</span>
<span class="nc" id="L739">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L740">            throw new RepositoryRuntimeException(e);</span>
<span class="nc" id="L741">        }</span>
<span class="nc" id="L742">        LOGGER.debug(&quot;Could not get last modified date property for node {}&quot;, node);</span>

<span class="nc bnc" id="L744" title="All 2 branches missed.">        if (createdDate != null) {</span>
<span class="nc" id="L745">            LOGGER.trace(&quot;Using created date for last modified date for node {}&quot;, node);</span>
<span class="nc" id="L746">            return createdDate;</span>
        }

<span class="nc" id="L749">        return null;</span>
    }

    private long getTimestamp(final String property, final long created) throws RepositoryException {
<span class="fc" id="L753">        LOGGER.trace(&quot;Using {} date&quot;, property);</span>
<span class="fc" id="L754">        final long timestamp = getProperty(property).getDate().getTimeInMillis();</span>
<span class="pc bpc" id="L755" title="1 of 4 branches missed.">        if (timestamp &lt; created &amp;&amp; created &gt; NO_TIME) {</span>
<span class="fc" id="L756">            LOGGER.trace(&quot;Returning the later created date ({} &gt; {}) for {}&quot;, created, timestamp, property);</span>
<span class="fc" id="L757">            return created;</span>
        }
<span class="fc" id="L759">        return timestamp;</span>
    }

    @Override
    public boolean hasType(final String type) {
        try {
<span class="fc bfc" id="L765" title="All 2 branches covered.">            if (type.equals(FEDORA_REPOSITORY_ROOT)) {</span>
<span class="fc" id="L766">                return node.isNodeType(ROOT);</span>
<span class="pc bpc" id="L767" title="3 of 4 branches missed.">            } else if (isFrozen.test(node) &amp;&amp; hasProperty(FROZEN_MIXIN_TYPES)) {</span>
<span class="nc" id="L768">                return property2values.apply(getProperty(FROZEN_MIXIN_TYPES)).map(uncheck(Value::getString))</span>
<span class="nc" id="L769">                    .anyMatch(type::equals);</span>
            }
<span class="fc" id="L771">            return node.isNodeType(type);</span>
<span class="nc" id="L772">        } catch (final PathNotFoundException e) {</span>
<span class="nc" id="L773">            throw new PathNotFoundRuntimeException(e);</span>
<span class="nc" id="L774">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L775">            throw new RepositoryRuntimeException(e);</span>
        }
    }

    @Override
    public List&lt;URI&gt; getTypes() {
        try {
<span class="fc" id="L782">            final List&lt;NodeType&gt; nodeTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L783">            final NodeType primaryNodeType = node.getPrimaryNodeType();</span>
<span class="fc" id="L784">            nodeTypes.add(primaryNodeType);</span>
<span class="fc" id="L785">            nodeTypes.addAll(asList(primaryNodeType.getSupertypes()));</span>
<span class="fc" id="L786">            final List&lt;NodeType&gt; mixinTypes = asList(node.getMixinNodeTypes());</span>

<span class="fc" id="L788">            nodeTypes.addAll(mixinTypes);</span>
<span class="fc" id="L789">            mixinTypes.stream()</span>
<span class="fc" id="L790">                .map(NodeType::getSupertypes)</span>
<span class="fc" id="L791">                .flatMap(Arrays::stream)</span>
<span class="fc" id="L792">                .forEach(nodeTypes::add);</span>

<span class="fc" id="L794">            final List&lt;URI&gt; types = nodeTypes.stream()</span>
<span class="fc" id="L795">                .map(uncheck(NodeType::getName))</span>
<span class="fc" id="L796">                .filter(hasInternalNamespace.negate())</span>
<span class="fc" id="L797">                .distinct()</span>
<span class="fc" id="L798">                .map(nodeTypeNameToURI)</span>
<span class="fc" id="L799">                .peek(x -&gt; LOGGER.debug(&quot;node has rdf:type {}&quot;, x))</span>
<span class="fc" id="L800">                .collect(Collectors.toList());</span>

<span class="fc" id="L802">            return types;</span>

<span class="nc" id="L804">        } catch (final PathNotFoundException e) {</span>
<span class="nc" id="L805">            throw new PathNotFoundRuntimeException(e);</span>
<span class="nc" id="L806">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L807">            throw new RepositoryRuntimeException(e);</span>
        }
    }

<span class="fc" id="L811">    private final Function&lt;String, URI&gt; nodeTypeNameToURI = uncheck(name -&gt; {</span>
<span class="fc" id="L812">        final String prefix = name.split(&quot;:&quot;)[0];</span>
<span class="fc" id="L813">        final String typeName = name.split(&quot;:&quot;)[1];</span>
<span class="fc" id="L814">        final String namespace = getSession().getWorkspace().getNamespaceRegistry().getURI(prefix);</span>
<span class="fc" id="L815">        return URI.create(getRDFNamespaceForJcrNamespace(namespace) + typeName);</span>
    });

    /* (non-Javadoc)
     * @see org.fcrepo.kernel.api.models.FedoraResource#updateProperties
     *     (org.fcrepo.kernel.api.identifiers.IdentifierConverter, java.lang.String, RdfStream)
     */
    @Override
    public void updateProperties(final IdentifierConverter&lt;Resource, FedoraResource&gt; idTranslator,
                                 final String sparqlUpdateStatement, final RdfStream originalTriples)
            throws MalformedRdfException, AccessDeniedException {

<span class="fc" id="L827">        final Model model = originalTriples.collect(toModel());</span>

<span class="fc" id="L829">        final FedoraResource described = getDescribedResource();</span>

<span class="fc" id="L831">        final UpdateRequest request = create(sparqlUpdateStatement,</span>
<span class="fc" id="L832">                idTranslator.reverse().convert(described).toString());</span>

<span class="fc" id="L834">        final Collection&lt;ConstraintViolationException&gt; errors = validateUpdateRequest(request);</span>

<span class="fc" id="L836">        final NamespaceRegistry namespaceRegistry = getNamespaceRegistry(getSession());</span>

<span class="fc" id="L838">        request.getPrefixMapping().getNsPrefixMap().forEach(</span>
            (k,v) -&gt; {
                try {
<span class="fc" id="L841">                    LOGGER.debug(&quot;Prefix mapping is key:{} -&gt; value:{}&quot;, k, v);</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">                    if (Arrays.asList(namespaceRegistry.getPrefixes()).contains(k)</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">                        &amp;&amp;  !v.equals(namespaceRegistry.getURI(k))) {</span>

<span class="fc" id="L845">                        final String namespaceURI = namespaceRegistry.getURI(k);</span>
<span class="fc" id="L846">                        LOGGER.debug(&quot;Prefix has already been defined: {}:{}&quot;, k, namespaceURI);</span>
<span class="fc" id="L847">                        throw new InvalidPrefixException(&quot;Prefix already exists as: &quot; + k + &quot; -&gt; &quot; + namespaceURI);</span>
                   }

<span class="nc" id="L850">                } catch (final RepositoryException e) {</span>
<span class="nc" id="L851">                    throw new RepositoryRuntimeException(e);</span>
<span class="fc" id="L852">                }</span>
<span class="fc" id="L853">           });</span>

<span class="fc" id="L855">        throwConstraintErrorsIfPresent(errors);</span>

<span class="fc" id="L857">        checkInteractionModel(request);</span>

<span class="fc" id="L859">        final FilteringJcrPropertyStatementListener listener = new FilteringJcrPropertyStatementListener(</span>
<span class="fc" id="L860">                idTranslator, getSession(), idTranslator.reverse().convert(described).asNode());</span>

<span class="fc" id="L862">        model.register(listener);</span>

        // If this resource's structural parent is an IndirectContainer, check whether the
        // ldp:insertedContentRelation property is present in the stream of changed triples.
        // If so, set the propertyChanged value to true.
<span class="fc" id="L867">        final AtomicBoolean propertyChanged = new AtomicBoolean();</span>
<span class="fc" id="L868">        ldpInsertedContentProperty(getNode()).ifPresent(resource -&gt; {</span>
<span class="fc" id="L869">            model.register(new PropertyChangedListener(resource, propertyChanged));</span>
<span class="fc" id="L870">        });</span>

<span class="fc" id="L872">        model.setNsPrefixes(request.getPrefixMapping());</span>
<span class="fc" id="L873">        execute(request, model);</span>

<span class="fc" id="L875">        removeEmptyFragments();</span>

<span class="fc" id="L877">        listener.assertNoExceptions();</span>

        try {
<span class="fc" id="L880">            touch(propertyChanged.get(), listener.getAddedCreatedDate(), listener.getAddedCreatedBy(),</span>
<span class="fc" id="L881">                    listener.getAddedModifiedDate(), listener.getAddedModifiedBy());</span>
<span class="nc" id="L882">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L883">            throw new RuntimeException(e);</span>
<span class="fc" id="L884">        }</span>
<span class="fc" id="L885">    }</span>


    private Optional&lt;String&gt; getResourceInteraction() {
<span class="fc" id="L889">        return INTERACTION_MODELS.stream().filter(x -&gt; hasType(x)).findFirst();</span>
    }

    private void checkInteractionModel(final Triple triple, final Optional&lt;String&gt; resourceInteractionModel) {
        // check for interaction model change violation
<span class="fc" id="L894">        final String interactionModel = getInteractionModel.apply(triple);</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">        if (StringUtils.isNotBlank(interactionModel) &amp;&amp;</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">            !interactionModel.equals(resourceInteractionModel.get())) {</span>
<span class="nc" id="L897">            throw new InteractionModelViolationException(&quot;Changing the resource's interaction model from &quot;</span>
<span class="nc" id="L898">                                                         + resourceInteractionModel.get() + &quot; to &quot; + interactionModel +</span>
                                                         &quot; is not allowed!&quot;);
        }
<span class="fc" id="L901">    }</span>

    /*
     * Check the SPARQLUpdate statements for the invalid interaction model changes.
     * @param request the UpdateRequest
     * @throws InteractionModelViolationException when attempting to change the interaction model
     */
    private void checkInteractionModel(final UpdateRequest request)  {
<span class="fc" id="L909">        final List&lt;Quad&gt; deleteQuads = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L910">        final List&lt;Quad&gt; updateQuads = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L912" title="All 2 branches covered.">        for (final Update operation : request.getOperations()) {</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">            if (operation instanceof UpdateModify) {</span>
<span class="fc" id="L914">                final UpdateModify op = (UpdateModify) operation;</span>
<span class="fc" id="L915">                deleteQuads.addAll(op.getDeleteQuads());</span>
<span class="fc" id="L916">                updateQuads.addAll(op.getInsertQuads());</span>
<span class="fc bfc" id="L917" title="All 2 branches covered.">            } else if (operation instanceof UpdateData) {</span>
<span class="fc" id="L918">                final UpdateData op = (UpdateData) operation;</span>
<span class="fc" id="L919">                updateQuads.addAll(op.getQuads());</span>
<span class="pc bpc" id="L920" title="1 of 2 branches missed.">            } else if (operation instanceof UpdateDeleteWhere) {</span>
<span class="fc" id="L921">                final UpdateDeleteWhere op = (UpdateDeleteWhere) operation;</span>
<span class="fc" id="L922">                deleteQuads.addAll(op.getQuads());</span>
            }

<span class="fc" id="L925">            final Optional&lt;String&gt; resourceInteractionModel = getResourceInteraction();</span>
<span class="fc bfc" id="L926" title="All 2 branches covered.">            if (resourceInteractionModel.isPresent()) {</span>
<span class="fc" id="L927">                updateQuads.forEach(e -&gt; {</span>
                    // check for interaction model change violation
<span class="fc" id="L929">                    checkInteractionModel(e.asTriple(), resourceInteractionModel);</span>
<span class="fc" id="L930">                });</span>
            }

<span class="fc" id="L933">            deleteQuads.forEach(e -&gt; {</span>
<span class="fc" id="L934">                final String interactionModel = getInteractionModel.apply(e.asTriple());</span>
<span class="pc bpc" id="L935" title="1 of 2 branches missed.">                if (StringUtils.isNotBlank(interactionModel)) {</span>
<span class="nc" id="L936">                    throw new InteractionModelViolationException(&quot;Deleting the interaction model &quot;</span>
                            + interactionModel + &quot; is not allowed!&quot;);
                }
<span class="fc" id="L939">            });</span>
<span class="fc" id="L940">        }</span>
<span class="fc" id="L941">    }</span>

    /*
     * Dynamic function to extract the interaction model from Triple.
     */
<span class="fc" id="L946">    private static final Function&lt;Triple, String&gt; getInteractionModel =</span>
<span class="fc" id="L947">            uncheck( x -&gt; {</span>
<span class="pc bpc" id="L948" title="1 of 4 branches missed.">                if (x.getPredicate().hasURI(RDF_NAMESPACE + &quot;type&quot;) &amp;&amp; x.getObject().isURI()</span>
<span class="pc bpc" id="L949" title="1 of 2 branches missed.">                        &amp;&amp; INTERACTION_MODELS.contains((x.getObject().getURI().replace(LDP_NAMESPACE, &quot;ldp:&quot;)))) {</span>
<span class="nc" id="L950">                return x.getObject().getURI().replace(LDP_NAMESPACE, &quot;ldp:&quot;);</span>
            }
<span class="fc" id="L952">            return null;</span>
    });

    @Override
    public RdfStream getTriples(final IdentifierConverter&lt;Resource, FedoraResource&gt; idTranslator,
                                final TripleCategory context) {
<span class="fc" id="L958">        return getTriples(idTranslator, singleton(context));</span>
    }

    @Override
    public RdfStream getTriples(final IdentifierConverter&lt;Resource, FedoraResource&gt; idTranslator,
                                final Set&lt;? extends TripleCategory&gt; contexts) {

<span class="fc" id="L965">        Stream&lt;Triple&gt; triples = contexts.stream()</span>
<span class="fc" id="L966">                .filter(contextMap::containsKey)</span>
<span class="fc" id="L967">                .map(x -&gt; contextMap.get(x).apply(this).apply(idTranslator).apply(contexts.contains(MINIMAL)))</span>
<span class="fc" id="L968">                .reduce(empty(), Stream::concat);</span>

        // if a memento, convert subjects to original resource and object references from referential integrity
        // ignoring internal URL back the original external URL.
<span class="fc bfc" id="L972" title="All 2 branches covered.">        if (isMemento()) {</span>
<span class="fc" id="L973">            final IdentifierConverter&lt;Resource, FedoraResource&gt; internalIdTranslator</span>
<span class="fc" id="L974">                    = new InternalIdentifierTranslator(getSession());</span>
<span class="fc" id="L975">            triples = triples.map(convertMementoReferences(idTranslator, internalIdTranslator));</span>
        }

<span class="fc" id="L978">        return new DefaultRdfStream(idTranslator.reverse().convert(this).asNode(), triples);</span>
    }

    /* (non-Javadoc)
     * @see org.fcrepo.kernel.api.models.FedoraResource#isNew()
     */
    @Override
    public Boolean isNew() {
<span class="nc" id="L986">        return node.isNew();</span>
    }

    /* (non-Javadoc)
     * @see org.fcrepo.kernel.api.models.FedoraResource#replaceProperties
     *     (org.fcrepo.kernel.api.identifiers.IdentifierConverter, org.apache.jena.rdf.model.Model,
     *     org.fcrepo.kernel.api.RdfStream)
     */
    @Override
    public void replaceProperties(final IdentifierConverter&lt;Resource, FedoraResource&gt; idTranslator,
        final Model inputModel, final RdfStream originalTriples) throws MalformedRdfException {

        // remove any statements that update &quot;relaxed&quot; server-managed triples so they can be updated separately
<span class="fc" id="L999">        final List&lt;Statement&gt; filteredStatements = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1000">        final StmtIterator it = inputModel.listStatements();</span>
<span class="fc" id="L1001">        final Optional&lt;String&gt; resourceInteractionModel = getResourceInteraction();</span>
<span class="fc" id="L1002">        final boolean hasInteractionModel = resourceInteractionModel.isPresent();</span>
<span class="fc bfc" id="L1003" title="All 2 branches covered.">        while (it.hasNext()) {</span>
<span class="fc" id="L1004">            final Statement next = it.next();</span>
<span class="pc bpc" id="L1005" title="1 of 2 branches missed.">            if (RdfLexicon.isRelaxed.test(next.getPredicate())) {</span>
<span class="nc" id="L1006">                filteredStatements.add(next);</span>
<span class="nc" id="L1007">                it.remove();</span>
            } else {
<span class="pc bpc" id="L1009" title="1 of 2 branches missed.">                if (hasInteractionModel) {</span>
<span class="nc" id="L1010">                    checkInteractionModel(next.asTriple(), resourceInteractionModel);</span>
                }
            }
<span class="fc" id="L1013">        }</span>
        // remove any &quot;relaxed&quot; server-managed triples from the existing triples
<span class="fc" id="L1015">        final RdfStream filteredTriples = new DefaultRdfStream(originalTriples.topic(),</span>
<span class="pc bpc" id="L1016" title="1 of 2 branches missed.">                originalTriples.filter(triple -&gt; !isRelaxed.test(createProperty(triple.getPredicate().getURI()))));</span>



<span class="fc" id="L1020">        try (final RdfStream replacementStream =</span>
<span class="fc" id="L1021">                new DefaultRdfStream(idTranslator.reverse().convert(this).asNode())) {</span>

<span class="fc" id="L1023">            final GraphDifferencer differencer =</span>
                new GraphDifferencer(inputModel, filteredTriples);

<span class="fc" id="L1026">            final StringBuilder exceptions = new StringBuilder();</span>
<span class="fc" id="L1027">            try (final DefaultRdfStream diffStream =</span>
<span class="fc" id="L1028">                    new DefaultRdfStream(replacementStream.topic(), differencer.difference())) {</span>
<span class="fc" id="L1029">                new RdfRemover(idTranslator, getSession(), diffStream).consume();</span>
<span class="nc" id="L1030">            } catch (final MalformedRdfException e) {</span>
<span class="nc" id="L1031">                exceptions.append(e.getMessage());</span>
<span class="nc" id="L1032">                exceptions.append(&quot;\n&quot;);</span>
<span class="nc" id="L1033">            } catch (final ConstraintViolationException e) {</span>
<span class="nc" id="L1034">                throw e;</span>
<span class="pc" id="L1035">            }</span>

<span class="fc" id="L1037">            try (</span>
<span class="fc" id="L1038">                final DefaultRdfStream notCommonStream =</span>
<span class="fc" id="L1039">                        new DefaultRdfStream(replacementStream.topic(), differencer.notCommon());</span>
<span class="fc" id="L1040">                final DefaultRdfStream testStream =</span>
<span class="fc" id="L1041">                        new DefaultRdfStream(replacementStream.topic(), differencer.notCommon())) {</span>

                // do some very basic validation to catch invalid RDF
                // this uses the same checks that updateProperties() uses
<span class="fc" id="L1045">                final Collection&lt;ConstraintViolationException&gt; errors = testStream</span>
<span class="fc" id="L1046">                        .flatMap(FedoraResourceImpl::validateTriple)</span>
<span class="fc bfc" id="L1047" title="All 2 branches covered.">                        .filter(x -&gt; x != null)</span>
<span class="fc" id="L1048">                        .collect(Collectors.toList());</span>

<span class="fc" id="L1050">                throwConstraintErrorsIfPresent(errors);</span>

<span class="fc" id="L1052">                new RdfAdder(idTranslator, getSession(), notCommonStream, inputModel.getNsPrefixMap()).consume();</span>
<span class="fc" id="L1053">            } catch (final MalformedRdfException e) {</span>
<span class="fc" id="L1054">                exceptions.append(e.getMessage());</span>
<span class="nc" id="L1055">            } catch (final ConstraintViolationException e) {</span>
<span class="nc" id="L1056">                throw e;</span>
<span class="fc" id="L1057">            }</span>

            // If this resource's structural parent is an IndirectContainer, check whether the
            // ldp:insertedContentRelation property is present in the stream of changed triples.
            // If so, set the propertyChanged value to true.
<span class="fc" id="L1062">            final AtomicBoolean propertyChanged = new AtomicBoolean();</span>
<span class="fc" id="L1063">            ldpInsertedContentProperty(getNode()).ifPresent(resource -&gt; {</span>
<span class="nc" id="L1064">                propertyChanged.set(differencer.notCommon().map(Triple::getPredicate).anyMatch(resource::equals));</span>
<span class="nc" id="L1065">            });</span>

<span class="fc" id="L1067">            removeEmptyFragments();</span>

<span class="fc bfc" id="L1069" title="All 2 branches covered.">            if (exceptions.length() &gt; 0) {</span>
<span class="fc" id="L1070">                throw new MalformedRdfException(exceptions.toString());</span>
            }

            try {
<span class="fc" id="L1074">                touch(propertyChanged.get(), RelaxedPropertiesHelper.getCreatedDate(filteredStatements),</span>
<span class="fc" id="L1075">                        RelaxedPropertiesHelper.getCreatedBy(filteredStatements),</span>
<span class="fc" id="L1076">                        RelaxedPropertiesHelper.getModifiedDate(filteredStatements),</span>
<span class="fc" id="L1077">                        RelaxedPropertiesHelper.getModifiedBy(filteredStatements));</span>
<span class="nc" id="L1078">            } catch (final RepositoryException e) {</span>
<span class="nc" id="L1079">                throw new RuntimeException(e);</span>
<span class="fc" id="L1080">            }</span>
        }
<span class="fc" id="L1082">    }</span>

    private void throwConstraintErrorsIfPresent(final Collection&lt;ConstraintViolationException&gt; errors) {
<span class="fc bfc" id="L1085" title="All 2 branches covered.">        if (!errors.isEmpty()) {</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">            if (errors.size() == 1) {</span>
                //throw the original constraint error if there
                //is only one so that the constraints document that
                //is returned to the user is as accurate as possible.
<span class="fc" id="L1090">                throw errors.stream().findFirst().get();</span>
            } else {
<span class="fc" id="L1092">                throw new ConstraintViolationException(</span>
<span class="fc" id="L1093">                    errors.stream().map(Exception::getMessage).collect(joining(&quot;,\n&quot;)));</span>
            }
        }
<span class="fc" id="L1096">    }</span>

    /**
     * Touches a resource to ensure that the implicitly updated properties are updated if
     * not explicitly set.
     * @param includeMembershipResource true if this touch should propagate through to
     *                                  ldp membership resources
     * @param createdDate the date to which the created date should be set or null to leave it unchanged
     * @param createdUser the user to which the created by should be set or null to leave it unchanged
     * @param modifiedDate the date to which the modified date should be set or null to use now
     * @param modifyingUser the user making the modification or null to use the current user
     * @throws RepositoryException an error occurs while updating the repository
     */
    @VisibleForTesting
    public void touch(final boolean includeMembershipResource, final Calendar createdDate, final String createdUser,
                      final Calendar modifiedDate, final String modifyingUser) throws RepositoryException {
<span class="fc" id="L1112">        FedoraTypesUtils.touch(getNode(), createdDate, createdUser, modifiedDate, modifyingUser);</span>

        // If the ldp:insertedContentRelation property was changed, update the
        // ldp:membershipResource resource.
<span class="fc bfc" id="L1116" title="All 2 branches covered.">        if (includeMembershipResource) {</span>
<span class="fc" id="L1117">            touchLdpMembershipResource(getNode(), modifiedDate, modifyingUser);</span>
        }
<span class="fc" id="L1119">    }</span>

    private void removeEmptyFragments() {
        try {
<span class="fc bfc" id="L1123" title="All 2 branches covered.">            if (node.hasNode(&quot;#&quot;)) {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1125">                final Iterator&lt;Node&gt; nodes = node.getNode(&quot;#&quot;).getNodes();</span>
<span class="fc" id="L1126">                nodes.forEachRemaining(n -&gt; {</span>
                    try {
                        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1129">                        final Iterator&lt;Property&gt; properties = n.getProperties();</span>
<span class="fc" id="L1130">                        final boolean hasUserProps = iteratorToStream(properties).map(propertyConverter::convert)</span>
<span class="fc bfc" id="L1131" title="All 2 branches covered.">                            .filter(p -&gt; !jcrProperties.contains(p))</span>
<span class="fc" id="L1132">                            .anyMatch(isManagedPredicate.negate());</span>

<span class="fc" id="L1134">                        final boolean hasUserTypes = Arrays.stream(n.getMixinNodeTypes())</span>
<span class="fc" id="L1135">                            .map(uncheck(NodeType::getName)).filter(hasInternalNamespace.negate())</span>
<span class="fc" id="L1136">                            .map(uncheck(type -&gt;</span>
<span class="fc" id="L1137">                                getSession().getWorkspace().getNamespaceRegistry().getURI(type.split(&quot;:&quot;)[0])))</span>
<span class="fc" id="L1138">                            .anyMatch(isManagedNamespace.negate());</span>

<span class="fc bfc" id="L1140" title="All 6 branches covered.">                        if (!hasUserProps &amp;&amp; !hasUserTypes &amp;&amp; !n.getWeakReferences().hasNext() &amp;&amp;</span>
<span class="pc bpc" id="L1141" title="1 of 2 branches missed.">                                !n.getReferences().hasNext()) {</span>
<span class="fc" id="L1142">                            LOGGER.debug(&quot;Removing empty hash URI node: {}&quot;, n.getName());</span>
<span class="fc" id="L1143">                            n.remove();</span>
                        }
<span class="nc" id="L1145">                    } catch (final RepositoryException ex) {</span>
<span class="nc" id="L1146">                        throw new RepositoryRuntimeException(&quot;Error removing empty fragments&quot;, ex);</span>
<span class="fc" id="L1147">                    }</span>
<span class="fc" id="L1148">                });</span>
            }
<span class="nc" id="L1150">        } catch (final RepositoryException ex) {</span>
<span class="nc" id="L1151">            throw new RepositoryRuntimeException(&quot;Error removing empty fragments&quot;, ex);</span>
<span class="fc" id="L1152">        }</span>
<span class="fc" id="L1153">    }</span>

    /* (non-Javadoc)
     * @see org.fcrepo.kernel.api.models.FedoraResource#getEtagValue()
     */
    @Override
    public String getEtagValue() {
<span class="fc" id="L1160">        final Instant lastModifiedDate = getLastModifiedDate();</span>

<span class="pc bpc" id="L1162" title="1 of 2 branches missed.">        if (lastModifiedDate != null) {</span>
<span class="fc" id="L1163">            return sha1Hex(getPath() + lastModifiedDate.toEpochMilli());</span>
        }
<span class="nc" id="L1165">        return &quot;&quot;;</span>
    }


    /**
     * Returns a function that converts the subject to the original URI and the object of a triple from an
     * undereferenceable internal identifier back to it's original external resource path.
     * If the object is not an internal identifier, the object is returned.
     *
     * @param translator a converter to get the external resource identifier from a path
     * @param internalTranslator a converter to get the path from an internal identifier
     * @return a function to convert triples
     */
     protected static Function&lt;Triple, Triple&gt; convertMementoReferences(
            final IdentifierConverter&lt;Resource, FedoraResource&gt; translator,
            final IdentifierConverter&lt;Resource, FedoraResource&gt; internalTranslator) {

<span class="fc" id="L1182">         return t -&gt; {</span>
<span class="fc" id="L1183">            final String subjectURI = t.getSubject().getURI();</span>
            // Remove any hash components from the subject while locating the original resource
            final String subjectPath;
<span class="fc" id="L1186">            final int hashIndex = subjectURI.indexOf(&quot;#&quot;);</span>
<span class="pc bpc" id="L1187" title="1 of 2 branches missed.">            if (hashIndex != -1) {</span>
<span class="nc" id="L1188">                subjectPath = subjectURI.substring(0, hashIndex);</span>
            } else {
<span class="fc" id="L1190">                subjectPath = subjectURI;</span>
            }
<span class="fc" id="L1192">            final Resource subject = createResource(subjectPath);</span>
<span class="fc" id="L1193">             final FedoraResource subjResc = translator.convert(subject);</span>
<span class="fc" id="L1194">            org.apache.jena.graph.Node subjectNode =</span>
<span class="fc" id="L1195">                 translator.reverse().convert(subjResc.getOriginalResource()).asNode();</span>

            // Add the hash component back into the subject uri. Note: we cannot convert the memento hash URI
            // to the original as a jcr node, as the hash may not exist for the original at this point.
<span class="pc bpc" id="L1199" title="1 of 2 branches missed.">            if (hashIndex != -1) {</span>
<span class="nc" id="L1200">                subjectNode = createURI(subjectNode.getURI() + subjectURI.substring(hashIndex));</span>
            }

<span class="fc" id="L1203">             org.apache.jena.graph.Node objectNode = t.getObject();</span>
<span class="fc bfc" id="L1204" title="All 2 branches covered.">             if (t.getObject().isURI()) {</span>
<span class="fc" id="L1205">                 final Resource object = createResource(t.getObject().getURI());</span>
<span class="fc bfc" id="L1206" title="All 2 branches covered.">                 if (internalTranslator.inDomain(object)) {</span>
<span class="fc" id="L1207">                     final FedoraResource objResc = internalTranslator.convert(object);</span>
<span class="fc" id="L1208">                     final Resource newObject = translator.reverse().convert(objResc);</span>
<span class="fc" id="L1209">                     objectNode = newObject.asNode();</span>
                 }
             }

<span class="fc" id="L1213">             return new Triple(subjectNode, t.getPredicate(), objectNode);</span>
         };
    }

    private static Collection&lt;ConstraintViolationException&gt; validateUpdateRequest(final UpdateRequest request) {
<span class="fc" id="L1218">        return request.getOperations().stream()</span>
<span class="fc" id="L1219">                .flatMap(x -&gt; {</span>
<span class="fc bfc" id="L1220" title="All 2 branches covered.">                    if (x instanceof UpdateModify) {</span>
<span class="fc" id="L1221">                        final UpdateModify y = (UpdateModify) x;</span>
<span class="fc" id="L1222">                        return concat(y.getInsertQuads().stream(), y.getDeleteQuads().stream());</span>
<span class="fc bfc" id="L1223" title="All 2 branches covered.">                    } else if (x instanceof UpdateData) {</span>
<span class="fc" id="L1224">                        return ((UpdateData) x).getQuads().stream();</span>
<span class="pc bpc" id="L1225" title="1 of 2 branches missed.">                    } else if (x instanceof UpdateDeleteWhere) {</span>
<span class="fc" id="L1226">                        return ((UpdateDeleteWhere) x).getQuads().stream();</span>
                    } else {
<span class="nc" id="L1228">                        return empty();</span>
                    }
                })
<span class="fc" id="L1231">                .map(x -&gt; x.asTriple())</span>
<span class="fc" id="L1232">                .flatMap(FedoraResourceImpl::validateTriple)</span>
<span class="fc bfc" id="L1233" title="All 2 branches covered.">                .filter(x -&gt; x != null)</span>
<span class="fc" id="L1234">                .collect(Collectors.toList());</span>
    }

    private static Stream&lt;ConstraintViolationException&gt; validateTriple(final Triple triple) {
<span class="fc" id="L1238">        return tripleValidators.stream().map(x -&gt; x.apply(triple));</span>
    }

    @Override
    public boolean equals(final Object object) {
<span class="pc bpc" id="L1243" title="1 of 2 branches missed.">        if (object instanceof FedoraResourceImpl) {</span>
<span class="fc" id="L1244">            return ((FedoraResourceImpl) object).getNode().equals(this.getNode());</span>
        }
<span class="nc" id="L1246">        return false;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1251">        return getNode().hashCode();</span>
    }

    protected Session getSession() {
        try {
<span class="fc" id="L1256">            return getNode().getSession();</span>
<span class="nc" id="L1257">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L1258">            throw new RepositoryRuntimeException(e);</span>
        }
    }

    @Override
    public String toString() {
<span class="nc" id="L1264">        return getNode().toString();</span>
    }

    @Override
    public void addType(final String type) {
        try {
<span class="pc bpc" id="L1270" title="1 of 2 branches missed.">            if (node.canAddMixin(type)) {</span>
<span class="fc" id="L1271">                node.addMixin(type);</span>
            }
<span class="nc" id="L1273">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L1274">            throw new RepositoryRuntimeException(e);</span>
<span class="fc" id="L1275">        }</span>
<span class="fc" id="L1276">    }</span>

    protected Property getProperty(final String relPath) {
        try {
<span class="fc" id="L1280">            return getNode().getProperty(relPath);</span>
<span class="nc" id="L1281">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L1282">            throw new RepositoryRuntimeException(e);</span>
        }
    }

    /**
     * A method that takes a Triple and returns a Triple that is the correct representation of
     * that triple for the given resource.  The current implementation of this method is used by
     * {@link PropertiesRdfContext} to replace the reported {@link org.fcrepo.kernel.api.RdfLexicon#LAST_MODIFIED_DATE}
     * with the one produced by {@link #getLastModifiedDate}.
     * @param r the Fedora resource
     * @param translator a converter to get the external identifier from a jcr node
     * @return a function to convert triples
     */
    public static Function&lt;Triple, Triple&gt; fixDatesIfNecessary(final FedoraResource r,
                                                      final Converter&lt;Node, Resource&gt; translator) {
<span class="fc" id="L1297">        return t -&gt; {</span>
<span class="fc bfc" id="L1298" title="All 2 branches covered.">            if (t.getPredicate().toString().equals(LAST_MODIFIED_DATE.toString())</span>
<span class="pc bpc" id="L1299" title="1 of 2 branches missed.">                    &amp;&amp; t.getSubject().equals(translator.convert(getJcrNode(r)).asNode())) {</span>
<span class="fc" id="L1300">                final Calendar c = new Calendar.Builder().setInstant(r.getLastModifiedDate().toEpochMilli()).build();</span>
<span class="fc" id="L1301">                return new Triple(t.getSubject(), t.getPredicate(), createTypedLiteral(c).asNode());</span>
            }
<span class="fc" id="L1303">            return t;</span>
        };
    }

  @Override
  public FedoraResource findMementoByDatetime(final Instant mementoDatetime) {
<span class="pc bpc" id="L1309" title="1 of 2 branches missed.">      if (isOriginalResource()) {</span>
<span class="fc" id="L1310">            final FedoraResource timemap = this.getTimeMap();</span>
<span class="pc bpc" id="L1311" title="1 of 2 branches missed.">            if (timemap != null) {</span>
<span class="fc" id="L1312">                final Stream&lt;FedoraResource&gt; mementos = timemap.getChildren();</span>
                // Filter to mementos prior to mementoDatetime, then reduce to the nearest one
<span class="fc" id="L1314">                final Optional&lt;FedoraResource&gt; closest = mementos</span>
<span class="fc bfc" id="L1315" title="All 2 branches covered.">                        .filter(t -&gt; dateTimeDifference(mementoDatetime, t.getMementoDatetime()) &lt;= 0)</span>
<span class="fc" id="L1316">                        .reduce((a, b) -&gt;</span>
<span class="fc" id="L1317">                                dateTimeDifference(a.getMementoDatetime(), mementoDatetime)</span>
<span class="pc bpc" id="L1318" title="1 of 2 branches missed.">                                &lt;= dateTimeDifference(b.getMementoDatetime(), mementoDatetime) ?</span>
                                        a : b);
<span class="fc bfc" id="L1320" title="All 2 branches covered.">                if (closest.isPresent()) {</span>
                    // Return the closest version older than the requested date.
<span class="fc" id="L1322">                    return closest.get();</span>
                } else {
                    // Otherwise you requested before the first version, so return the first version if it exists.
                    // If there are no Mementos return null.
<span class="fc" id="L1326">                    final Optional&lt;FedoraResource&gt; earliest =  timemap.getChildren().min(</span>
<span class="fc" id="L1327">                            Comparator.comparing(FedoraResource::getMementoDatetime));</span>
<span class="fc" id="L1328">                    return earliest.orElse(null);</span>
                }
            }
      }
<span class="nc" id="L1332">      return null;</span>
  }

    /**
     * Calculate the difference between two datetime to the unit.
     *
     * @param d1 first datetime
     * @param d2 second datetime
     * @return the difference
     */
  private static long dateTimeDifference(final Temporal d1, final Temporal d2) {
<span class="fc" id="L1343">      return ChronoUnit.SECONDS.between(d1, d2);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>