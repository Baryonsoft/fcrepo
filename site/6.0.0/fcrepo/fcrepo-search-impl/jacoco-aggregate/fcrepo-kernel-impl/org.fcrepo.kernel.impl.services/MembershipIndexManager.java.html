<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>MembershipIndexManager.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Fedora Repository Search Impl</a> &gt; <a href="../index.html" class="el_bundle">fcrepo-kernel-impl</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.kernel.impl.services</a> &gt; <span class="el_source">MembershipIndexManager.java</span></div><h1>MembershipIndexManager.java</h1><pre class="source lang-java linenums">/*
 * Licensed to DuraSpace under one or more contributor license agreements.
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * DuraSpace licenses this file to you under the Apache License,
 * Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.fcrepo.kernel.impl.services;

import static org.slf4j.LoggerFactory.getLogger;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Queue;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.function.Consumer;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import javax.annotation.PostConstruct;
import javax.inject.Inject;
import javax.sql.DataSource;

import org.fcrepo.common.db.DbPlatform;
import org.fcrepo.kernel.api.Transaction;
import org.fcrepo.kernel.api.identifiers.FedoraId;

import org.apache.jena.graph.Node;
import org.apache.jena.graph.NodeFactory;
import org.apache.jena.graph.Triple;
import org.slf4j.Logger;
import org.springframework.jdbc.core.RowCallbackHandler;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * Manager for the membership index
 *
 * @author bbpennel
 */
@Component
<span class="fc" id="L62">public class MembershipIndexManager {</span>
<span class="fc" id="L63">    private static final Logger log = getLogger(MembershipIndexManager.class);</span>

<span class="fc" id="L65">    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);</span>
<span class="fc" id="L66">    private static final Timestamp NO_START_TIMESTAMP = Timestamp.from(Instant.parse(&quot;1000-01-01T00:00:00.000Z&quot;));</span>

    private static final String ADD_OPERATION = &quot;add&quot;;
    private static final String DELETE_OPERATION = &quot;delete&quot;;
    private static final String FORCE_FLAG = &quot;force&quot;;

    private static final String TX_ID_PARAM = &quot;txId&quot;;
    private static final String SUBJECT_ID_PARAM = &quot;subjectId&quot;;
    private static final String NO_END_TIME_PARAM = &quot;noEndTime&quot;;
    private static final String ADD_OP_PARAM = &quot;addOp&quot;;
    private static final String DELETE_OP_PARAM = &quot;deleteOp&quot;;
    private static final String MEMENTO_TIME_PARAM = &quot;mementoTime&quot;;
    private static final String PROPERTY_PARAM = &quot;property&quot;;
    private static final String TARGET_ID_PARAM = &quot;targetId&quot;;
    private static final String SOURCE_ID_PARAM = &quot;sourceId&quot;;
    private static final String PROXY_ID_PARAM = &quot;proxyId&quot;;
    private static final String START_TIME_PARAM = &quot;startTime&quot;;
    private static final String END_TIME_PARAM = &quot;endTime&quot;;
    private static final String LAST_UPDATED_PARAM = &quot;lastUpdated&quot;;
    private static final String OPERATION_PARAM = &quot;operation&quot;;
    private static final String FORCE_PARAM = &quot;forceFlag&quot;;
    private static final String LIMIT_PARAM = &quot;limit&quot;;
    private static final String OFFSET_PARAM = &quot;offSet&quot;;

    private static final String SELECT_ALL_MEMBERSHIP = &quot;SELECT * FROM membership&quot;;

    private static final String SELECT_ALL_OPERATIONS = &quot;SELECT * FROM membership_tx_operations&quot;;

    private static final String SELECT_MEMBERSHIP_IN_TX =
            &quot;SELECT property, object_id&quot; +
            &quot; FROM membership m&quot; +
            &quot; WHERE subject_id = :subjectId&quot; +
                &quot; AND end_time = :noEndTime&quot; +
                &quot; AND NOT EXISTS (&quot; +
                    &quot; SELECT 1&quot; +
                    &quot; FROM membership_tx_operations mto&quot; +
                    &quot; WHERE mto.subject_id = :subjectId&quot; +
                        &quot; AND mto.source_id = m.source_id&quot; +
                        &quot; AND mto.object_id = m.object_id&quot; +
                        &quot; AND mto.tx_id = :txId&quot; +
                        &quot; AND mto.operation = :deleteOp)&quot; +
            &quot; UNION&quot; +
            &quot; SELECT property, object_id&quot; +
            &quot; FROM membership_tx_operations&quot; +
            &quot; WHERE subject_id = :subjectId&quot; +
                &quot; AND tx_id = :txId&quot; +
                &quot; AND end_time = :noEndTime&quot; +
                &quot; AND operation = :addOp&quot; +
            &quot; ORDER BY property, object_id&quot; +
            &quot; LIMIT :limit OFFSET :offSet&quot;;

    private static final String DIRECT_SELECT_MEMBERSHIP =
            &quot;SELECT property, object_id&quot; +
            &quot; FROM membership&quot; +
            &quot; WHERE subject_id = :subjectId&quot; +
                &quot; AND end_time = :noEndTime&quot; +
            &quot; ORDER BY property, object_id&quot; +
            &quot; LIMIT :limit OFFSET :offSet&quot;;

    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =
            &quot;SELECT property, object_id&quot; +
            &quot; FROM membership m&quot; +
            &quot; WHERE m.subject_id = :subjectId&quot; +
                &quot; AND m.start_time &lt;= :mementoTime&quot; +
                &quot; AND m.end_time &gt; :mementoTime&quot; +
                &quot; AND NOT EXISTS (&quot; +
                    &quot; SELECT 1&quot; +
                    &quot; FROM membership_tx_operations mto&quot; +
                    &quot; WHERE mto.subject_id = :subjectId&quot; +
                        &quot; AND mto.source_id = m.source_id&quot; +
                        &quot; AND mto.property = m.property&quot; +
                        &quot; AND mto.object_id = m.object_id&quot; +
                        &quot; AND mto.end_time &lt;= :mementoTime&quot; +
                        &quot; AND mto.tx_id = :txId&quot; +
                        &quot; AND mto.operation = :deleteOp)&quot; +
            &quot; UNION&quot; +
            &quot; SELECT property, object_id&quot; +
            &quot; FROM membership_tx_operations&quot; +
            &quot; WHERE subject_id = :subjectId&quot; +
                &quot; AND tx_id = :txId&quot; +
                &quot; AND start_time &lt;= :mementoTime&quot; +
                &quot; AND end_time &gt; :mementoTime&quot; +
                &quot; AND operation = :addOp&quot; +
            &quot; ORDER BY property, object_id&quot; +
            &quot; LIMIT :limit OFFSET :offSet&quot;;

    private static final String DIRECT_SELECT_MEMBERSHIP_MEMENTO =
            &quot;SELECT property, object_id&quot; +
            &quot; FROM membership&quot; +
            &quot; WHERE subject_id = :subjectId&quot; +
                &quot; AND start_time &lt;= :mementoTime&quot; +
                &quot; AND end_time &gt; :mementoTime&quot; +
            &quot; ORDER BY property, object_id&quot; +
            &quot; LIMIT :limit OFFSET :offSet&quot;;

    private static final String SELECT_LAST_UPDATED =
            &quot;SELECT max(last_updated) as last_updated&quot; +
            &quot; FROM membership&quot; +
            &quot; WHERE subject_id = :subjectId&quot;;

    // For mementos, use the start_time instead of last_updated as the
    // end_time reflects when the next version starts
    private static final String SELECT_LAST_UPDATED_MEMENTO =
            &quot;SELECT max(start_time)&quot; +
            &quot; FROM membership&quot; +
            &quot; WHERE subject_id = :subjectId&quot; +
                &quot; AND start_time &lt;= :mementoTime&quot; +
                &quot; AND end_time &gt; :mementoTime&quot;;

    private static final String SELECT_LAST_UPDATED_IN_TX =
            &quot;SELECT max(combined.updated) as last_updated&quot; +
            &quot; FROM (&quot; +
                &quot; SELECT max(last_updated) as updated&quot; +
                &quot; FROM membership m&quot; +
                &quot; WHERE subject_id = :subjectId&quot; +
                    &quot; AND NOT EXISTS (&quot; +
                        &quot; SELECT 1&quot; +
                        &quot; FROM membership_tx_operations mto&quot; +
                        &quot; WHERE mto.subject_id = :subjectId&quot; +
                            &quot; AND mto.source_id = m.source_id&quot; +
                            &quot; AND mto.object_id = m.object_id&quot; +
                            &quot; AND mto.tx_id = :txId&quot; +
                            &quot; AND mto.operation = :deleteOp)&quot; +
                &quot; UNION&quot; +
                &quot; SELECT max(last_updated) as updated&quot; +
                &quot; FROM membership_tx_operations&quot; +
                &quot; WHERE subject_id = :subjectId&quot; +
                    &quot; AND tx_id = :txId&quot; +
            &quot;) combined&quot;;

    private static final String INSERT_MEMBERSHIP_IN_TX =
            &quot;INSERT INTO membership_tx_operations (subject_id, property, object_id, source_id,&quot; +
                    &quot; proxy_id, start_time, end_time, last_updated, tx_id, operation)&quot; +
            &quot; VALUES (:subjectId, :property, :targetId, :sourceId,&quot; +
                    &quot; :proxyId, :startTime, :endTime, :lastUpdated, :txId, :operation)&quot;;

    private static final String DIRECT_INSERT_MEMBERSHIP =
            &quot;INSERT INTO membership (subject_id, property, object_id, source_id,&quot; +
                    &quot; proxy_id, start_time, end_time, last_updated)&quot; +
            &quot; VALUES (:subjectId, :property, :targetId, :sourceId,&quot; +
                    &quot; :proxyId, :startTime, :endTime, :lastUpdated)&quot;;

    private static final String END_EXISTING_MEMBERSHIP =
            &quot;INSERT INTO membership_tx_operations (subject_id, property, object_id, source_id,&quot; +
                    &quot; proxy_id, start_time, end_time, last_updated, tx_id, operation)&quot; +
            &quot; SELECT m.subject_id, m.property, m.object_id, m.source_id, m.proxy_id, m.start_time,&quot; +
                    &quot; :endTime, :endTime, :txId, :deleteOp&quot; +
            &quot; FROM membership m&quot; +
            &quot; WHERE m.source_id = :sourceId&quot; +
                &quot; AND m.proxy_id = :proxyId&quot; +
                &quot; AND m.end_time = :noEndTime&quot;;

    private static final String DIRECT_END_EXISTING_MEMBERSHIP =
            &quot;UPDATE membership SET end_time = :endTime, last_updated = :endTime&quot; +
            &quot; WHERE source_id = :sourceId&quot; +
                &quot; AND proxy_id = :proxyId&quot; +
                &quot; AND end_time = :noEndTime&quot;;

    private static final String CLEAR_FOR_PROXY_IN_TX =
            &quot;DELETE FROM membership_tx_operations&quot; +
            &quot; WHERE source_id = :sourceId&quot; +
                &quot; AND tx_id = :txId&quot; +
                &quot; AND proxy_id = :proxyId&quot; +
                &quot; AND force_flag IS NULL&quot;;

    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =
            &quot;DELETE FROM membership_tx_operations&quot; +
            &quot; WHERE source_id = :sourceId&quot; +
                &quot; AND tx_id = :txId&quot; +
                &quot; AND operation = :addOp&quot;;

    // Add &quot;delete&quot; entries for all existing membership from the given source, if not already deleted
    private static final String END_EXISTING_FOR_SOURCE =
            &quot;INSERT INTO membership_tx_operations (subject_id, property, object_id, source_id,&quot; +
                    &quot; proxy_id, start_time, end_time, last_updated, tx_id, operation)&quot; +
            &quot; SELECT subject_id, property, object_id, source_id,&quot; +
                    &quot; proxy_id, start_time, :endTime, :endTime, :txId, :deleteOp&quot; +
            &quot; FROM membership m&quot; +
            &quot; WHERE source_id = :sourceId&quot; +
                &quot; AND end_time = :noEndTime&quot; +
                &quot; AND NOT EXISTS (&quot; +
                    &quot; SELECT TRUE&quot; +
                    &quot; FROM membership_tx_operations mtx&quot; +
                    &quot; WHERE mtx.subject_id = m.subject_id&quot; +
                        &quot; AND mtx.property = m.property&quot; +
                        &quot; AND mtx.object_id = m.object_id&quot; +
                        &quot; AND mtx.source_id = m.source_id&quot; +
                        &quot; AND mtx.proxy_id = m.proxy_id&quot; +
                        &quot; AND mtx.operation = :deleteOp&quot; +
                    &quot;)&quot;;

    private static final String DIRECT_END_EXISTING_FOR_SOURCE =
            &quot;UPDATE membership SET end_time = :endTime, last_updated = :endTime&quot; +
                    &quot; WHERE source_id = :sourceId&quot; +
                    &quot; AND end_time = :noEndTime&quot;;

    private static final String DELETE_EXISTING_FOR_SOURCE_AFTER =
            &quot;INSERT INTO membership_tx_operations(subject_id, property, object_id, source_id,&quot; +
                    &quot; proxy_id, start_time, end_time, last_updated, tx_id, operation, force_flag)&quot; +
            &quot; SELECT subject_id, property, object_id, source_id, proxy_id, start_time, end_time,&quot; +
                    &quot; last_updated, :txId, :deleteOp, :forceFlag&quot; +
            &quot; FROM membership m&quot; +
            &quot; WHERE m.source_id = :sourceId&quot; +
                &quot; AND (m.start_time &gt;= :startTime&quot; +
                &quot; OR m.end_time &gt;= :startTime)&quot;;

    private static final String DIRECT_DELETE_EXISTING_FOR_SOURCE_AFTER =
            &quot;DELETE FROM membership&quot; +
                    &quot; WHERE source_id = :sourceId&quot; +
                    &quot; AND (start_time &gt;= :startTime&quot; +
                    &quot; OR end_time &gt;= :startTime)&quot;;

    private static final String DELETE_EXISTING_FOR_PROXY_AFTER =
            &quot;INSERT INTO membership_tx_operations(subject_id, property, object_id, source_id,&quot; +
                    &quot; proxy_id, start_time, end_time, last_updated, tx_id, operation, force_flag)&quot; +
            &quot; SELECT subject_id, property, object_id, source_id, proxy_id, start_time, end_time,&quot; +
                    &quot; last_updated, :txId, :deleteOp, :forceFlag&quot; +
            &quot; FROM membership m&quot; +
            &quot; WHERE m.proxy_id = :proxyId&quot; +
                &quot; AND (m.start_time &gt;= :startTime&quot; +
                &quot; OR m.end_time &gt;= :startTime)&quot;;

    private static final String DIRECT_DELETE_EXISTING_FOR_PROXY_AFTER =
            &quot;UPDATE membership SET end_time = :endTime, last_updated = :endTime&quot; +
            &quot; WHERE proxy_id = :proxyId&quot; +
                &quot; AND (start_time &gt;= :endTime&quot; +
                &quot; OR end_time &gt;= :endTime)&quot;;

    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =
            &quot;DELETE from membership&quot; +
            &quot; where source_id = :targetId&quot; +
                &quot; OR subject_id = :targetId&quot; +
                &quot; OR object_id = :targetId&quot;;

    private static final String PURGE_ALL_REFERENCES_TRANSACTION =
            &quot;DELETE from membership_tx_operations&quot; +
            &quot; WHERE tx_id = :txId&quot; +
                &quot; AND (source_id = :targetId&quot; +
                &quot; OR subject_id = :targetId&quot; +
                &quot; OR object_id = :targetId)&quot;;

    private static final String COMMIT_DELETES =
            &quot;DELETE from membership&quot; +
            &quot; WHERE EXISTS (&quot; +
                &quot; SELECT TRUE&quot; +
                &quot; FROM membership_tx_operations mto&quot; +
                &quot; WHERE mto.tx_id = :txId&quot; +
                    &quot; AND mto.operation = :deleteOp&quot; +
                    &quot; AND mto.force_flag = :forceFlag&quot; +
                    &quot; AND membership.source_id = mto.source_id&quot; +
                    &quot; AND membership.proxy_id = mto.proxy_id&quot; +
                    &quot; AND membership.subject_id = mto.subject_id&quot; +
                    &quot; AND membership.property = mto.property&quot; +
                    &quot; AND membership.object_id = mto.object_id&quot; +
                &quot; )&quot;;

    private static final String COMMIT_ENDS_H2 =
            &quot;UPDATE membership m&quot; +
            &quot; SET end_time = (&quot; +
                &quot; SELECT mto.end_time&quot; +
                &quot; FROM membership_tx_operations mto&quot; +
                &quot; WHERE mto.tx_id = :txId&quot; +
                    &quot; AND m.source_id = mto.source_id&quot; +
                    &quot; AND m.proxy_id = mto.proxy_id&quot; +
                    &quot; AND m.subject_id = mto.subject_id&quot; +
                    &quot; AND m.property = mto.property&quot; +
                    &quot; AND m.object_id = mto.object_id&quot; +
                    &quot; AND mto.operation = :deleteOp&quot; +
                &quot; ),&quot; +
                &quot; last_updated = (&quot; +
                    &quot; SELECT mto.end_time&quot; +
                    &quot; FROM membership_tx_operations mto&quot; +
                    &quot; WHERE mto.tx_id = :txId&quot; +
                        &quot; AND m.source_id = mto.source_id&quot; +
                        &quot; AND m.proxy_id = mto.proxy_id&quot; +
                        &quot; AND m.subject_id = mto.subject_id&quot; +
                        &quot; AND m.property = mto.property&quot; +
                        &quot; AND m.object_id = mto.object_id&quot; +
                        &quot; AND mto.operation = :deleteOp&quot; +
                    &quot; )&quot; +
            &quot; WHERE EXISTS (&quot; +
                &quot;SELECT TRUE&quot; +
                &quot; FROM membership_tx_operations mto&quot; +
                &quot; WHERE mto.tx_id = :txId&quot; +
                    &quot; AND mto.operation = :deleteOp&quot; +
                    &quot; AND m.source_id = mto.source_id&quot; +
                    &quot; AND m.proxy_id = mto.proxy_id&quot; +
                    &quot; AND m.subject_id = mto.subject_id&quot; +
                    &quot; AND m.property = mto.property&quot; +
                    &quot; AND m.object_id = mto.object_id&quot; +
                &quot; )&quot;;

    private static final String COMMIT_ENDS_POSTGRES =
            &quot;UPDATE membership&quot; +
            &quot; SET end_time = mto.end_time, last_updated = mto.end_time&quot; +
            &quot; FROM membership_tx_operations mto&quot; +
            &quot; WHERE mto.tx_id = :txId&quot; +
                &quot; AND mto.operation = :deleteOp&quot; +
                &quot; AND membership.source_id = mto.source_id&quot; +
                &quot; AND membership.proxy_id = mto.proxy_id&quot; +
                &quot; AND membership.subject_id = mto.subject_id&quot; +
                &quot; AND membership.property = mto.property&quot; +
                &quot; AND membership.object_id = mto.object_id&quot;;

    private static final String COMMIT_ENDS_MYSQL =
            &quot;UPDATE membership m&quot; +
            &quot; INNER JOIN membership_tx_operations mto ON&quot; +
                &quot; m.source_id = mto.source_id&quot; +
                &quot; AND m.proxy_id = mto.proxy_id&quot; +
                &quot; AND m.subject_id = mto.subject_id&quot; +
                &quot; AND m.property = mto.property&quot; +
                &quot; AND m.object_id = mto.object_id&quot; +
            &quot; SET m.end_time = mto.end_time, m.last_updated = mto.end_time&quot; +
            &quot; WHERE mto.tx_id = :txId&quot; +
                &quot; AND mto.operation = :deleteOp&quot;;

<span class="fc" id="L382">    private static final Map&lt;DbPlatform, String&gt; COMMIT_ENDS_MAP = Map.of(</span>
            DbPlatform.MYSQL, COMMIT_ENDS_MYSQL,
            DbPlatform.MARIADB, COMMIT_ENDS_MYSQL,
            DbPlatform.POSTGRESQL, COMMIT_ENDS_POSTGRES,
            DbPlatform.H2, COMMIT_ENDS_H2
    );

    // Transfer all &quot;add&quot; operations from tx to committed membership, unless the entry already exists
    private static final String COMMIT_ADDS =
            &quot;INSERT INTO membership&quot; +
            &quot; (subject_id, property, object_id, source_id, proxy_id, start_time, end_time, last_updated)&quot; +
            &quot; SELECT subject_id, property, object_id, source_id, proxy_id, start_time, end_time, last_updated&quot; +
            &quot; FROM membership_tx_operations mto&quot; +
            &quot; WHERE mto.tx_id = :txId&quot; +
                &quot; AND mto.operation = :addOp&quot; +
                &quot; AND NOT EXISTS (&quot; +
                    &quot; SELECT TRUE&quot; +
                    &quot; FROM membership m&quot; +
                    &quot; WHERE m.source_id = mto.source_id&quot; +
                        &quot; AND m.proxy_id = mto.proxy_id&quot; +
                        &quot; AND m.subject_id = mto.subject_id&quot; +
                        &quot; AND m.property = mto.property&quot; +
                        &quot; AND m.object_id = mto.object_id&quot; +
                        &quot; AND m.start_time = mto.start_time&quot; +
                        &quot; AND m.end_time = mto.end_time&quot; +
                &quot; )&quot;;

    private static final String DELETE_TRANSACTION =
            &quot;DELETE FROM membership_tx_operations&quot; +
            &quot; WHERE tx_id = :txId&quot;;

    private static final String TRUNCATE_MEMBERSHIP = &quot;TRUNCATE TABLE membership&quot;;

    private static final String TRUNCATE_MEMBERSHIP_TX = &quot;TRUNCATE TABLE membership_tx_operations&quot;;

    @Inject
    private DataSource dataSource;

    private NamedParameterJdbcTemplate jdbcTemplate;

    private DbPlatform dbPlatform;

    private static final int MEMBERSHIP_LIMIT = 50000;

    @PostConstruct
    public void setUp() {
<span class="fc" id="L428">        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());</span>
<span class="fc" id="L429">        dbPlatform = DbPlatform.fromDataSource(dataSource);</span>
<span class="fc" id="L430">    }</span>

    /**
     * End a membership from the child of a Direct/IndirectContainer, setting an end time if committed,
     * or clearing from the current tx if it was newly added.
     *
     * @param tx transaction
     * @param sourceId ID of the direct/indirect container whose membership should be ended
     * @param proxyId ID of the proxy producing this membership, when applicable
     * @param endTime the time the resource was deleted, generally its last modified
     */
    public void endMembershipFromChild(final Transaction tx, final FedoraId sourceId, final FedoraId proxyId,
            final Instant endTime) {
<span class="fc" id="L443">        tx.doInTx(() -&gt; {</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">            if (!tx.isShortLived()) {</span>
<span class="fc" id="L445">                final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="fc" id="L446">                parameterSource.addValue(TX_ID_PARAM, tx.getId());</span>
<span class="fc" id="L447">                parameterSource.addValue(SOURCE_ID_PARAM, sourceId.getFullId());</span>
<span class="fc" id="L448">                parameterSource.addValue(PROXY_ID_PARAM, proxyId.getFullId());</span>

<span class="fc" id="L450">                final int affected = jdbcTemplate.update(CLEAR_FOR_PROXY_IN_TX, parameterSource);</span>

                // If no rows were deleted, then assume we need to delete permanent entry
<span class="fc bfc" id="L453" title="All 2 branches covered.">                if (affected == 0) {</span>
<span class="fc" id="L454">                    final MapSqlParameterSource parameterSource2 = new MapSqlParameterSource();</span>
<span class="fc" id="L455">                    parameterSource2.addValue(TX_ID_PARAM, tx.getId());</span>
<span class="fc" id="L456">                    parameterSource2.addValue(SOURCE_ID_PARAM, sourceId.getFullId());</span>
<span class="fc" id="L457">                    parameterSource2.addValue(PROXY_ID_PARAM, proxyId.getFullId());</span>
<span class="fc" id="L458">                    parameterSource2.addValue(END_TIME_PARAM, formatInstant(endTime));</span>
<span class="fc" id="L459">                    parameterSource2.addValue(NO_END_TIME_PARAM, NO_END_TIMESTAMP);</span>
<span class="fc" id="L460">                    parameterSource2.addValue(DELETE_OP_PARAM, DELETE_OPERATION);</span>
<span class="fc" id="L461">                    jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);</span>
                }
<span class="fc" id="L463">            } else {</span>
<span class="nc" id="L464">                final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="nc" id="L465">                parameterSource.addValue(SOURCE_ID_PARAM, sourceId.getFullId());</span>
<span class="nc" id="L466">                parameterSource.addValue(PROXY_ID_PARAM, proxyId.getFullId());</span>
<span class="nc" id="L467">                parameterSource.addValue(END_TIME_PARAM, formatInstant(endTime));</span>
<span class="nc" id="L468">                parameterSource.addValue(NO_END_TIME_PARAM, NO_END_TIMESTAMP);</span>
<span class="nc" id="L469">                jdbcTemplate.update(DIRECT_END_EXISTING_MEMBERSHIP, parameterSource);</span>
            }
<span class="fc" id="L471">        });</span>
<span class="fc" id="L472">    }</span>

    public void deleteMembershipForProxyAfter(final Transaction tx,
                                              final FedoraId sourceId,
                                              final FedoraId proxyId,
                                              final Instant afterTime) {
<span class="nc" id="L478">        tx.doInTx(() -&gt; {</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">            final var afterTimestamp = afterTime == null ? NO_START_TIMESTAMP : formatInstant(afterTime);</span>

<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (!tx.isShortLived()) {</span>
                // Clear all membership added in this transaction
<span class="nc" id="L483">                final var parameterSource = Map.of(</span>
<span class="nc" id="L484">                        TX_ID_PARAM, tx.getId(),</span>
<span class="nc" id="L485">                        SOURCE_ID_PARAM, sourceId.getFullId(),</span>
<span class="nc" id="L486">                        PROXY_ID_PARAM, proxyId.getFullId(),</span>
                        OPERATION_PARAM, ADD_OPERATION);

<span class="nc" id="L489">                jdbcTemplate.update(CLEAR_FOR_PROXY_IN_TX, parameterSource);</span>

                // Delete all existing membership entries that start after or end after the given timestamp
<span class="nc" id="L492">                final Map&lt;String, Object&gt; parameterSource2 = Map.of(</span>
<span class="nc" id="L493">                        TX_ID_PARAM, tx.getId(),</span>
<span class="nc" id="L494">                        PROXY_ID_PARAM, proxyId.getFullId(),</span>
                        START_TIME_PARAM, afterTimestamp,
                        FORCE_PARAM, FORCE_FLAG,
                        DELETE_OP_PARAM, DELETE_OPERATION);
<span class="nc" id="L498">                jdbcTemplate.update(DELETE_EXISTING_FOR_PROXY_AFTER, parameterSource2);</span>
<span class="nc" id="L499">            } else {</span>
<span class="nc" id="L500">                final Map&lt;String, Object&gt; parameterSource = Map.of(</span>
<span class="nc" id="L501">                        PROXY_ID_PARAM, proxyId.getFullId(),</span>
                        END_TIME_PARAM, afterTimestamp);
<span class="nc" id="L503">                jdbcTemplate.update(DIRECT_DELETE_EXISTING_FOR_PROXY_AFTER, parameterSource);</span>
            }
<span class="nc" id="L505">        });</span>
<span class="nc" id="L506">    }</span>

    /**
     * End all membership properties resulting from the specified source container
     * @param tx transaction
     * @param sourceId ID of the direct/indirect container whose membership should be ended
     * @param endTime the time the resource was deleted, generally its last modified
     */
    public void endMembershipForSource(final Transaction tx, final FedoraId sourceId, final Instant endTime) {
<span class="fc" id="L515">        tx.doInTx(() -&gt; {</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">            if (!tx.isShortLived()) {</span>
<span class="fc" id="L517">                final Map&lt;String, Object&gt; parameterSource = Map.of(</span>
<span class="fc" id="L518">                        TX_ID_PARAM, tx.getId(),</span>
<span class="fc" id="L519">                        SOURCE_ID_PARAM, sourceId.getFullId(),</span>
                        ADD_OP_PARAM, ADD_OPERATION);

<span class="fc" id="L522">                jdbcTemplate.update(CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX, parameterSource);</span>

<span class="fc" id="L524">                final Map&lt;String, Object&gt; parameterSource2 = Map.of(</span>
<span class="fc" id="L525">                        TX_ID_PARAM, tx.getId(),</span>
<span class="fc" id="L526">                        SOURCE_ID_PARAM, sourceId.getFullId(),</span>
<span class="fc" id="L527">                        END_TIME_PARAM, formatInstant(endTime),</span>
                        NO_END_TIME_PARAM, NO_END_TIMESTAMP,
                        DELETE_OP_PARAM, DELETE_OPERATION);
<span class="fc" id="L530">                jdbcTemplate.update(END_EXISTING_FOR_SOURCE, parameterSource2);</span>
<span class="fc" id="L531">            } else {</span>
<span class="nc" id="L532">                final Map&lt;String, Object&gt; parameterSource = Map.of(</span>
<span class="nc" id="L533">                        SOURCE_ID_PARAM, sourceId.getFullId(),</span>
<span class="nc" id="L534">                        END_TIME_PARAM, formatInstant(endTime),</span>
                        NO_END_TIME_PARAM, NO_END_TIMESTAMP);
<span class="nc" id="L536">                jdbcTemplate.update(DIRECT_END_EXISTING_FOR_SOURCE, parameterSource);</span>
            }
<span class="fc" id="L538">        });</span>
<span class="fc" id="L539">    }</span>

    /**
     * Delete membership entries that are active at or after the given timestamp for the specified source
     * @param tx transaction
     * @param sourceId ID of the direct/indirect container
     * @param afterTime time at or after which membership should be removed
     */
    public void deleteMembershipForSourceAfter(final Transaction tx, final FedoraId sourceId, final Instant afterTime) {
<span class="fc" id="L548">        tx.doInTx(() -&gt; {</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">            final var afterTimestamp = afterTime == null ? NO_START_TIMESTAMP : formatInstant(afterTime);</span>

<span class="pc bpc" id="L551" title="1 of 2 branches missed.">            if (!tx.isShortLived()) {</span>
                // Clear all membership added in this transaction
<span class="fc" id="L553">                final Map&lt;String, Object&gt; parameterSource = Map.of(</span>
<span class="fc" id="L554">                        TX_ID_PARAM, tx.getId(),</span>
<span class="fc" id="L555">                        SOURCE_ID_PARAM, sourceId.getFullId(),</span>
                        ADD_OP_PARAM, ADD_OPERATION);

<span class="fc" id="L558">                jdbcTemplate.update(CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX, parameterSource);</span>

                // Delete all existing membership entries that start after or end after the given timestamp
<span class="fc" id="L561">                final Map&lt;String, Object&gt; parameterSource2 = Map.of(</span>
<span class="fc" id="L562">                        TX_ID_PARAM, tx.getId(),</span>
<span class="fc" id="L563">                        SOURCE_ID_PARAM, sourceId.getFullId(),</span>
                        START_TIME_PARAM, afterTimestamp,
                        FORCE_PARAM, FORCE_FLAG,
                        DELETE_OP_PARAM, DELETE_OPERATION);
<span class="fc" id="L567">                jdbcTemplate.update(DELETE_EXISTING_FOR_SOURCE_AFTER, parameterSource2);</span>
<span class="fc" id="L568">            } else {</span>
<span class="nc" id="L569">                final Map&lt;String, Object&gt; parameterSource = Map.of(</span>
<span class="nc" id="L570">                        SOURCE_ID_PARAM, sourceId.getFullId(),</span>
                        START_TIME_PARAM, afterTimestamp);
<span class="nc" id="L572">                jdbcTemplate.update(DIRECT_DELETE_EXISTING_FOR_SOURCE_AFTER, parameterSource);</span>
            }
<span class="fc" id="L574">        });</span>
<span class="fc" id="L575">    }</span>

    /**
     * Clean up any references to the target id, in transactions and outside
     * @param txId transaction id
     * @param targetId identifier of the resource to cleanup membership references for
     */
    public void deleteMembershipReferences(final String txId, final FedoraId targetId) {
<span class="fc" id="L583">        final Map&lt;String, Object&gt; parameterSource = Map.of(</span>
<span class="fc" id="L584">                TARGET_ID_PARAM, targetId.getFullId(),</span>
                TX_ID_PARAM, txId);

<span class="fc" id="L587">        jdbcTemplate.update(PURGE_ALL_REFERENCES_TRANSACTION, parameterSource);</span>
<span class="fc" id="L588">        jdbcTemplate.update(PURGE_ALL_REFERENCES_MEMBERSHIP, parameterSource);</span>
<span class="fc" id="L589">    }</span>

    /**
     * Add new membership property to the index, clearing any delete
     * operations for the property if necessary.
     * @param tx transaction
     * @param sourceId ID of the direct/indirect container which produced the membership
     * @param proxyId ID of the proxy producing this membership, when applicable
     * @param membership membership triple
     * @param startTime time the membership triple was added
     */
    public void addMembership(final Transaction tx, final FedoraId sourceId, final FedoraId proxyId,
            final Triple membership, final Instant startTime) {
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">        if (membership == null) {</span>
<span class="nc" id="L603">            return;</span>
        }
<span class="fc" id="L605">        addMembership(tx, sourceId, proxyId, membership, startTime, null);</span>
<span class="fc" id="L606">    }</span>

    /**
     * Add new membership property to the index
     * @param tx transaction
     * @param sourceId ID of the direct/indirect container which produced the membership
     * @param proxyId ID of the proxy producing this membership, when applicable
     * @param membership membership triple
     * @param startTime time the membership triple was added
     * @param endTime time the membership triple ends, or never if not provided
     */
    public void addMembership(final Transaction tx, final FedoraId sourceId, final FedoraId proxyId,
            final Triple membership, final Instant startTime, final Instant endTime) {
<span class="fc" id="L619">        tx.doInTx(() -&gt; {</span>
            final Timestamp endTimestamp;
            final Timestamp lastUpdated;
<span class="fc" id="L622">            final Timestamp startTimestamp = formatInstant(startTime);</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">            if (endTime == null) {</span>
<span class="fc" id="L624">                endTimestamp = NO_END_TIMESTAMP;</span>
<span class="fc" id="L625">                lastUpdated = startTimestamp;</span>
            } else {
<span class="fc" id="L627">                endTimestamp = formatInstant(endTime);</span>
<span class="fc" id="L628">                lastUpdated = endTimestamp;</span>
            }
            // Add the new membership operation
<span class="fc" id="L631">            final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="fc" id="L632">            parameterSource.addValue(SUBJECT_ID_PARAM, membership.getSubject().getURI());</span>
<span class="fc" id="L633">            parameterSource.addValue(PROPERTY_PARAM, membership.getPredicate().getURI());</span>
<span class="fc" id="L634">            parameterSource.addValue(TARGET_ID_PARAM, membership.getObject().getURI());</span>
<span class="fc" id="L635">            parameterSource.addValue(SOURCE_ID_PARAM, sourceId.getFullId());</span>
<span class="fc" id="L636">            parameterSource.addValue(PROXY_ID_PARAM, proxyId.getFullId());</span>
<span class="fc" id="L637">            parameterSource.addValue(START_TIME_PARAM, startTimestamp);</span>
<span class="fc" id="L638">            parameterSource.addValue(END_TIME_PARAM, endTimestamp);</span>
<span class="fc" id="L639">            parameterSource.addValue(LAST_UPDATED_PARAM, lastUpdated);</span>

<span class="pc bpc" id="L641" title="1 of 2 branches missed.">            if (!tx.isShortLived()) {</span>
<span class="fc" id="L642">                parameterSource.addValue(TX_ID_PARAM, tx.getId());</span>
<span class="fc" id="L643">                parameterSource.addValue(OPERATION_PARAM, ADD_OPERATION);</span>
<span class="fc" id="L644">                jdbcTemplate.update(INSERT_MEMBERSHIP_IN_TX, parameterSource);</span>
            } else {
<span class="nc" id="L646">                jdbcTemplate.update(DIRECT_INSERT_MEMBERSHIP, parameterSource);</span>
            }
<span class="fc" id="L648">        });</span>
<span class="fc" id="L649">    }</span>

    /**
     * Get a stream of membership triples with
     * @param tx transaction from which membership will be retrieved, or null for no transaction
     * @param subjectId ID of the subject
     * @return Stream of membership triples
     */
    public Stream&lt;Triple&gt; getMembership(final Transaction tx, final FedoraId subjectId) {
<span class="fc" id="L658">        final Node subjectNode = NodeFactory.createURI(subjectId.getBaseId());</span>

<span class="fc" id="L660">        final RowMapper&lt;Triple&gt; membershipMapper = (rs, rowNum) -&gt;</span>
<span class="fc" id="L661">                Triple.create(subjectNode,</span>
<span class="fc" id="L662">                        NodeFactory.createURI(rs.getString(&quot;property&quot;)),</span>
<span class="fc" id="L663">                        NodeFactory.createURI(rs.getString(&quot;object_id&quot;)));</span>

<span class="fc" id="L665">        final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
        final String query;

<span class="fc bfc" id="L668" title="All 2 branches covered.">        if (subjectId.isMemento()) {</span>
<span class="fc" id="L669">            parameterSource.addValue(SUBJECT_ID_PARAM, subjectId.getBaseId());</span>
<span class="fc" id="L670">            parameterSource.addValue(MEMENTO_TIME_PARAM, formatInstant(subjectId.getMementoInstant()));</span>
        } else {
<span class="fc" id="L672">            parameterSource.addValue(SUBJECT_ID_PARAM, subjectId.getFullId());</span>
<span class="fc" id="L673">            parameterSource.addValue(NO_END_TIME_PARAM, NO_END_TIMESTAMP);</span>
        }

<span class="fc bfc" id="L676" title="All 2 branches covered.">        if (tx.isOpenLongRunning()) {</span>
<span class="fc" id="L677">            parameterSource.addValue(TX_ID_PARAM, tx.getId());</span>

<span class="fc bfc" id="L679" title="All 2 branches covered.">            if (subjectId.isMemento()) {</span>
<span class="fc" id="L680">                query = SELECT_MEMBERSHIP_MEMENTO_IN_TX;</span>
            } else {
<span class="fc" id="L682">                query = SELECT_MEMBERSHIP_IN_TX;</span>
            }
        } else {
<span class="fc bfc" id="L685" title="All 2 branches covered.">            if (subjectId.isMemento()) {</span>
<span class="fc" id="L686">                query = DIRECT_SELECT_MEMBERSHIP_MEMENTO;</span>
            } else {
<span class="fc" id="L688">                query = DIRECT_SELECT_MEMBERSHIP;</span>
            }
        }

<span class="fc" id="L692">        return StreamSupport.stream(new MembershipIterator(query, parameterSource, membershipMapper), false);</span>
    }

    public Instant getLastUpdated(final Transaction transaction, final FedoraId subjectId) {
<span class="fc" id="L696">        final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>

<span class="fc" id="L698">        parameterSource.addValue(NO_END_TIME_PARAM, NO_END_TIMESTAMP);</span>
        final String lastUpdatedQuery;
<span class="pc bpc" id="L700" title="1 of 2 branches missed.">        if (subjectId.isMemento()) {</span>
<span class="nc" id="L701">            lastUpdatedQuery = SELECT_LAST_UPDATED_MEMENTO;</span>
<span class="nc" id="L702">            parameterSource.addValue(SUBJECT_ID_PARAM, subjectId.getBaseId());</span>
<span class="nc" id="L703">            parameterSource.addValue(MEMENTO_TIME_PARAM, formatInstant(subjectId.getMementoInstant()));</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">        } else if (transaction.isOpenLongRunning()) {</span>
<span class="fc" id="L705">            lastUpdatedQuery = SELECT_LAST_UPDATED_IN_TX;</span>
<span class="fc" id="L706">            parameterSource.addValue(SUBJECT_ID_PARAM, subjectId.getFullId());</span>
<span class="fc" id="L707">            parameterSource.addValue(TX_ID_PARAM, transaction.getId());</span>
<span class="fc" id="L708">            parameterSource.addValue(DELETE_OP_PARAM, DELETE_OPERATION);</span>
        } else {
<span class="fc" id="L710">            lastUpdatedQuery = SELECT_LAST_UPDATED;</span>
<span class="fc" id="L711">            parameterSource.addValue(SUBJECT_ID_PARAM, subjectId.getFullId());</span>
        }

<span class="fc" id="L714">        final var updated = jdbcTemplate.queryForObject(lastUpdatedQuery, parameterSource, Timestamp.class);</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">        if (updated != null) {</span>
<span class="fc" id="L716">            return updated.toInstant();</span>
        }
<span class="fc" id="L718">        return null;</span>
    }

    /**
     * Perform a commit of operations stored in the specified transaction
     * @param tx transaction
     */
    public void commitTransaction(final Transaction tx) {
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">        if (!tx.isShortLived()) {</span>
<span class="fc" id="L727">            tx.ensureCommitting();</span>
<span class="fc" id="L728">            final Map&lt;String, String&gt; parameterSource = Map.of(</span>
<span class="fc" id="L729">                    TX_ID_PARAM, tx.getId(),</span>
                    ADD_OP_PARAM, ADD_OPERATION,
                    DELETE_OP_PARAM, DELETE_OPERATION,
                    FORCE_PARAM, FORCE_FLAG);

<span class="fc" id="L734">            jdbcTemplate.update(COMMIT_DELETES, parameterSource);</span>
<span class="fc" id="L735">            final int ends = jdbcTemplate.update(COMMIT_ENDS_MAP.get(this.dbPlatform), parameterSource);</span>
<span class="fc" id="L736">            final int adds = jdbcTemplate.update(COMMIT_ADDS, parameterSource);</span>
<span class="fc" id="L737">            final int cleaned = jdbcTemplate.update(DELETE_TRANSACTION, parameterSource);</span>

<span class="fc" id="L739">            log.debug(&quot;Completed commit, {} ended, {} adds, {} operations&quot;, ends, adds, cleaned);</span>
        }
<span class="fc" id="L741">    }</span>

    /**
     * Delete all entries related to a transaction
     * @param tx transaction
     */
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void deleteTransaction(final Transaction tx) {
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">        if (!tx.isShortLived()) {</span>
<span class="fc" id="L750">            final Map&lt;String, String&gt; parameterSource = Map.of(TX_ID_PARAM, tx.getId());</span>
<span class="fc" id="L751">            jdbcTemplate.update(DELETE_TRANSACTION, parameterSource);</span>
        }
<span class="fc" id="L753">    }</span>

    /**
     * Format an instant to a timestamp without milliseconds, due to precision
     * issues with memento datetimes.
     * @param instant the instant
     * @return a Timestamp
     */
    private Timestamp formatInstant(final Instant instant) {
<span class="fc" id="L762">        final var timestamp = Timestamp.from(instant);</span>
<span class="fc" id="L763">        timestamp.setNanos(0);</span>
<span class="fc" id="L764">        return timestamp;</span>
    }

    /**
     * Clear all entries from the index
     */
    public void clearIndex() {
<span class="fc" id="L771">        jdbcTemplate.update(TRUNCATE_MEMBERSHIP, Map.of());</span>
<span class="fc" id="L772">        jdbcTemplate.update(TRUNCATE_MEMBERSHIP_TX, Map.of());</span>
<span class="fc" id="L773">    }</span>

    /**
     * Log all membership entries, for debugging usage only
     */
    protected void logMembership() {
<span class="nc" id="L779">        log.info(&quot;source_id, proxy_id, subject_id, property, object_id, start_time, end_time, last_updated&quot;);</span>
<span class="nc" id="L780">        jdbcTemplate.query(SELECT_ALL_MEMBERSHIP, new RowCallbackHandler() {</span>
            @Override
            public void processRow(final ResultSet rs) throws SQLException {
<span class="nc" id="L783">                log.info(&quot;{}, {}, {}, {}, {}, {}, {}, {}&quot;,</span>
<span class="nc" id="L784">                        rs.getString(&quot;source_id&quot;), rs.getString(&quot;proxy_id&quot;), rs.getString(&quot;subject_id&quot;),</span>
<span class="nc" id="L785">                        rs.getString(&quot;property&quot;), rs.getString(&quot;object_id&quot;), rs.getTimestamp(&quot;start_time&quot;),</span>
<span class="nc" id="L786">                        rs.getTimestamp(&quot;end_time&quot;), rs.getTimestamp(&quot;last_updated&quot;));</span>
<span class="nc" id="L787">            }</span>
        });
<span class="nc" id="L789">    }</span>

    /**
     * Log all membership operations, for debugging usage only
     */
    protected void logOperations() {
<span class="nc" id="L795">        log.info(&quot;source_id, proxy_id, subject_id, property, object_id, start_time, end_time,&quot;</span>
                + &quot; last_updated, tx_id, operation, force_flag&quot;);
<span class="nc" id="L797">        jdbcTemplate.query(SELECT_ALL_OPERATIONS, new RowCallbackHandler() {</span>
            @Override
            public void processRow(final ResultSet rs) throws SQLException {
<span class="nc" id="L800">                log.info(&quot;{}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}&quot;,</span>
<span class="nc" id="L801">                        rs.getString(&quot;source_id&quot;), rs.getString(&quot;proxy_id&quot;), rs.getString(&quot;subject_id&quot;),</span>
<span class="nc" id="L802">                        rs.getString(&quot;property&quot;), rs.getString(&quot;object_id&quot;), rs.getTimestamp(&quot;start_time&quot;),</span>
<span class="nc" id="L803">                        rs.getTimestamp(&quot;end_time&quot;), rs.getTimestamp(&quot;last_updated&quot;), rs.getString(&quot;tx_id&quot;),</span>
<span class="nc" id="L804">                        rs.getString(&quot;operation&quot;), rs.getString(&quot;force_flag&quot;));</span>
<span class="nc" id="L805">            }</span>
        });
<span class="nc" id="L807">    }</span>

    /**
     * Set the JDBC datastore.
     * @param dataSource the dataStore.
     */
    public void setDataSource(final DataSource dataSource) {
<span class="fc" id="L814">        this.dataSource = dataSource;</span>
<span class="fc" id="L815">    }</span>

    /**
     * Get the JDBC datastore.
     * @return the dataStore.
     */
    public DataSource getDataSource() {
<span class="fc" id="L822">        return dataSource;</span>
    }

    /**
     * Private class to back a stream with a paged DB query.
     *
     * If this needs to be run in parallel we will have to override trySplit() and determine a good method to split on.
     */
    private class MembershipIterator extends Spliterators.AbstractSpliterator&lt;Triple&gt; {
<span class="fc" id="L831">        final Queue&lt;Triple&gt; children = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L832">        int numOffsets = 0;</span>
        final String queryToUse;
        final MapSqlParameterSource parameterSource;
        final RowMapper&lt;Triple&gt; rowMapper;

        public MembershipIterator(final String query, final MapSqlParameterSource parameters,
<span class="fc" id="L838">                                  final RowMapper&lt;Triple&gt; mapper) {</span>
<span class="fc" id="L839">            super(Long.MAX_VALUE, Spliterator.ORDERED);</span>
<span class="fc" id="L840">            queryToUse = query;</span>
<span class="fc" id="L841">            parameterSource = parameters;</span>
<span class="fc" id="L842">            rowMapper = mapper;</span>
<span class="fc" id="L843">            parameterSource.addValue(ADD_OP_PARAM, ADD_OPERATION);</span>
<span class="fc" id="L844">            parameterSource.addValue(DELETE_OP_PARAM, DELETE_OPERATION);</span>
<span class="fc" id="L845">            parameterSource.addValue(LIMIT_PARAM, MEMBERSHIP_LIMIT);</span>
<span class="fc" id="L846">        }</span>

        @Override
        public boolean tryAdvance(final Consumer&lt;? super Triple&gt; action) {
            try {
<span class="fc" id="L851">                action.accept(children.remove());</span>
<span class="fc" id="L852">            } catch (final NoSuchElementException e) {</span>
<span class="fc" id="L853">                parameterSource.addValue(OFFSET_PARAM, numOffsets * MEMBERSHIP_LIMIT);</span>
<span class="fc" id="L854">                numOffsets += 1;</span>
<span class="fc" id="L855">                children.addAll(jdbcTemplate.query(queryToUse, parameterSource, rowMapper));</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">                if (children.size() == 0) {</span>
                    // no more elements.
<span class="fc" id="L858">                    return false;</span>
                }
<span class="fc" id="L860">                action.accept(children.remove());</span>
<span class="fc" id="L861">            }</span>
<span class="fc" id="L862">            return true;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>