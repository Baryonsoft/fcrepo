<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>OcflPropsConfig.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Fedora Repository Deployable Web Application</a> &gt; <a href="../index.html" class="el_bundle">fcrepo-configs</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.config</a> &gt; <span class="el_source">OcflPropsConfig.java</span></div><h1>OcflPropsConfig.java</h1><pre class="source lang-java linenums">/*
 * Licensed to DuraSpace under one or more contributor license agreements.
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * DuraSpace licenses this file to you under the Apache License,
 * Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.fcrepo.config;

import java.io.IOException;
import java.nio.file.Path;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import javax.annotation.PostConstruct;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;

/**
 * Fedora's OCFL related configuration properties
 *
 * @author pwinckles
 * @since 6.0.0
 */
@Configuration
<span class="fc" id="L41">public class OcflPropsConfig extends BasePropsConfig {</span>

<span class="fc" id="L43">    private static final Logger LOGGER = LoggerFactory.getLogger(OcflPropsConfig.class);</span>

    public static final String FCREPO_OCFL_STAGING = &quot;fcrepo.ocfl.staging&quot;;
    public static final String FCREPO_OCFL_ROOT = &quot;fcrepo.ocfl.root&quot;;
    public static final String FCREPO_OCFL_TEMP = &quot;fcrepo.ocfl.temp&quot;;
    private static final String FCREPO_OCFL_S3_BUCKET = &quot;fcrepo.ocfl.s3.bucket&quot;;

    private static final String OCFL_STAGING = &quot;staging&quot;;
    private static final String OCFL_ROOT = &quot;ocfl-root&quot;;
    private static final String OCFL_TEMP = &quot;ocfl-temp&quot;;

    private static final String FCREPO_PERSISTENCE_ALGORITHM = &quot;fcrepo.persistence.defaultDigestAlgorithm&quot;;

    @Value(&quot;${&quot; + FCREPO_OCFL_STAGING + &quot;:#{fedoraPropsConfig.fedoraData.resolve('&quot; + OCFL_STAGING + &quot;')}}&quot;)
    private Path fedoraOcflStaging;

    @Value(&quot;${&quot; + FCREPO_OCFL_ROOT + &quot;:#{fedoraPropsConfig.fedoraData.resolve('&quot; + OCFL_ROOT + &quot;')}}&quot;)
    private Path ocflRepoRoot;

    @Value(&quot;${&quot; + FCREPO_OCFL_TEMP + &quot;:#{fedoraPropsConfig.fedoraData.resolve('&quot; + OCFL_TEMP + &quot;')}}&quot;)
    private Path ocflTemp;

    /**
     * Controls whether changes are committed to new OCFL versions or to a mutable HEAD
     */
    @Value(&quot;${fcrepo.autoversioning.enabled:true}&quot;)
    private boolean autoVersioningEnabled;

    @Value(&quot;${fcrepo.storage:ocfl-fs}&quot;)
    private String storageStr;
    private Storage storage;

    @Value(&quot;${fcrepo.aws.access-key:}&quot;)
    private String awsAccessKey;

    @Value(&quot;${fcrepo.aws.secret-key:}&quot;)
    private String awsSecretKey;

    @Value(&quot;${fcrepo.aws.region:}&quot;)
    private String awsRegion;

    @Value(&quot;${fcrepo.s3.endpoint:}&quot;)
    private String s3Endpoint;

    @Value(&quot;${fcrepo.s3.path.style.access:false}&quot;)
    private boolean pathStyleAccessEnabled;

    @Value(&quot;${&quot; + FCREPO_OCFL_S3_BUCKET + &quot;:}&quot;)
    private String ocflS3Bucket;

    @Value(&quot;${fcrepo.ocfl.s3.prefix:}&quot;)
    private String ocflS3Prefix;

    @Value(&quot;${fcrepo.resource-header-cache.enable:true}&quot;)
    private boolean resourceHeadersCacheEnabled;

    @Value(&quot;${fcrepo.resource-header-cache.max-size:512}&quot;)
    private long resourceHeadersCacheMaxSize;

    @Value(&quot;${fcrepo.resource-header-cache.expire-after-seconds:600}&quot;)
    private long resourceHeadersCacheExpireAfterSeconds;

    @Value(&quot;${fcrepo.ocfl.reindex.threads:-1}&quot;)
    private long reindexThreads;

    @Value(&quot;${fcrepo.ocfl.reindex.batchSize:100}&quot;)
    private long reindexBatchSize;

    @Value(&quot;${fcrepo.ocfl.reindex.failOnError:true}&quot;)
    private boolean reindexFailOnError;

    @Value(&quot;${&quot; + FCREPO_PERSISTENCE_ALGORITHM + &quot;:sha512}&quot;)
    private String FCREPO_DIGEST_ALGORITHM_VALUE;

    @Value(&quot;${fcrepo.ocfl.s3.db.enabled:true}&quot;)
    private boolean ocflS3DbEnabled;

    @Value(&quot;${fcrepo.ocfl.unsafe.write.enabled:false}&quot;)
    private boolean unsafeWriteEnabled;

    @Value(&quot;${fcrepo.cache.db.ocfl.id_map.size.entries:1024}&quot;)
    private long fedoraToOcflCacheSize;

    @Value(&quot;${fcrepo.cache.db.ocfl.id_map.timeout.minutes:30}&quot;)
    private long fedoraToOcflCacheTimeout;

    private DigestAlgorithm FCREPO_DIGEST_ALGORITHM;

    /**
     * List of valid choices for fcrepo.persistence.defaultDigestAlgorithm
     */
<span class="fc" id="L134">    private static final List&lt;DigestAlgorithm&gt; FCREPO_VALID_DIGEST_ALGORITHMS = List.of(</span>
            DigestAlgorithm.SHA256,
            DigestAlgorithm.SHA512
    );

<span class="fc" id="L139">    private static final long availableThreads = Runtime.getRuntime().availableProcessors();</span>

    @PostConstruct
    private void postConstruct() throws IOException {
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        if (reindexThreads &lt; 0L) {</span>
<span class="fc" id="L144">            reindexThreads = computeDefaultReindexThreads();</span>
        } else {
<span class="nc" id="L146">            reindexThreads = checkReindexThreadLimit(reindexThreads);</span>
        }
<span class="fc" id="L148">        storage = Storage.fromString(storageStr);</span>
<span class="fc" id="L149">        LOGGER.info(&quot;Fedora storage type: {}&quot;, storage);</span>
<span class="fc" id="L150">        LOGGER.info(&quot;Fedora staging: {}&quot;, fedoraOcflStaging);</span>
<span class="fc" id="L151">        LOGGER.info(&quot;Fedora OCFL temp: {}&quot;, ocflTemp);</span>
<span class="fc" id="L152">        LOGGER.info(&quot;Fedora OCFL reindexing threads: {}&quot;, reindexThreads);</span>
<span class="fc" id="L153">        LOGGER.info(&quot;Fedora OCFL reindexing batch size: {}&quot;, reindexBatchSize);</span>
<span class="fc" id="L154">        LOGGER.info(&quot;Fedora OCFL reindexing fail on error: {}&quot;, reindexFailOnError);</span>
<span class="fc" id="L155">        createDirectories(fedoraOcflStaging);</span>
<span class="fc" id="L156">        createDirectories(ocflTemp);</span>

<span class="pc bpc" id="L158" title="1 of 2 branches missed.">        if (storage == Storage.OCFL_FILESYSTEM) {</span>
<span class="fc" id="L159">            LOGGER.info(&quot;Fedora OCFL root: {}&quot;, ocflRepoRoot);</span>
<span class="fc" id="L160">            createDirectories(ocflRepoRoot);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        } else if (storage == Storage.OCFL_S3) {</span>
<span class="nc" id="L162">            Objects.requireNonNull(ocflS3Bucket,</span>
<span class="nc" id="L163">                    String.format(&quot;The property %s must be set when OCFL S3 storage is used&quot;, FCREPO_OCFL_S3_BUCKET));</span>

<span class="nc" id="L165">            LOGGER.info(&quot;Fedora AWS access key: {}&quot;, awsAccessKey);</span>
<span class="nc" id="L166">            LOGGER.info(&quot;Fedora AWS secret key set: {}&quot;, Objects.isNull(awsSecretKey));</span>
<span class="nc" id="L167">            LOGGER.info(&quot;Fedora AWS region: {}&quot;, awsRegion);</span>
<span class="nc" id="L168">            LOGGER.info(&quot;Fedora OCFL S3 bucket: {}&quot;, ocflS3Bucket);</span>
<span class="nc" id="L169">            LOGGER.info(&quot;Fedora OCFL S3 prefix: {}&quot;, ocflS3Prefix);</span>
        }
<span class="fc" id="L171">        FCREPO_DIGEST_ALGORITHM = DigestAlgorithm.fromAlgorithm(FCREPO_DIGEST_ALGORITHM_VALUE);</span>
        // Throw error if the configured default digest is not known to fedora or is not a valid option
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        if (DigestAlgorithm.MISSING.equals(FCREPO_DIGEST_ALGORITHM) ||</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">                !FCREPO_VALID_DIGEST_ALGORITHMS.contains(FCREPO_DIGEST_ALGORITHM)) {</span>
<span class="nc" id="L175">            throw new IllegalArgumentException(String.format(&quot;Invalid %s property configured: %s, must be one of %s&quot;,</span>
                    FCREPO_PERSISTENCE_ALGORITHM, FCREPO_DIGEST_ALGORITHM_VALUE,
<span class="nc" id="L177">                    FCREPO_VALID_DIGEST_ALGORITHMS.stream().map(DigestAlgorithm::getAlgorithm)</span>
<span class="nc" id="L178">                            .collect(Collectors.joining(&quot;, &quot;))));</span>
        }
<span class="fc" id="L180">        LOGGER.info(&quot;Fedora OCFL digest algorithm: {}&quot;, FCREPO_DIGEST_ALGORITHM.getAlgorithm());</span>
<span class="fc" id="L181">    }</span>

    /**
     * @return Path to directory Fedora stages resources before moving them into OCFL
     */
    public Path getFedoraOcflStaging() {
<span class="fc" id="L187">        return fedoraOcflStaging;</span>
    }

    /**
     * Sets the path to the Fedora staging directory -- should only be used for testing purposes.
     *
     * @param fedoraOcflStaging Path to Fedora staging directory
     */
    public void setFedoraOcflStaging(final Path fedoraOcflStaging) {
<span class="nc" id="L196">        this.fedoraOcflStaging = fedoraOcflStaging;</span>
<span class="nc" id="L197">    }</span>

    /**
     * @return Path to OCFL root directory
     */
    public Path getOcflRepoRoot() {
<span class="fc" id="L203">        return ocflRepoRoot;</span>
    }

    /**
     * Sets the path to the Fedora OCFL root directory -- should only be used for testing purposes.
     *
     * @param ocflRepoRoot Path to Fedora OCFL root directory
     */
    public void setOcflRepoRoot(final Path ocflRepoRoot) {
<span class="nc" id="L212">        this.ocflRepoRoot = ocflRepoRoot;</span>
<span class="nc" id="L213">    }</span>

    /**
     * @return Path to the temp directory used by the OCFL client
     */
    public Path getOcflTemp() {
<span class="fc" id="L219">        return ocflTemp;</span>
    }

    /**
     * Sets the path to the OCFL temp directory -- should only be used for testing purposes.
     *
     * @param ocflTemp Path to OCFL temp directory
     */
    public void setOcflTemp(final Path ocflTemp) {
<span class="nc" id="L228">        this.ocflTemp = ocflTemp;</span>
<span class="nc" id="L229">    }</span>

    /**
     * @return true if every update should create a new OCFL version; false if the mutable HEAD should be used
     */
    public boolean isAutoVersioningEnabled() {
<span class="fc" id="L235">        return autoVersioningEnabled;</span>
    }

    /**
     * Determines whether or not new OCFL versions are created on every update.
     *
     * @param autoVersioningEnabled true to create new versions on every update
     */
    public void setAutoVersioningEnabled(final boolean autoVersioningEnabled) {
<span class="fc" id="L244">        this.autoVersioningEnabled = autoVersioningEnabled;</span>
<span class="fc" id="L245">    }</span>

    /**
     * @return Indicates the storage type. ocfl-fs is the default
     */
    public Storage getStorage() {
<span class="fc" id="L251">        return storage;</span>
    }

    /**
     * @param storage storage to use
     */
    public void setStorage(final Storage storage) {
<span class="nc" id="L258">        this.storage = storage;</span>
<span class="nc" id="L259">    }</span>

    /**
     * @return the aws access key to use, may be null
     */
    public String getAwsAccessKey() {
<span class="nc" id="L265">        return awsAccessKey;</span>
    }

    /**
     * @param awsAccessKey the aws access key to use
     */
    public void setAwsAccessKey(final String awsAccessKey) {
<span class="nc" id="L272">        this.awsAccessKey = awsAccessKey;</span>
<span class="nc" id="L273">    }</span>

    /**
     * @return the aws secret key to use, may be null
     */
    public String getAwsSecretKey() {
<span class="nc" id="L279">        return awsSecretKey;</span>
    }

    /**
     * @param awsSecretKey the aws secret key to use
     */
    public void setAwsSecretKey(final String awsSecretKey) {
<span class="nc" id="L286">        this.awsSecretKey = awsSecretKey;</span>
<span class="nc" id="L287">    }</span>

    /**
     * @return the aws region to use, may be null
     */
    public String getAwsRegion() {
<span class="nc" id="L293">        return awsRegion;</span>
    }

    /**
     * @param awsRegion the aws region to use
     */
    public void setAwsRegion(final String awsRegion) {
<span class="nc" id="L300">        this.awsRegion = awsRegion;</span>
<span class="nc" id="L301">    }</span>

    /**
     * @return the s3 bucket to store objects in
     */
    public String getOcflS3Bucket() {
<span class="nc" id="L307">        return ocflS3Bucket;</span>
    }

    /**
     * @param ocflS3Bucket sets the s3 bucket to store objects in
     */
    public void setOcflS3Bucket(final String ocflS3Bucket) {
<span class="nc" id="L314">        this.ocflS3Bucket = ocflS3Bucket;</span>
<span class="nc" id="L315">    }</span>

    /**
     * @return the s3 prefix to store objects under, may be null
     */
    public String getOcflS3Prefix() {
<span class="nc" id="L321">        return ocflS3Prefix;</span>
    }

    /**
     * @param ocflS3Prefix the prefix to store objects under
     */
    public void setOcflS3Prefix(final String ocflS3Prefix) {
<span class="nc" id="L328">        this.ocflS3Prefix = ocflS3Prefix;</span>
<span class="nc" id="L329">    }</span>

    /**
     * @return whether or not to enable the resource headers cache
     */
    public boolean isResourceHeadersCacheEnabled() {
<span class="fc" id="L335">        return resourceHeadersCacheEnabled;</span>
    }

    /**
     * @param resourceHeadersCacheEnabled whether or not to enable the resource headers cache
     */
    public void setResourceHeadersCacheEnabled(final boolean resourceHeadersCacheEnabled) {
<span class="nc" id="L342">        this.resourceHeadersCacheEnabled = resourceHeadersCacheEnabled;</span>
<span class="nc" id="L343">    }</span>

    /**
     * @return maximum number or resource headers in cache
     */
    public long getResourceHeadersCacheMaxSize() {
<span class="nc" id="L349">        return resourceHeadersCacheMaxSize;</span>
    }

    /**
     * @param resourceHeadersCacheMaxSize maximum number of resource headers in cache
     */
    public void setResourceHeadersCacheMaxSize(final long resourceHeadersCacheMaxSize) {
<span class="nc" id="L356">        this.resourceHeadersCacheMaxSize = resourceHeadersCacheMaxSize;</span>
<span class="nc" id="L357">    }</span>

    /**
     * @return number of seconds to wait before expiring a resource header from the cache
     */
    public long getResourceHeadersCacheExpireAfterSeconds() {
<span class="nc" id="L363">        return resourceHeadersCacheExpireAfterSeconds;</span>
    }

    /**
     * @param resourceHeadersCacheExpireAfterSeconds
     *      number of seconds to wait before expiring a resource header from the cache
     */
    public void setResourceHeadersCacheExpireAfterSeconds(final long resourceHeadersCacheExpireAfterSeconds) {
<span class="nc" id="L371">        this.resourceHeadersCacheExpireAfterSeconds = resourceHeadersCacheExpireAfterSeconds;</span>
<span class="nc" id="L372">    }</span>

    /**
     * @param threads
     *   number of threads to use when rebuilding from Fedora OCFL on disk.
     */
    public void setReindexingThreads(final long threads) {
<span class="nc" id="L379">        this.reindexThreads = checkReindexThreadLimit(threads);</span>
<span class="nc" id="L380">    }</span>

    /**
     * @return number of threads to use when rebuilding from Fedora OCFL on disk.
     */
    public long getReindexingThreads() {
<span class="fc" id="L386">        return this.reindexThreads;</span>
    }

    /**
     * @return number of OCFL ids for a the reindexing manager to hand out at once.
     */
    public long getReindexBatchSize() {
<span class="fc" id="L393">        return reindexBatchSize;</span>
    }

    /**
     * @param reindexBatchSize
     *   number of OCFL ids for a the reindexing manager to hand out at once.
     */
    public void setReindexBatchSize(final long reindexBatchSize) {
<span class="nc" id="L401">        this.reindexBatchSize = reindexBatchSize;</span>
<span class="nc" id="L402">    }</span>

    /**
     * @return whether to stop the entire reindexing process if a single object fails.
     */
    public boolean isReindexFailOnError() {
<span class="fc" id="L408">        return reindexFailOnError;</span>
    }

    /**
     * @param reindexFailOnError
     *   whether to stop the entire reindexing process if a single object fails.
     */
    public void setReindexFailOnError(final boolean reindexFailOnError) {
<span class="nc" id="L416">        this.reindexFailOnError = reindexFailOnError;</span>
<span class="nc" id="L417">    }</span>

    /**
     * Check we don't create too few reindexing threads.
     * @param threads the number of threads requested.
     * @return higher of the requested amount or 1
     */
    private long checkReindexThreadLimit(final long threads) {
<span class="nc bnc" id="L425" title="All 2 branches missed.">       if (threads &lt;= 0) {</span>
<span class="nc" id="L426">            LOGGER.warn(&quot;Can't have fewer than 1 reindexing thread, setting to 1.&quot;);</span>
<span class="nc" id="L427">            return 1;</span>
        } else {
<span class="nc" id="L429">            return threads;</span>
        }
    }

    /**
     * @return number of available processors minus 1.
     */
    private static long computeDefaultReindexThreads() {
<span class="fc" id="L437">        return Math.max(availableThreads - 1, 1);</span>
    }

    /**
     * @return the configured OCFL digest algorithm
     */
    public DigestAlgorithm getDefaultDigestAlgorithm() {
<span class="fc" id="L444">        return FCREPO_DIGEST_ALGORITHM;</span>
    }

    /**
     * @return an optional custom s3 endpoint or null
     */
    public String getS3Endpoint() {
<span class="nc" id="L451">        return s3Endpoint;</span>
    }

    /**
     * @return true if path style S3 access should be used
     */
    public boolean isPathStyleAccessEnabled() {
<span class="nc" id="L458">        return pathStyleAccessEnabled;</span>
    }

    /**
     * @return true if the ocfl client should be configured to use a database when storing objects in S3
     */
    public boolean isOcflS3DbEnabled() {
<span class="nc" id="L465">        return ocflS3DbEnabled;</span>
    }

    /**
     * When unsafe writes are enabled, the OCFL client does not calculate a digest for files that are added, and
     * trusts the digest value that it's given. If this value is incorrect, the object will be corrupted.
     *
     * @return true if objects should be written to OCFL using an &quot;unsafe&quot; write
     */
    public boolean isUnsafeWriteEnabled() {
<span class="fc" id="L475">        return unsafeWriteEnabled;</span>
    }

    /**
     * @return Size of the fedoraToOcflIndex cache.
     */
    public long getFedoraToOcflCacheSize() {
<span class="fc" id="L482">        return fedoraToOcflCacheSize;</span>
    }

    /**
     * @return Time to cache expiration in minutes.
     */
    public long getFedoraToOcflCacheTimeout() {
<span class="fc" id="L489">        return fedoraToOcflCacheTimeout;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>